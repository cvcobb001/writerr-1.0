{
  "version": 3,
  "sources": ["src/event-filtering-system.ts", "src/event-bus-integration.ts", "src/error-handling/ai-submission-error-manager.ts", "src/error-handling/retry-recovery-manager.ts", "src/performance-optimization.ts", "src/conflict-detection-algorithms.ts", "src/change-merging-algorithms.ts", "src/change-consolidation-manager.ts", "src/event-coordination-patterns.ts", "src/main.ts", "src/settings.ts", "../../shared/utils/index.ts", "src/validation/sanitization-utils.ts", "src/validation/ai-metadata-validator.ts", "src/queries/query-builder.ts", "src/queries/query-utils.ts", "src/queries/edit-change-query-system.ts", "src/edit-tracker.ts", "src/edit-renderer.ts", "src/side-panel-view.ts", "src/edit-cluster-manager.ts", "src/ui/ToggleStateManager.ts", "src/components/ToggleConfirmationModal.ts", "src/change-grouping-system.ts", "src/change-batch-manager.ts", "src/types/submit-changes-from-ai.ts", "src/plugin-system/plugin-interface.ts", "src/utils.ts", "src/plugin-system/plugin-registry.ts", "src/plugin-system/plugin-security-validator.ts", "src/plugin-system/plugin-capability-validator.ts", "src/plugin-system/editorial-engine-plugin.ts", "src/plugin-system/plugin-api.ts", "src/event-persistence-manager.ts"],
  "sourcesContent": ["/**\n * Event Filtering System for Preventing Feedback Loops\n * \n * This system provides comprehensive event filtering to prevent circular dependencies\n * and feedback loops between plugins in the Writerr Platform ecosystem.\n * \n * Key Features:\n * - Loop detection algorithms for event chains\n * - Event source tracking and correlation\n * - Plugin interaction mapping\n * - Temporal filtering for rapid-fire events\n * - Event chain analysis and visualization\n */\n\nimport { WriterrlEvent, WriterrlEventV2 } from './event-bus-integration';\n\n// ============================================================================\n// Core Types and Interfaces\n// ============================================================================\n\nexport interface EventChainNode {\n  eventId: string;\n  eventType: string;\n  sourcePlugin: string;\n  timestamp: number;\n  sessionId?: string;\n  parentEventId?: string;\n  depth: number;\n  correlationId: string;\n}\n\nexport interface EventLoopDetectionResult {\n  hasLoop: boolean;\n  loopPath?: EventChainNode[];\n  loopType: LoopType;\n  severity: LoopSeverity;\n  preventionAction: PreventionAction;\n}\n\nexport enum LoopType {\n  DIRECT_CIRCULAR = 'direct_circular',           // A \u2192 B \u2192 A\n  INDIRECT_CIRCULAR = 'indirect_circular',       // A \u2192 B \u2192 C \u2192 A\n  OSCILLATING = 'oscillating',                   // A \u2194 B \u2194 A (rapid back-and-forth)\n  CASCADE_FEEDBACK = 'cascade_feedback',         // Multiple events causing exponential growth\n  TEMPORAL_LOOP = 'temporal_loop'                // Time-based rapid firing\n}\n\nexport enum LoopSeverity {\n  LOW = 'low',           // Manageable, warning only\n  MEDIUM = 'medium',     // Requires intervention\n  HIGH = 'high',         // Immediate termination needed\n  CRITICAL = 'critical'  // System stability threat\n}\n\nexport enum PreventionAction {\n  ALLOW = 'allow',                    // Event passes through\n  WARN = 'warn',                      // Log warning but allow\n  DELAY = 'delay',                    // Introduce delay before processing\n  THROTTLE = 'throttle',              // Rate limit similar events\n  BLOCK = 'block',                    // Prevent event processing\n  TERMINATE_CHAIN = 'terminate_chain'  // Stop entire event chain\n}\n\nexport interface EventFrequencyTracker {\n  eventType: string;\n  sourcePlugin: string;\n  count: number;\n  firstOccurrence: number;\n  lastOccurrence: number;\n  averageInterval: number;\n  isRunaway: boolean;\n}\n\nexport interface PluginInteractionMap {\n  sourcePlugin: string;\n  targetPlugin: string;\n  eventTypes: string[];\n  frequency: number;\n  lastInteraction: number;\n  riskScore: number;\n}\n\nexport interface EventFilteringConfig {\n  // Loop Detection Settings\n  maxEventChainDepth: number;\n  loopDetectionWindowMs: number;\n  circularReferenceThreshold: number;\n  \n  // Frequency Control\n  maxEventsPerSecond: number;\n  rapidFireThresholdMs: number;\n  runawayEventThreshold: number;\n  \n  // Plugin Interaction Limits\n  maxPluginInteractionsPerSecond: number;\n  pluginCooldownMs: number;\n  \n  // Performance Settings\n  eventHistoryLimit: number;\n  correlationCleanupIntervalMs: number;\n  \n  // Filtering Behavior\n  enableLoopPrevention: boolean;\n  enableFrequencyThrottling: boolean;\n  enablePluginIsolation: boolean;\n  debugMode: boolean;\n}\n\nexport interface EventCorrelationData {\n  correlationId: string;\n  rootEventId: string;\n  eventChain: EventChainNode[];\n  createdAt: number;\n  lastUpdated: number;\n  isActive: boolean;\n  riskScore: number;\n}\n\n// ============================================================================\n// Event Filtering System Implementation\n// ============================================================================\n\nexport class EventFilteringSystem {\n  private config: EventFilteringConfig;\n  private eventHistory: Map<string, EventChainNode> = new Map();\n  private eventCorrelations: Map<string, EventCorrelationData> = new Map();\n  private pluginInteractions: Map<string, PluginInteractionMap> = new Map();\n  private frequencyTrackers: Map<string, EventFrequencyTracker> = new Map();\n  private cleanupInterval: NodeJS.Timeout | null = null;\n  private debugMode: boolean = false;\n\n  constructor(config: Partial<EventFilteringConfig> = {}) {\n    this.config = {\n      maxEventChainDepth: 10,\n      loopDetectionWindowMs: 30000, // 30 seconds\n      circularReferenceThreshold: 3,\n      maxEventsPerSecond: 50,\n      rapidFireThresholdMs: 100,\n      runawayEventThreshold: 20,\n      maxPluginInteractionsPerSecond: 25,\n      pluginCooldownMs: 500,\n      eventHistoryLimit: 1000,\n      correlationCleanupIntervalMs: 60000, // 1 minute\n      enableLoopPrevention: true,\n      enableFrequencyThrottling: true,\n      enablePluginIsolation: true,\n      debugMode: false,\n      ...config\n    };\n\n    this.debugMode = this.config.debugMode;\n    this.startCleanupTimer();\n  }\n\n  /**\n   * Main filtering method - analyzes event for potential feedback loops\n   */\n  async shouldProcessEvent(event: WriterrlEvent | WriterrlEventV2): Promise<EventLoopDetectionResult> {\n    const startTime = Date.now();\n\n    try {\n      // Create event chain node\n      const eventNode = this.createEventChainNode(event);\n      \n      // Perform multiple filtering checks\n      const results = await Promise.all([\n        this.detectDirectLoop(eventNode),\n        this.detectFrequencyLoop(eventNode),\n        this.detectPluginInteractionLoop(eventNode),\n        this.detectTemporalLoop(eventNode)\n      ]);\n\n      // Combine results and determine final action\n      const combinedResult = this.combineDetectionResults(results);\n\n      // Update tracking data\n      this.updateEventHistory(eventNode);\n      this.updateFrequencyTracking(eventNode);\n      this.updatePluginInteractionTracking(eventNode);\n      this.updateCorrelationData(eventNode, combinedResult);\n\n      // Log filtering decision\n      if (this.debugMode) {\n        console.log(`[EventFiltering] Event ${event.type} from ${event.sourcePlugin}: ${combinedResult.preventionAction} (${Date.now() - startTime}ms)`);\n      }\n\n      return combinedResult;\n\n    } catch (error) {\n      console.error('[EventFiltering] Error in shouldProcessEvent:', error);\n      \n      // Fail-safe: allow event but log error\n      return {\n        hasLoop: false,\n        loopType: LoopType.DIRECT_CIRCULAR,\n        severity: LoopSeverity.LOW,\n        preventionAction: PreventionAction.ALLOW\n      };\n    }\n  }\n\n  /**\n   * Detect direct circular references in event chains\n   */\n  private async detectDirectLoop(eventNode: EventChainNode): Promise<EventLoopDetectionResult> {\n    if (!this.config.enableLoopPrevention) {\n      return this.createAllowResult();\n    }\n\n    // Check for immediate circular reference\n    const correlationData = this.eventCorrelations.get(eventNode.correlationId);\n    if (correlationData) {\n      const eventChain = correlationData.eventChain;\n      \n      // Look for the same event type from the same plugin in the chain\n      const similarEvents = eventChain.filter(node => \n        node.eventType === eventNode.eventType && \n        node.sourcePlugin === eventNode.sourcePlugin\n      );\n\n      if (similarEvents.length >= this.config.circularReferenceThreshold) {\n        return {\n          hasLoop: true,\n          loopPath: [...eventChain, eventNode],\n          loopType: LoopType.DIRECT_CIRCULAR,\n          severity: LoopSeverity.HIGH,\n          preventionAction: PreventionAction.BLOCK\n        };\n      }\n\n      // Check for plugin ping-pong effect\n      if (eventChain.length >= 2) {\n        const lastEvent = eventChain[eventChain.length - 1];\n        const secondLastEvent = eventChain[eventChain.length - 2];\n        \n        if (lastEvent.sourcePlugin === eventNode.sourcePlugin &&\n            secondLastEvent.sourcePlugin === lastEvent.sourcePlugin &&\n            Date.now() - lastEvent.timestamp < this.config.rapidFireThresholdMs) {\n          \n          return {\n            hasLoop: true,\n            loopPath: [secondLastEvent, lastEvent, eventNode],\n            loopType: LoopType.OSCILLATING,\n            severity: LoopSeverity.MEDIUM,\n            preventionAction: PreventionAction.THROTTLE\n          };\n        }\n      }\n    }\n\n    return this.createAllowResult();\n  }\n\n  /**\n   * Detect frequency-based loops (runaway event generation)\n   */\n  private async detectFrequencyLoop(eventNode: EventChainNode): Promise<EventLoopDetectionResult> {\n    if (!this.config.enableFrequencyThrottling) {\n      return this.createAllowResult();\n    }\n\n    const frequencyKey = `${eventNode.sourcePlugin}:${eventNode.eventType}`;\n    const tracker = this.frequencyTrackers.get(frequencyKey);\n\n    if (tracker) {\n      const timeDiff = eventNode.timestamp - tracker.firstOccurrence;\n      const eventsPerSecond = (tracker.count * 1000) / Math.max(timeDiff, 1);\n\n      if (eventsPerSecond > this.config.maxEventsPerSecond) {\n        return {\n          hasLoop: true,\n          loopType: LoopType.CASCADE_FEEDBACK,\n          severity: LoopSeverity.HIGH,\n          preventionAction: PreventionAction.THROTTLE\n        };\n      }\n\n      if (tracker.count > this.config.runawayEventThreshold) {\n        return {\n          hasLoop: true,\n          loopType: LoopType.CASCADE_FEEDBACK,\n          severity: LoopSeverity.CRITICAL,\n          preventionAction: PreventionAction.TERMINATE_CHAIN\n        };\n      }\n    }\n\n    return this.createAllowResult();\n  }\n\n  /**\n   * Detect plugin interaction loops\n   */\n  private async detectPluginInteractionLoop(eventNode: EventChainNode): Promise<EventLoopDetectionResult> {\n    if (!this.config.enablePluginIsolation) {\n      return this.createAllowResult();\n    }\n\n    // Check for excessive plugin interactions\n    const interactionKey = eventNode.sourcePlugin;\n    const interactions = Array.from(this.pluginInteractions.values())\n      .filter(interaction => interaction.sourcePlugin === interactionKey);\n\n    const recentInteractions = interactions.filter(interaction => \n      eventNode.timestamp - interaction.lastInteraction < 1000\n    );\n\n    if (recentInteractions.length > this.config.maxPluginInteractionsPerSecond) {\n      return {\n        hasLoop: true,\n        loopType: LoopType.INDIRECT_CIRCULAR,\n        severity: LoopSeverity.MEDIUM,\n        preventionAction: PreventionAction.DELAY\n      };\n    }\n\n    return this.createAllowResult();\n  }\n\n  /**\n   * Detect temporal loops (rapid-fire events)\n   */\n  private async detectTemporalLoop(eventNode: EventChainNode): Promise<EventLoopDetectionResult> {\n    const recentEvents = Array.from(this.eventHistory.values())\n      .filter(node => \n        node.sourcePlugin === eventNode.sourcePlugin &&\n        node.eventType === eventNode.eventType &&\n        eventNode.timestamp - node.timestamp < this.config.rapidFireThresholdMs\n      );\n\n    if (recentEvents.length >= 3) {\n      return {\n        hasLoop: true,\n        loopPath: [...recentEvents, eventNode],\n        loopType: LoopType.TEMPORAL_LOOP,\n        severity: LoopSeverity.MEDIUM,\n        preventionAction: PreventionAction.DELAY\n      };\n    }\n\n    return this.createAllowResult();\n  }\n\n  /**\n   * Combine multiple detection results into final decision\n   */\n  private combineDetectionResults(results: EventLoopDetectionResult[]): EventLoopDetectionResult {\n    // Find the most severe result\n    const hasAnyLoop = results.some(r => r.hasLoop);\n    if (!hasAnyLoop) {\n      return this.createAllowResult();\n    }\n\n    // Sort by severity and get the most critical\n    const severityOrder = [LoopSeverity.CRITICAL, LoopSeverity.HIGH, LoopSeverity.MEDIUM, LoopSeverity.LOW];\n    const mostSevere = results\n      .filter(r => r.hasLoop)\n      .sort((a, b) => severityOrder.indexOf(a.severity) - severityOrder.indexOf(b.severity))[0];\n\n    return mostSevere;\n  }\n\n  /**\n   * Create event chain node from event\n   */\n  private createEventChainNode(event: WriterrlEvent | WriterrlEventV2): EventChainNode {\n    const eventId = this.generateEventId(event);\n    const correlationId = this.getOrCreateCorrelationId(event);\n    \n    return {\n      eventId,\n      eventType: event.type,\n      sourcePlugin: event.sourcePlugin,\n      timestamp: Date.now(),\n      sessionId: event.sessionId,\n      parentEventId: this.getParentEventId(event),\n      depth: this.calculateEventDepth(correlationId),\n      correlationId\n    };\n  }\n\n  /**\n   * Generate unique event ID\n   */\n  private generateEventId(event: WriterrlEvent | WriterrlEventV2): string {\n    return `${event.sourcePlugin}-${event.type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Get or create correlation ID for event chain tracking\n   */\n  private getOrCreateCorrelationId(event: WriterrlEvent | WriterrlEventV2): string {\n    // Check if this event has a correlation context\n    if ('correlationId' in event && event.correlationId) {\n      return event.correlationId;\n    }\n\n    // Create new correlation ID\n    return `correlation-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Get parent event ID from event context\n   */\n  private getParentEventId(event: WriterrlEvent | WriterrlEventV2): string | undefined {\n    if ('parentEventId' in event) {\n      return event.parentEventId;\n    }\n    return undefined;\n  }\n\n  /**\n   * Calculate event depth in chain\n   */\n  private calculateEventDepth(correlationId: string): number {\n    const correlationData = this.eventCorrelations.get(correlationId);\n    return correlationData ? correlationData.eventChain.length : 0;\n  }\n\n  /**\n   * Update event history\n   */\n  private updateEventHistory(eventNode: EventChainNode): void {\n    this.eventHistory.set(eventNode.eventId, eventNode);\n\n    // Cleanup old events\n    if (this.eventHistory.size > this.config.eventHistoryLimit) {\n      const oldestEvents = Array.from(this.eventHistory.entries())\n        .sort((a, b) => a[1].timestamp - b[1].timestamp)\n        .slice(0, Math.floor(this.config.eventHistoryLimit * 0.1));\n      \n      oldestEvents.forEach(([eventId]) => {\n        this.eventHistory.delete(eventId);\n      });\n    }\n  }\n\n  /**\n   * Update frequency tracking\n   */\n  private updateFrequencyTracking(eventNode: EventChainNode): void {\n    const frequencyKey = `${eventNode.sourcePlugin}:${eventNode.eventType}`;\n    const existing = this.frequencyTrackers.get(frequencyKey);\n\n    if (existing) {\n      existing.count++;\n      existing.lastOccurrence = eventNode.timestamp;\n      existing.averageInterval = (eventNode.timestamp - existing.firstOccurrence) / existing.count;\n      existing.isRunaway = existing.count > this.config.runawayEventThreshold;\n    } else {\n      this.frequencyTrackers.set(frequencyKey, {\n        eventType: eventNode.eventType,\n        sourcePlugin: eventNode.sourcePlugin,\n        count: 1,\n        firstOccurrence: eventNode.timestamp,\n        lastOccurrence: eventNode.timestamp,\n        averageInterval: 0,\n        isRunaway: false\n      });\n    }\n  }\n\n  /**\n   * Update plugin interaction tracking\n   */\n  private updatePluginInteractionTracking(eventNode: EventChainNode): void {\n    // This would be enhanced with actual target plugin detection\n    // For now, we track source plugin activity\n    const interactionKey = eventNode.sourcePlugin;\n    \n    if (!this.pluginInteractions.has(interactionKey)) {\n      this.pluginInteractions.set(interactionKey, {\n        sourcePlugin: eventNode.sourcePlugin,\n        targetPlugin: 'unknown', // Would be detected from event analysis\n        eventTypes: [eventNode.eventType],\n        frequency: 1,\n        lastInteraction: eventNode.timestamp,\n        riskScore: 0\n      });\n    } else {\n      const interaction = this.pluginInteractions.get(interactionKey)!;\n      interaction.frequency++;\n      interaction.lastInteraction = eventNode.timestamp;\n      interaction.riskScore = this.calculateRiskScore(interaction);\n      \n      if (!interaction.eventTypes.includes(eventNode.eventType)) {\n        interaction.eventTypes.push(eventNode.eventType);\n      }\n    }\n  }\n\n  /**\n   * Calculate risk score for plugin interactions\n   */\n  private calculateRiskScore(interaction: PluginInteractionMap): number {\n    const timeDiff = Date.now() - interaction.lastInteraction;\n    const frequencyScore = Math.min(interaction.frequency / 100, 1);\n    const recencyScore = Math.max(1 - (timeDiff / 60000), 0); // Decay over 1 minute\n    const diversityScore = Math.min(interaction.eventTypes.length / 10, 1);\n    \n    return (frequencyScore * 0.5) + (recencyScore * 0.3) + (diversityScore * 0.2);\n  }\n\n  /**\n   * Update correlation data\n   */\n  private updateCorrelationData(eventNode: EventChainNode, result: EventLoopDetectionResult): void {\n    const existing = this.eventCorrelations.get(eventNode.correlationId);\n    \n    if (existing) {\n      existing.eventChain.push(eventNode);\n      existing.lastUpdated = eventNode.timestamp;\n      existing.riskScore = this.calculateCorrelationRiskScore(existing, result);\n      existing.isActive = result.preventionAction !== PreventionAction.TERMINATE_CHAIN;\n    } else {\n      this.eventCorrelations.set(eventNode.correlationId, {\n        correlationId: eventNode.correlationId,\n        rootEventId: eventNode.eventId,\n        eventChain: [eventNode],\n        createdAt: eventNode.timestamp,\n        lastUpdated: eventNode.timestamp,\n        isActive: true,\n        riskScore: result.hasLoop ? 0.5 : 0\n      });\n    }\n  }\n\n  /**\n   * Calculate risk score for correlation data\n   */\n  private calculateCorrelationRiskScore(correlation: EventCorrelationData, result: EventLoopDetectionResult): number {\n    const chainLength = correlation.eventChain.length;\n    const lengthScore = Math.min(chainLength / this.config.maxEventChainDepth, 1);\n    const loopScore = result.hasLoop ? 0.8 : 0;\n    const timeScore = Math.max(1 - ((Date.now() - correlation.lastUpdated) / 30000), 0);\n    \n    return Math.min((lengthScore * 0.3) + (loopScore * 0.5) + (timeScore * 0.2), 1);\n  }\n\n  /**\n   * Create allow result\n   */\n  private createAllowResult(): EventLoopDetectionResult {\n    return {\n      hasLoop: false,\n      loopType: LoopType.DIRECT_CIRCULAR,\n      severity: LoopSeverity.LOW,\n      preventionAction: PreventionAction.ALLOW\n    };\n  }\n\n  /**\n   * Start cleanup timer\n   */\n  private startCleanupTimer(): void {\n    this.cleanupInterval = setInterval(() => {\n      this.performCleanup();\n    }, this.config.correlationCleanupIntervalMs);\n  }\n\n  /**\n   * Perform periodic cleanup\n   */\n  private performCleanup(): void {\n    const now = Date.now();\n    \n    // Clean up old correlations\n    for (const [correlationId, data] of this.eventCorrelations.entries()) {\n      if (now - data.lastUpdated > this.config.loopDetectionWindowMs) {\n        this.eventCorrelations.delete(correlationId);\n      }\n    }\n\n    // Clean up old frequency trackers\n    for (const [key, tracker] of this.frequencyTrackers.entries()) {\n      if (now - tracker.lastOccurrence > 60000) { // 1 minute\n        this.frequencyTrackers.delete(key);\n      }\n    }\n\n    // Clean up old plugin interactions\n    for (const [key, interaction] of this.pluginInteractions.entries()) {\n      if (now - interaction.lastInteraction > 300000) { // 5 minutes\n        this.pluginInteractions.delete(key);\n      }\n    }\n\n    if (this.debugMode) {\n      console.log(`[EventFiltering] Cleanup complete. Active correlations: ${this.eventCorrelations.size}, Frequency trackers: ${this.frequencyTrackers.size}, Plugin interactions: ${this.pluginInteractions.size}`);\n    }\n  }\n\n  /**\n   * Get system statistics\n   */\n  public getSystemStats(): {\n    activeCorrelations: number;\n    frequencyTrackers: number;\n    pluginInteractions: number;\n    eventHistorySize: number;\n    highRiskCorrelations: number;\n    runawayTrackers: number;\n  } {\n    const highRiskCorrelations = Array.from(this.eventCorrelations.values())\n      .filter(c => c.riskScore > 0.7).length;\n    \n    const runawayTrackers = Array.from(this.frequencyTrackers.values())\n      .filter(t => t.isRunaway).length;\n\n    return {\n      activeCorrelations: this.eventCorrelations.size,\n      frequencyTrackers: this.frequencyTrackers.size,\n      pluginInteractions: this.pluginInteractions.size,\n      eventHistorySize: this.eventHistory.size,\n      highRiskCorrelations,\n      runawayTrackers\n    };\n  }\n\n  /**\n   * Update configuration\n   */\n  public updateConfig(newConfig: Partial<EventFilteringConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    this.debugMode = this.config.debugMode;\n  }\n\n  /**\n   * Get current configuration\n   */\n  public getConfig(): EventFilteringConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Dispose and cleanup\n   */\n  public dispose(): void {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = null;\n    }\n    \n    this.eventHistory.clear();\n    this.eventCorrelations.clear();\n    this.pluginInteractions.clear();\n    this.frequencyTrackers.clear();\n  }\n}\n\n// ============================================================================\n// Event Filtering Integration Extensions\n// ============================================================================\n\nexport interface EventFilteringExtensions {\n  // Plugin responsibility boundary definitions\n  pluginCapabilities: Map<string, Set<string>>; // plugin -> allowed event types\n  eventOwnership: Map<string, string>; // event type -> responsible plugin\n  \n  // Enhanced filtering methods\n  shouldPluginHandleEvent(pluginId: string, eventType: string): boolean;\n  getPluginPriority(pluginId: string, eventType: string): number;\n  detectEventOwnershipConflict(event: WriterrlEvent | WriterrlEventV2): boolean;\n}\n\n/**\n * Enhanced event filtering with plugin responsibility boundaries\n */\nexport class EnhancedEventFilteringSystem extends EventFilteringSystem implements EventFilteringExtensions {\n  public pluginCapabilities = new Map<string, Set<string>>();\n  public eventOwnership = new Map<string, string>();\n  private pluginPriorities = new Map<string, Map<string, number>>();\n\n  constructor(config: Partial<EventFilteringConfig> = {}) {\n    super(config);\n    this.initializeDefaultCapabilities();\n  }\n\n  /**\n   * Initialize default plugin capabilities\n   */\n  private initializeDefaultCapabilities(): void {\n    // Track Edits Plugin capabilities\n    this.pluginCapabilities.set('track-edits', new Set([\n      'document.change.applied',\n      'document.change.reverted',\n      'ai.processing.complete',\n      'session.synchronization'\n    ]));\n\n    // Editorial Engine Plugin capabilities\n    this.pluginCapabilities.set('editorial-engine', new Set([\n      'ai.processing.start',\n      'ai.processing.progress',\n      'ai.processing.complete',\n      'ai.processing.error',\n      'constraint.validation'\n    ]));\n\n    // Writerr Chat Plugin capabilities\n    this.pluginCapabilities.set('writerr-chat', new Set([\n      'session.lifecycle',\n      'conversation.message',\n      'ai.processing.start',\n      'user.interaction'\n    ]));\n\n    // Define event ownership\n    this.eventOwnership.set('document.change.applied', 'track-edits');\n    this.eventOwnership.set('ai.processing.start', 'editorial-engine');\n    this.eventOwnership.set('session.lifecycle', 'writerr-chat');\n  }\n\n  /**\n   * Check if plugin should handle specific event type\n   */\n  public shouldPluginHandleEvent(pluginId: string, eventType: string): boolean {\n    const capabilities = this.pluginCapabilities.get(pluginId);\n    if (!capabilities) return false;\n    \n    return capabilities.has(eventType);\n  }\n\n  /**\n   * Get plugin priority for event type\n   */\n  public getPluginPriority(pluginId: string, eventType: string): number {\n    const pluginPriorities = this.pluginPriorities.get(pluginId);\n    if (!pluginPriorities) return 0;\n    \n    return pluginPriorities.get(eventType) || 0;\n  }\n\n  /**\n   * Detect event ownership conflicts\n   */\n  public detectEventOwnershipConflict(event: WriterrlEvent | WriterrlEventV2): boolean {\n    const expectedOwner = this.eventOwnership.get(event.type);\n    if (!expectedOwner) return false;\n    \n    return expectedOwner !== event.sourcePlugin;\n  }\n\n  /**\n   * Enhanced event filtering with plugin responsibility checks\n   */\n  public async shouldProcessEvent(event: WriterrlEvent | WriterrlEventV2): Promise<EventLoopDetectionResult> {\n    // First run the base filtering\n    const baseResult = await super.shouldProcessEvent(event);\n    \n    // If base filtering blocks, return that result\n    if (baseResult.preventionAction === PreventionAction.BLOCK || \n        baseResult.preventionAction === PreventionAction.TERMINATE_CHAIN) {\n      return baseResult;\n    }\n\n    // Check plugin responsibility boundaries\n    if (this.detectEventOwnershipConflict(event)) {\n      return {\n        hasLoop: true,\n        loopType: LoopType.INDIRECT_CIRCULAR,\n        severity: LoopSeverity.MEDIUM,\n        preventionAction: PreventionAction.WARN\n      };\n    }\n\n    return baseResult;\n  }\n\n  /**\n   * Register plugin capabilities\n   */\n  public registerPluginCapabilities(pluginId: string, capabilities: string[]): void {\n    this.pluginCapabilities.set(pluginId, new Set(capabilities));\n  }\n\n  /**\n   * Set event ownership\n   */\n  public setEventOwnership(eventType: string, ownerId: string): void {\n    this.eventOwnership.set(eventType, ownerId);\n  }\n}", "/**\n * Event Bus Integration Layer for Track Edits Plugin\n * \n * Provides comprehensive event bus connection management, health monitoring,\n * and cross-plugin coordination for the Writerr Platform ecosystem.\n * \n * @fileoverview Event bus integration with connection management and error handling\n * @version 1.0.0\n */\n\n// ============================================================================\n// Event Schema Definitions\n// ============================================================================\n\n/**\n * Base interface for all Writerr platform events\n */\nexport interface WriterrlEventBase {\n  eventId: string;\n  timestamp: number;\n  sourcePlugin: string;\n  targetPlugins?: string[];\n  sessionId?: string;\n  documentId?: string;\n}\n\n/**\n * Change events for AI processing notifications\n */\nexport interface WriterrlChangeEvent extends WriterrlEventBase {\n  type: 'change.ai.start' | 'change.ai.complete' | 'change.ai.error' | 'change.batch.created' | 'change.batch.processed';\n  payload: {\n    changeIds: string[];\n    aiProvider?: string;\n    aiModel?: string;\n    operationType?: string;\n    batchId?: string;\n    errorDetails?: any;\n    processingMetadata?: any;\n  };\n}\n\n/**\n * Document events for multi-plugin editing coordination\n */\nexport interface WriterrlDocumentEvent extends WriterrlEventBase {\n  type: 'document.edit.start' | 'document.edit.complete' | 'document.focus.changed' | 'document.save.before' | 'document.save.after';\n  payload: {\n    documentPath: string;\n    editorView?: any;\n    fileModified?: boolean;\n    activeView?: string;\n    editMetadata?: {\n      source: string;\n      editCount: number;\n      timestamp: number;\n    };\n  };\n}\n\n/**\n * Session events for cross-plugin synchronization\n */\nexport interface WriterrlSessionEvent extends WriterrlEventBase {\n  type: 'session.created' | 'session.ended' | 'session.paused' | 'session.resumed' | 'session.exported';\n  payload: {\n    sessionData: any;\n    participants: string[];\n    syncState?: 'active' | 'paused' | 'ended';\n    exportFormat?: string;\n    exportPath?: string;\n  };\n}\n\n/**\n * Error events for platform-wide error handling\n */\nexport interface WriterrlErrorEvent extends WriterrlEventBase {\n  type: 'error.plugin.failure' | 'error.system.critical' | 'error.recovery.attempted' | 'error.recovery.completed';\n  payload: {\n    errorType: string;\n    errorMessage: string;\n    errorStack?: string;\n    recoveryAction?: string;\n    affectedFeatures: string[];\n    severity: 'low' | 'medium' | 'high' | 'critical';\n  };\n}\n\n// ============================================================================\n// COMPREHENSIVE STANDARDIZED EVENT SCHEMAS FOR PLATFORM-WIDE COORDINATION\n// ============================================================================\n\n/**\n * Event Schema Version for backward compatibility\n */\nexport const WRITERR_EVENT_SCHEMA_VERSION = '1.0.0';\n\n/**\n * Event priority levels for coordination needs\n */\nexport enum EventPriority {\n  LOW = 0,\n  NORMAL = 1,\n  HIGH = 2,\n  CRITICAL = 3\n}\n\n/**\n * Event persistence requirements for offline synchronization\n */\nexport enum EventPersistence {\n  NONE = 'none',           // No persistence needed\n  SESSION = 'session',     // Persist for current session only\n  OFFLINE = 'offline',     // Persist for offline sync\n  PERMANENT = 'permanent'  // Permanent audit trail\n}\n\n/**\n * Enhanced base interface with versioning and metadata\n */\nexport interface WriterrlEventBaseV2 extends WriterrlEventBase {\n  /** Schema version for backward compatibility */\n  schemaVersion: string;\n  \n  /** Event priority for processing order */\n  priority: EventPriority;\n  \n  /** Persistence requirements */\n  persistence: EventPersistence;\n  \n  /** Event metadata for routing and debugging */\n  metadata: {\n    /** Correlation ID for tracking related events */\n    correlationId?: string;\n    \n    /** Parent event ID for event chains */\n    parentEventId?: string;\n    \n    /** Event sequence number within a workflow */\n    sequenceNumber?: number;\n    \n    /** Custom routing hints */\n    routingHints?: string[];\n    \n    /** Debug information */\n    debug?: {\n      sourceLocation?: string;\n      stackTrace?: string;\n      performanceMetrics?: Record<string, number>;\n    };\n  };\n  \n  /** Event expiration timestamp */\n  expiresAt?: number;\n  \n  /** Retry count for error recovery */\n  retryCount?: number;\n}\n\n// ============================================================================\n// AI PROCESSING LIFECYCLE EVENTS\n// ============================================================================\n\nexport interface AIProcessingStartEvent extends WriterrlEventBaseV2 {\n  type: 'ai.processing.start';\n  payload: {\n    /** Processing operation details */\n    operation: {\n      type: EditorialOperationType;\n      provider: string;\n      model: string;\n      requestId: string;\n    };\n    \n    /** Input context */\n    input: {\n      documentId: string;\n      content: string;\n      userPrompt: string;\n      constraints?: string[];\n    };\n    \n    /** Processing configuration */\n    config: {\n      expectedDuration?: number;\n      maxRetries: number;\n      timeoutMs: number;\n      batchSize?: number;\n    };\n    \n    /** Plugin context */\n    pluginContext: {\n      sourcePluginId: string;\n      sourcePluginVersion: string;\n      processingCapabilities: string[];\n    };\n  };\n}\n\nexport interface AIProcessingProgressEvent extends WriterrlEventBaseV2 {\n  type: 'ai.processing.progress';\n  payload: {\n    /** Reference to original request */\n    requestId: string;\n    \n    /** Progress information */\n    progress: {\n      percentage: number;\n      stage: string;\n      estimatedTimeRemaining?: number;\n      currentOperation?: string;\n    };\n    \n    /** Intermediate results */\n    partialResults?: {\n      processedCount: number;\n      totalCount: number;\n      previewChanges?: any[];\n    };\n    \n    /** Performance metrics */\n    metrics: {\n      tokensProcessed: number;\n      responseTime: number;\n      memoryUsage: number;\n    };\n  };\n}\n\nexport interface AIProcessingCompleteEvent extends WriterrlEventBaseV2 {\n  type: 'ai.processing.complete';\n  payload: {\n    /** Reference to original request */\n    requestId: string;\n    \n    /** Processing results */\n    results: {\n      changeIds: string[];\n      changeGroupId?: string;\n      summary: string;\n      confidence: number;\n      appliedConstraints: string[];\n    };\n    \n    /** Final metrics */\n    metrics: {\n      totalTokens: number;\n      processingTime: number;\n      qualityScore: number;\n      constraintCompliance: number;\n    };\n    \n    /** Next action recommendations */\n    recommendations?: {\n      suggestedReview: boolean;\n      recommendedBatching?: string;\n      followupActions?: string[];\n    };\n  };\n}\n\nexport interface AIProcessingErrorEvent extends WriterrlEventBaseV2 {\n  type: 'ai.processing.error';\n  payload: {\n    /** Reference to original request */\n    requestId: string;\n    \n    /** Error details */\n    error: {\n      type: string;\n      message: string;\n      code?: string;\n      stack?: string;\n      recoverability: 'recoverable' | 'non-recoverable';\n    };\n    \n    /** Context at time of error */\n    context: {\n      stage: string;\n      partialResults?: any[];\n      resourceUsage: Record<string, number>;\n    };\n    \n    /** Recovery options */\n    recovery: {\n      automaticRetryAvailable: boolean;\n      manualInterventionRequired: boolean;\n      suggestedActions: string[];\n      fallbackOptions?: string[];\n    };\n  };\n}\n\n// ============================================================================\n// DOCUMENT CHANGE EVENTS WITH DETAILED ATTRIBUTION\n// ============================================================================\n\nexport interface DocumentChangeStartEvent extends WriterrlEventBaseV2 {\n  type: 'document.change.start';\n  payload: {\n    /** Document information */\n    document: {\n      id: string;\n      path: string;\n      title: string;\n      contentHash: string;\n    };\n    \n    /** Change context */\n    changeContext: {\n      initiatingPlugin: string;\n      changeType: 'ai-assisted' | 'manual' | 'collaborative';\n      userIntent: string;\n      scopeDescription: string;\n    };\n    \n    /** Pre-change state */\n    beforeState: {\n      wordCount: number;\n      characterCount: number;\n      lastModified: number;\n      checksum: string;\n    };\n  };\n}\n\nexport interface DocumentChangeAppliedEvent extends WriterrlEventBaseV2 {\n  type: 'document.change.applied';\n  payload: {\n    /** Change details */\n    change: {\n      id: string;\n      type: string;\n      range: { start: number; end: number };\n      originalText: string;\n      newText: string;\n      confidence: number;\n    };\n    \n    /** Attribution */\n    attribution: {\n      source: 'ai' | 'user' | 'system';\n      aiProvider?: string;\n      aiModel?: string;\n      userSession?: string;\n      pluginId: string;\n      timestamp: number;\n    };\n    \n    /** Context */\n    context: {\n      reason: string;\n      constraints: string[];\n      qualityMetrics: Record<string, number>;\n      reviewRequired: boolean;\n    };\n  };\n}\n\nexport interface DocumentChangeBatchedEvent extends WriterrlEventBaseV2 {\n  type: 'document.change.batched';\n  payload: {\n    /** Batch information */\n    batch: {\n      id: string;\n      changeIds: string[];\n      groupingStrategy: string;\n      totalChanges: number;\n    };\n    \n    /** Batch context */\n    context: {\n      documentId: string;\n      userPrompt: string;\n      processingTime: number;\n      batchingReason: string;\n    };\n    \n    /** Batch metrics */\n    metrics: {\n      avgConfidence: number;\n      totalTextChanged: number;\n      impactScope: string[];\n    };\n  };\n}\n\nexport interface DocumentChangeRevertedEvent extends WriterrlEventBaseV2 {\n  type: 'document.change.reverted';\n  payload: {\n    /** Reversion details */\n    reversion: {\n      changeIds: string[];\n      revertedAt: number;\n      revertReason: string;\n      triggeredBy: 'user' | 'system' | 'plugin';\n    };\n    \n    /** Impact assessment */\n    impact: {\n      documentId: string;\n      affectedText: string;\n      dependentChanges: string[];\n      recoveryActions: string[];\n    };\n  };\n}\n\n// ============================================================================\n// SESSION MANAGEMENT EVENTS FOR CROSS-PLUGIN SYNCHRONIZATION\n// ============================================================================\n\nexport interface SessionLifecycleEvent extends WriterrlEventBaseV2 {\n  type: 'session.created' | 'session.resumed' | 'session.paused' | 'session.ended';\n  payload: {\n    /** Session details */\n    session: {\n      id: string;\n      type: 'editing' | 'reviewing' | 'collaborative';\n      ownerId: string;\n      participants: string[];\n      createdAt: number;\n    };\n    \n    /** Session state */\n    state: {\n      activeDocuments: string[];\n      pluginStates: Record<string, any>;\n      syncStatus: 'active' | 'paused' | 'syncing' | 'error';\n      lastSyncAt?: number;\n    };\n    \n    /** Context */\n    context: {\n      triggeredBy: string;\n      reason: string;\n      previousState?: string;\n      expectedDuration?: number;\n    };\n  };\n}\n\nexport interface SessionSynchronizationEvent extends WriterrlEventBaseV2 {\n  type: 'session.sync.start' | 'session.sync.complete' | 'session.sync.conflict';\n  payload: {\n    /** Sync operation */\n    sync: {\n      sessionId: string;\n      syncId: string;\n      participants: string[];\n      syncScope: string[];\n    };\n    \n    /** Sync data */\n    data: {\n      changesSynced?: number;\n      conflictsDetected?: number;\n      resolutionStrategy?: string;\n      syncedAt: number;\n    };\n    \n    /** Conflict details (if applicable) */\n    conflicts?: {\n      type: string;\n      affectedDocuments: string[];\n      resolutionOptions: string[];\n      autoResolved: boolean;\n    }[];\n  };\n}\n\n// ============================================================================\n// PLUGIN LIFECYCLE EVENTS FOR COORDINATION AND HEALTH MONITORING\n// ============================================================================\n\nexport interface PluginLifecycleEvent extends WriterrlEventBaseV2 {\n  type: 'plugin.registered' | 'plugin.activated' | 'plugin.deactivated' | 'plugin.unregistered';\n  payload: {\n    /** Plugin information */\n    plugin: {\n      id: string;\n      name: string;\n      version: string;\n      type: 'core' | 'editorial' | 'ui' | 'integration';\n      capabilities: string[];\n    };\n    \n    /** Lifecycle context */\n    lifecycle: {\n      previousState?: string;\n      newState: string;\n      reason: string;\n      triggeredBy: 'system' | 'user' | 'dependency';\n    };\n    \n    /** Dependencies */\n    dependencies: {\n      requiredPlugins: string[];\n      optionalPlugins: string[];\n      conflicts: string[];\n    };\n    \n    /** Health information */\n    health: {\n      status: 'healthy' | 'warning' | 'error';\n      lastCheck: number;\n      metrics: Record<string, number>;\n      issues: string[];\n    };\n  };\n}\n\nexport interface PluginHealthEvent extends WriterrlEventBaseV2 {\n  type: 'plugin.health.check' | 'plugin.health.warning' | 'plugin.health.error' | 'plugin.health.recovered';\n  payload: {\n    /** Plugin identification */\n    pluginId: string;\n    \n    /** Health details */\n    health: {\n      status: 'healthy' | 'warning' | 'error' | 'critical';\n      checkedAt: number;\n      checkType: 'periodic' | 'triggered' | 'startup';\n      previousStatus?: string;\n    };\n    \n    /** Metrics */\n    metrics: {\n      memoryUsage: number;\n      cpuUsage: number;\n      responseTime: number;\n      errorRate: number;\n      uptime: number;\n    };\n    \n    /** Issues */\n    issues: {\n      type: string;\n      severity: 'info' | 'warning' | 'error' | 'critical';\n      message: string;\n      suggestedAction?: string;\n    }[];\n    \n    /** Recovery information */\n    recovery?: {\n      attemptedAt: number;\n      successful: boolean;\n      strategy: string;\n      nextCheck: number;\n    };\n  };\n}\n\n// ============================================================================\n// PLATFORM-WIDE ERROR AND RECOVERY EVENTS\n// ============================================================================\n\nexport interface PlatformErrorEvent extends WriterrlEventBaseV2 {\n  type: 'platform.error.system' | 'platform.error.integration' | 'platform.error.data';\n  payload: {\n    /** Error classification */\n    error: {\n      category: 'system' | 'integration' | 'data' | 'security' | 'performance';\n      severity: 'low' | 'medium' | 'high' | 'critical';\n      code: string;\n      message: string;\n      stack?: string;\n    };\n    \n    /** Affected scope */\n    impact: {\n      affectedPlugins: string[];\n      affectedFeatures: string[];\n      affectedDocuments: string[];\n      userImpact: 'none' | 'minor' | 'major' | 'blocking';\n    };\n    \n    /** Context */\n    context: {\n      operationInProgress?: string;\n      userAction?: string;\n      systemState: Record<string, any>;\n      environmentInfo: Record<string, string>;\n    };\n    \n    /** Diagnostics */\n    diagnostics: {\n      errorId: string;\n      reportedAt: number;\n      reportedBy: string;\n      reproductionSteps?: string[];\n      logContext?: string;\n    };\n  };\n}\n\nexport interface PlatformRecoveryEvent extends WriterrlEventBaseV2 {\n  type: 'platform.recovery.initiated' | 'platform.recovery.progress' | 'platform.recovery.complete' | 'platform.recovery.failed';\n  payload: {\n    /** Recovery operation */\n    recovery: {\n      id: string;\n      errorId: string;\n      strategy: string;\n      initiatedBy: 'system' | 'user' | 'plugin';\n      initiatedAt: number;\n    };\n    \n    /** Recovery progress */\n    progress?: {\n      stage: string;\n      percentage: number;\n      estimatedTimeRemaining?: number;\n      completedSteps: string[];\n      currentStep: string;\n    };\n    \n    /** Recovery results */\n    result?: {\n      successful: boolean;\n      restoredFeatures: string[];\n      remainingIssues: string[];\n      dataIntegrity: 'verified' | 'partial' | 'compromised';\n    };\n    \n    /** Post-recovery state */\n    postRecovery?: {\n      systemStatus: 'operational' | 'degraded' | 'offline';\n      pluginStatuses: Record<string, string>;\n      recommendedActions: string[];\n      monitoringEnabled: boolean;\n    };\n  };\n}\n\n// ============================================================================\n// WORKFLOW COORDINATION EVENTS\n// ============================================================================\n\nexport interface WorkflowEvent extends WriterrlEventBaseV2 {\n  type: 'workflow.started' | 'workflow.step.complete' | 'workflow.complete' | 'workflow.cancelled';\n  payload: {\n    /** Workflow identification */\n    workflow: {\n      id: string;\n      name: string;\n      type: 'chat-to-editorial' | 'editorial-to-track' | 'collaborative-edit';\n      initiator: string;\n    };\n    \n    /** Workflow context */\n    context: {\n      documentId: string;\n      sessionId?: string;\n      participantPlugins: string[];\n      startedAt: number;\n      expectedSteps: string[];\n    };\n    \n    /** Current step (if applicable) */\n    currentStep?: {\n      name: string;\n      status: 'pending' | 'in-progress' | 'complete' | 'error';\n      assignedPlugin: string;\n      startedAt: number;\n      data?: any;\n    };\n    \n    /** Workflow results (if complete) */\n    results?: {\n      totalSteps: number;\n      completedSteps: number;\n      duration: number;\n      artifacts: string[];\n      success: boolean;\n    };\n  };\n}\n\n// ============================================================================\n// UPDATED UNION TYPE WITH NEW EVENTS\n// ============================================================================\n\nexport type WriterrlEventV2 = \n  // AI Processing Events\n  | AIProcessingStartEvent\n  | AIProcessingProgressEvent  \n  | AIProcessingCompleteEvent\n  | AIProcessingErrorEvent\n  \n  // Document Change Events\n  | DocumentChangeStartEvent\n  | DocumentChangeAppliedEvent\n  | DocumentChangeBatchedEvent\n  | DocumentChangeRevertedEvent\n  \n  // Session Management Events\n  | SessionLifecycleEvent\n  | SessionSynchronizationEvent\n  \n  // Plugin Lifecycle Events\n  | PluginLifecycleEvent\n  | PluginHealthEvent\n  \n  // Platform Error and Recovery Events\n  | PlatformErrorEvent\n  | PlatformRecoveryEvent\n  \n  // Workflow Coordination Events\n  | WorkflowEvent\n  \n  // Legacy events (for backward compatibility)\n  | WriterrlChangeEvent\n  | WriterrlDocumentEvent\n  | WriterrlSessionEvent\n  | WriterrlErrorEvent;\n\n// ============================================================================\n// EVENT CREATION HELPERS\n// ============================================================================\n\nexport class WriterrlEventFactory {\n  static createBaseEvent(\n    type: string,\n    sourcePlugin: string,\n    priority: EventPriority = EventPriority.NORMAL,\n    persistence: EventPersistence = EventPersistence.SESSION\n  ): Omit<WriterrlEventBaseV2, 'type' | 'payload'> {\n    return {\n      eventId: this.generateEventId(),\n      timestamp: Date.now(),\n      sourcePlugin,\n      schemaVersion: WRITERR_EVENT_SCHEMA_VERSION,\n      priority,\n      persistence,\n      metadata: {\n        correlationId: this.generateCorrelationId(),\n      },\n    };\n  }\n  \n  static generateEventId(): string {\n    return `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  static generateCorrelationId(): string {\n    return `corr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  static createAIProcessingStartEvent(\n    sourcePlugin: string,\n    operation: any,\n    input: any,\n    config: any,\n    pluginContext: any\n  ): AIProcessingStartEvent {\n    return {\n      ...this.createBaseEvent('ai.processing.start', sourcePlugin, EventPriority.HIGH),\n      type: 'ai.processing.start',\n      payload: { operation, input, config, pluginContext },\n    };\n  }\n  \n  static createDocumentChangeAppliedEvent(\n    sourcePlugin: string,\n    change: any,\n    attribution: any,\n    context: any\n  ): DocumentChangeAppliedEvent {\n    return {\n      ...this.createBaseEvent('document.change.applied', sourcePlugin, EventPriority.NORMAL, EventPersistence.PERMANENT),\n      type: 'document.change.applied',\n      payload: { change, attribution, context },\n    };\n  }\n  \n  static createWorkflowEvent(\n    type: WorkflowEvent['type'],\n    sourcePlugin: string,\n    workflow: any,\n    context: any,\n    currentStep?: any,\n    results?: any\n  ): WorkflowEvent {\n    return {\n      ...this.createBaseEvent(type, sourcePlugin, EventPriority.HIGH),\n      type,\n      payload: { workflow, context, currentStep, results },\n    };\n  }\n}\n\n// ============================================================================\n// EVENT VALIDATION UTILITIES\n// ============================================================================\n\nexport interface EventValidationResult {\n  valid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\nexport class WriterrlEventValidator {\n  static validateEvent(event: any): EventValidationResult {\n    const result: EventValidationResult = {\n      valid: true,\n      errors: [],\n      warnings: [],\n    };\n    \n    // Basic structure validation\n    if (!event.eventId) {\n      result.errors.push('Missing eventId');\n      result.valid = false;\n    }\n    \n    if (!event.timestamp) {\n      result.errors.push('Missing timestamp');\n      result.valid = false;\n    }\n    \n    if (!event.sourcePlugin) {\n      result.errors.push('Missing sourcePlugin');\n      result.valid = false;\n    }\n    \n    if (!event.type) {\n      result.errors.push('Missing event type');\n      result.valid = false;\n    }\n    \n    // Schema version validation\n    if (event.schemaVersion && event.schemaVersion !== WRITERR_EVENT_SCHEMA_VERSION) {\n      result.warnings.push(`Schema version mismatch: expected ${WRITERR_EVENT_SCHEMA_VERSION}, got ${event.schemaVersion}`);\n    }\n    \n    // Priority validation\n    if (event.priority !== undefined && !Object.values(EventPriority).includes(event.priority)) {\n      result.errors.push('Invalid priority value');\n      result.valid = false;\n    }\n    \n    // Persistence validation\n    if (event.persistence && !Object.values(EventPersistence).includes(event.persistence)) {\n      result.errors.push('Invalid persistence value');\n      result.valid = false;\n    }\n    \n    // Payload validation\n    if (!event.payload) {\n      result.errors.push('Missing payload');\n      result.valid = false;\n    }\n    \n    return result;\n  }\n  \n  static sanitizeEvent(event: any): any {\n    // Remove sensitive data and ensure safe serialization\n    const sanitized = { ...event };\n    \n    // Remove potential sensitive information from debug metadata\n    if (sanitized.metadata?.debug?.stackTrace) {\n      sanitized.metadata.debug.stackTrace = '[REDACTED]';\n    }\n    \n    // Ensure all required fields are present with defaults\n    if (!sanitized.schemaVersion) {\n      sanitized.schemaVersion = WRITERR_EVENT_SCHEMA_VERSION;\n    }\n    \n    if (!sanitized.priority) {\n      sanitized.priority = EventPriority.NORMAL;\n    }\n    \n    if (!sanitized.persistence) {\n      sanitized.persistence = EventPersistence.SESSION;\n    }\n    \n    if (!sanitized.metadata) {\n      sanitized.metadata = {};\n    }\n    \n    return sanitized;\n  }\n}\n\n/**\n * Union type for all Writerrl platform events\n */\nexport type WriterrlEvent = WriterrlChangeEvent | WriterrlDocumentEvent | WriterrlSessionEvent | WriterrlErrorEvent;\n\n/**\n * Event handler function type\n */\nexport type WriterrlEventHandler = (event: WriterrlEvent) => void | Promise<void>;\n\n/**\n * Event subscription options\n */\nexport interface EventSubscriptionOptions {\n  once?: boolean;\n  filter?: (event: WriterrlEvent) => boolean;\n  priority?: 'high' | 'normal' | 'low';\n  async?: boolean;\n}\n\n/**\n * Event publication options\n */\nexport interface EventPublicationOptions {\n  targetPlugins?: string[];\n  priority?: 'high' | 'normal' | 'low';\n  persistent?: boolean;\n  retryOnFailure?: boolean;\n}\n\n/**\n * Event bus interface definition\n */\nexport interface WriterrlEventBus {\n  on(eventType: string, handler: WriterrlEventHandler, options?: EventSubscriptionOptions): void;\n  off(eventType: string, handler: WriterrlEventHandler): void;\n  emit(eventType: string, event: WriterrlEvent, options?: EventPublicationOptions): Promise<void>;\n  getStats?(): any;\n  reset?(): void;\n}\n\n// ============================================================================\n// Event Bus Connection Management\n// ============================================================================\n\nimport { EditorialOperationType } from './types/submit-changes-from-ai';\n\nexport interface EventBusConnectionConfig {\n  maxReconnectAttempts?: number;\n  reconnectDelay?: number;\n  healthCheckInterval?: number;\n  enableDebugMode?: boolean;\n  eventFilters?: {\n    sourcePlugins?: string[];\n    eventTypes?: string[];\n    sessionIds?: string[];\n  };\n}\n\nexport interface EventBusConnectionHealth {\n  isConnected: boolean;\n  lastHeartbeat: number;\n  connectionAttempts: number;\n  eventsPublished: number;\n  eventsReceived: number;\n  errors: Array<{\n    timestamp: number;\n    error: string;\n    context: string;\n  }>;\n}\n\nexport class WriterrlEventBusConnection {\n  private eventBus: WriterrlEventBus | null = null;\n  private config: EventBusConnectionConfig;\n  private health: EventBusConnectionHealth;\n  private subscriptions = new Map<string, { handler: WriterrlEventHandler; options: EventSubscriptionOptions }>();\n  private connectionCheckInterval: NodeJS.Timeout | null = null;\n  private debugMode: boolean = false;\n  \n  // Event filtering system integration\n  private eventFilteringSystem: import('./event-filtering-system').EnhancedEventFilteringSystem | null = null;\n  private filteringEnabled: boolean = false;\n\n  constructor(config: EventBusConnectionConfig = {}) {\n    this.config = {\n      maxReconnectAttempts: 3,\n      reconnectDelay: 1000,\n      healthCheckInterval: 30000,\n      enableDebugMode: false,\n      ...config\n    };\n\n    this.health = {\n      isConnected: false,\n      lastHeartbeat: 0,\n      connectionAttempts: 0,\n      eventsPublished: 0,\n      eventsReceived: 0,\n      errors: []\n    };\n\n    this.debugMode = this.config.enableDebugMode || false;\n    \n    // Initialize event filtering system if enabled\n    this.initializeEventFiltering();\n  }\n\n  /**\n   * Initialize event filtering system\n   */\n  private async initializeEventFiltering(): Promise<void> {\n    try {\n      const { EnhancedEventFilteringSystem } = await import('./event-filtering-system');\n      \n      this.eventFilteringSystem = new EnhancedEventFilteringSystem({\n        enableLoopPrevention: true,\n        enableFrequencyThrottling: true,\n        enablePluginIsolation: true,\n        debugMode: this.debugMode,\n        maxEventChainDepth: 10,\n        maxEventsPerSecond: 50,\n        runawayEventThreshold: 20\n      });\n      \n      this.filteringEnabled = true;\n      \n      if (this.debugMode) {\n        console.log('[TrackEdits EventBus] Event filtering system initialized');\n      }\n    } catch (error) {\n      console.warn('[TrackEdits EventBus] Failed to initialize event filtering system:', error);\n      this.filteringEnabled = false;\n    }\n  }\n\n  /**\n   * Initialize connection to the window.Writerr event bus\n   */\n  async connect(): Promise<boolean> {\n    try {\n      // Check if window.Writerr exists and has event bus\n      if (typeof window !== 'undefined' && \n          (window as any).Writerr && \n          (window as any).Writerr.eventBus) {\n        \n        this.eventBus = (window as any).Writerr.eventBus;\n        this.health.isConnected = true;\n        this.health.lastHeartbeat = Date.now();\n        this.health.connectionAttempts++;\n\n        if (this.debugMode) {\n          console.log('[TrackEdits EventBus] Connected to window.Writerr event bus');\n        }\n\n        // Start health monitoring\n        this.startHealthMonitoring();\n        \n        // Re-subscribe to any existing subscriptions\n        await this.resubscribeAll();\n\n        return true;\n      } else {\n        this.logError('Event bus not available', 'connection');\n        return false;\n      }\n    } catch (error) {\n      this.logError(`Connection failed: ${error}`, 'connection');\n      return false;\n    }\n  }\n\n  /**\n   * Disconnect from event bus and cleanup\n   */\n  async disconnect(): Promise<void> {\n    try {\n      // Unsubscribe from all events\n      await this.unsubscribeAll();\n\n      // Stop health monitoring\n      if (this.connectionCheckInterval) {\n        clearInterval(this.connectionCheckInterval);\n        this.connectionCheckInterval = null;\n      }\n\n      // Dispose event filtering system\n      if (this.eventFilteringSystem) {\n        this.eventFilteringSystem.dispose();\n      }\n\n      this.eventBus = null;\n      this.health.isConnected = false;\n\n      if (this.debugMode) {\n        console.log('[TrackEdits EventBus] Disconnected from event bus');\n      }\n    } catch (error) {\n      this.logError(`Disconnect error: ${error}`, 'disconnect');\n    }\n  }\n\n  /**\n   * Subscribe to events with automatic reconnection handling and advanced filtering\n   */\n  async subscribe(\n    eventType: string, \n    handler: WriterrlEventHandler, \n    options: EventSubscriptionOptions = {}\n  ): Promise<boolean> {\n    try {\n      // Store subscription for reconnection\n      this.subscriptions.set(eventType, { handler, options });\n\n      if (!this.eventBus) {\n        if (this.debugMode) {\n          console.log(`[TrackEdits EventBus] Deferring subscription to ${eventType} until connected`);\n        }\n        return false;\n      }\n\n      // Create wrapped handler for filtering and error handling\n      const wrappedHandler: WriterrlEventHandler = async (event) => {\n        try {\n          // Apply basic configuration filters\n          if (!this.shouldProcessEvent(event)) {\n            return;\n          }\n\n          // Apply advanced event filtering to prevent feedback loops\n          if (this.filteringEnabled && this.eventFilteringSystem) {\n            const filterResult = await this.eventFilteringSystem.shouldProcessEvent(event);\n            \n            if (!this.shouldProcessFilteredEvent(filterResult, event)) {\n              return;\n            }\n          }\n\n          this.health.eventsReceived++;\n\n          if (this.debugMode) {\n            console.log(`[TrackEdits EventBus] Processing event: ${event.type}`, event);\n          }\n\n          await handler(event);\n        } catch (error) {\n          this.logError(`Event handler error for ${eventType}: ${error}`, 'handler');\n        }\n      };\n\n      this.eventBus.on(eventType, wrappedHandler, options);\n\n      if (this.debugMode) {\n        console.log(`[TrackEdits EventBus] Subscribed to ${eventType}`);\n      }\n\n      return true;\n    } catch (error) {\n      this.logError(`Subscription error for ${eventType}: ${error}`, 'subscription');\n      return false;\n    }\n  }\n\n  /**\n   * Determine whether to process event based on filtering result\n   */\n  private shouldProcessFilteredEvent(\n    filterResult: import('./event-filtering-system').EventLoopDetectionResult, \n    event: WriterrlEvent | WriterrlEventV2\n  ): boolean {\n    switch (filterResult.preventionAction) {\n      case 'allow':\n        return true;\n        \n      case 'warn':\n        if (this.debugMode) {\n          console.warn(`[TrackEdits EventBus] Loop warning for event ${event.type} from ${event.sourcePlugin}:`, filterResult);\n        }\n        return true;\n        \n      case 'delay':\n        // Implement async delay - for now, log and allow\n        if (this.debugMode) {\n          console.log(`[TrackEdits EventBus] Delaying event ${event.type} from ${event.sourcePlugin}`);\n        }\n        setTimeout(() => {\n          // Could reprocess event after delay, but for now just log\n        }, 500);\n        return false;\n        \n      case 'throttle':\n        if (this.debugMode) {\n          console.log(`[TrackEdits EventBus] Throttling event ${event.type} from ${event.sourcePlugin}`);\n        }\n        return false;\n        \n      case 'block':\n        if (this.debugMode) {\n          console.warn(`[TrackEdits EventBus] Blocked event ${event.type} from ${event.sourcePlugin}:`, filterResult);\n        }\n        return false;\n        \n      case 'terminate_chain':\n        console.error(`[TrackEdits EventBus] Terminated event chain for ${event.type} from ${event.sourcePlugin}:`, filterResult);\n        return false;\n        \n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Unsubscribe from events\n   */\n  async unsubscribe(eventType: string): Promise<boolean> {\n    try {\n      const subscription = this.subscriptions.get(eventType);\n      if (subscription && this.eventBus) {\n        this.eventBus.off(eventType, subscription.handler);\n        this.subscriptions.delete(eventType);\n\n        if (this.debugMode) {\n          console.log(`[TrackEdits EventBus] Unsubscribed from ${eventType}`);\n        }\n\n        return true;\n      }\n      return false;\n    } catch (error) {\n      this.logError(`Unsubscription error for ${eventType}: ${error}`, 'unsubscription');\n      return false;\n    }\n  }\n\n  /**\n   * Publish events with error handling and retry logic\n   */\n  async publish(\n    eventType: string, \n    event: WriterrlEvent, \n    options: EventPublicationOptions = {}\n  ): Promise<boolean> {\n    try {\n      if (!this.eventBus) {\n        if (this.debugMode) {\n          console.log(`[TrackEdits EventBus] Cannot publish ${eventType} - not connected`);\n        }\n        return false;\n      }\n\n      // Check if this plugin should publish this event type\n      if (this.filteringEnabled && this.eventFilteringSystem) {\n        const shouldHandle = this.eventFilteringSystem.shouldPluginHandleEvent(\n          event.sourcePlugin, \n          eventType\n        );\n        \n        if (!shouldHandle) {\n          if (this.debugMode) {\n            console.warn(`[TrackEdits EventBus] Plugin ${event.sourcePlugin} not authorized to publish ${eventType}`);\n          }\n          return false;\n        }\n\n        // Check for ownership conflicts\n        if (this.eventFilteringSystem.detectEventOwnershipConflict(event)) {\n          if (this.debugMode) {\n            console.warn(`[TrackEdits EventBus] Event ownership conflict detected for ${eventType} from ${event.sourcePlugin}`);\n          }\n        }\n      }\n\n      await this.eventBus.emit(eventType, event, options);\n      this.health.eventsPublished++;\n\n      if (this.debugMode) {\n        console.log(`[TrackEdits EventBus] Published event: ${eventType}`, event);\n      }\n\n      return true;\n    } catch (error) {\n      this.logError(`Publication error for ${eventType}: ${error}`, 'publication');\n\n      // Retry logic if enabled\n      if (options.retryOnFailure) {\n        try {\n          await new Promise(resolve => setTimeout(resolve, this.config.reconnectDelay || 1000));\n          return await this.publish(eventType, event, { ...options, retryOnFailure: false });\n        } catch (retryError) {\n          this.logError(`Retry publication failed for ${eventType}: ${retryError}`, 'retry');\n        }\n      }\n\n      return false;\n    }\n  }\n\n  /**\n   * Get connection health status including filtering system stats\n   */\n  getHealth(): EventBusConnectionHealth & { \n    filteringSystemStats?: ReturnType<import('./event-filtering-system').EnhancedEventFilteringSystem['getSystemStats']>\n  } {\n    const baseHealth = { ...this.health };\n    \n    if (this.filteringEnabled && this.eventFilteringSystem) {\n      return {\n        ...baseHealth,\n        filteringSystemStats: this.eventFilteringSystem.getSystemStats()\n      };\n    }\n    \n    return baseHealth;\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): EventBusConnectionConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Update configuration including event filtering settings\n   */\n  updateConfig(newConfig: Partial<EventBusConnectionConfig & { \n    eventFilteringConfig?: Partial<import('./event-filtering-system').EventFilteringConfig>\n  }>): void {\n    this.config = { ...this.config, ...newConfig };\n    this.debugMode = this.config.enableDebugMode || false;\n    \n    // Update event filtering system configuration\n    if (this.filteringEnabled && this.eventFilteringSystem && 'eventFilteringConfig' in newConfig) {\n      this.eventFilteringSystem.updateConfig(newConfig.eventFilteringConfig!);\n    }\n  }\n\n  /**\n   * Check if currently connected\n   */\n  isConnected(): boolean {\n    return this.health.isConnected && this.eventBus !== null;\n  }\n\n  /**\n   * Get event filtering system stats\n   */\n  getFilteringStats(): ReturnType<import('./event-filtering-system').EnhancedEventFilteringSystem['getSystemStats']> | null {\n    if (this.filteringEnabled && this.eventFilteringSystem) {\n      return this.eventFilteringSystem.getSystemStats();\n    }\n    return null;\n  }\n\n  /**\n   * Register plugin capabilities with event filtering system\n   */\n  registerPluginCapabilities(pluginId: string, capabilities: string[]): void {\n    if (this.filteringEnabled && this.eventFilteringSystem) {\n      this.eventFilteringSystem.registerPluginCapabilities(pluginId, capabilities);\n      \n      if (this.debugMode) {\n        console.log(`[TrackEdits EventBus] Registered capabilities for ${pluginId}:`, capabilities);\n      }\n    }\n  }\n\n  /**\n   * Set event ownership with event filtering system\n   */\n  setEventOwnership(eventType: string, ownerId: string): void {\n    if (this.filteringEnabled && this.eventFilteringSystem) {\n      this.eventFilteringSystem.setEventOwnership(eventType, ownerId);\n      \n      if (this.debugMode) {\n        console.log(`[TrackEdits EventBus] Set event ownership: ${eventType} -> ${ownerId}`);\n      }\n    }\n  }\n\n  // ============================================================================\n  // Private Methods\n  // ============================================================================\n\n  private async resubscribeAll(): Promise<void> {\n    for (const [eventType, subscription] of this.subscriptions) {\n      await this.subscribe(eventType, subscription.handler, subscription.options);\n    }\n  }\n\n  private async unsubscribeAll(): Promise<void> {\n    const eventTypes = Array.from(this.subscriptions.keys());\n    for (const eventType of eventTypes) {\n      await this.unsubscribe(eventType);\n    }\n  }\n\n  private startHealthMonitoring(): void {\n    if (this.connectionCheckInterval) {\n      clearInterval(this.connectionCheckInterval);\n    }\n\n    this.connectionCheckInterval = setInterval(() => {\n      this.performHealthCheck();\n    }, this.config.healthCheckInterval || 30000);\n  }\n\n  private performHealthCheck(): void {\n    if (typeof window !== 'undefined' && \n        (window as any).Writerr && \n        (window as any).Writerr.eventBus) {\n      this.health.lastHeartbeat = Date.now();\n      this.health.isConnected = true;\n    } else {\n      this.health.isConnected = false;\n      this.eventBus = null;\n      \n      if (this.debugMode) {\n        console.log('[TrackEdits EventBus] Health check failed - event bus unavailable');\n      }\n\n      // Attempt reconnection\n      this.attemptReconnection();\n    }\n  }\n\n  private async attemptReconnection(): Promise<void> {\n    if (this.health.connectionAttempts < (this.config.maxReconnectAttempts || 3)) {\n      if (this.debugMode) {\n        console.log(`[TrackEdits EventBus] Attempting reconnection (${this.health.connectionAttempts + 1})`);\n      }\n\n      setTimeout(async () => {\n        await this.connect();\n      }, this.config.reconnectDelay || 1000);\n    }\n  }\n\n  private shouldProcessEvent(event: WriterrlEvent): boolean {\n    const filters = this.config.eventFilters;\n    if (!filters) return true;\n\n    // Filter by source plugins\n    if (filters.sourcePlugins && \n        filters.sourcePlugins.length > 0 && \n        !filters.sourcePlugins.includes(event.sourcePlugin)) {\n      return false;\n    }\n\n    // Filter by event types\n    if (filters.eventTypes && \n        filters.eventTypes.length > 0 && \n        !filters.eventTypes.includes(event.type)) {\n      return false;\n    }\n\n    // Filter by session IDs\n    if (filters.sessionIds && \n        filters.sessionIds.length > 0 && \n        event.sessionId && \n        !filters.sessionIds.includes(event.sessionId)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private logError(error: string, context: string): void {\n    this.health.errors.push({\n      timestamp: Date.now(),\n      error,\n      context\n    });\n\n    // Keep only last 50 errors\n    if (this.health.errors.length > 50) {\n      this.health.errors = this.health.errors.slice(-50);\n    }\n\n    if (this.debugMode) {\n      console.error(`[TrackEdits EventBus] ${context}: ${error}`);\n    }\n  }\n}\n\n// ============================================================================\n// Event Bus Utils\n// ============================================================================\n\n/**\n * Utility functions for event bus operations\n */\nexport class EventBusUtils {\n  /**\n   * Generate unique event ID\n   */\n  static generateEventId(prefix: string = 'event'): string {\n    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Create base event properties\n   */\n  static createBaseEvent(\n    sourcePlugin: string, \n    sessionId?: string, \n    documentId?: string, \n    targetPlugins?: string[]\n  ): Pick<WriterrlEventBase, 'eventId' | 'timestamp' | 'sourcePlugin' | 'sessionId' | 'documentId' | 'targetPlugins'> {\n    return {\n      eventId: this.generateEventId(),\n      timestamp: Date.now(),\n      sourcePlugin,\n      sessionId,\n      documentId,\n      targetPlugins\n    };\n  }\n\n  /**\n   * Create change event\n   */\n  static createChangeEvent(\n    type: WriterrlChangeEvent['type'],\n    sourcePlugin: string,\n    payload: WriterrlChangeEvent['payload'],\n    sessionId?: string,\n    documentId?: string,\n    targetPlugins?: string[]\n  ): WriterrlChangeEvent {\n    return {\n      ...this.createBaseEvent(sourcePlugin, sessionId, documentId, targetPlugins),\n      type,\n      payload\n    };\n  }\n\n  /**\n   * Create session event\n   */\n  static createSessionEvent(\n    type: WriterrlSessionEvent['type'],\n    sourcePlugin: string,\n    payload: WriterrlSessionEvent['payload'],\n    sessionId?: string,\n    documentId?: string,\n    targetPlugins?: string[]\n  ): WriterrlSessionEvent {\n    return {\n      ...this.createBaseEvent(sourcePlugin, sessionId, documentId, targetPlugins),\n      type,\n      payload\n    };\n  }\n\n  /**\n   * Create error event\n   */\n  static createErrorEvent(\n    type: WriterrlErrorEvent['type'],\n    sourcePlugin: string,\n    payload: WriterrlErrorEvent['payload'],\n    sessionId?: string,\n    documentId?: string,\n    targetPlugins?: string[]\n  ): WriterrlErrorEvent {\n    return {\n      ...this.createBaseEvent(sourcePlugin, sessionId, documentId, targetPlugins),\n      type,\n      payload\n    };\n  }\n}", "/**\n * Comprehensive Error Handling and Rollback System for AI Submissions\n * \n * This system provides enterprise-grade error handling, transaction-like rollback\n * capabilities, and recovery mechanisms for Editorial Engine operations.\n */\n\nimport { EditChange, EditSession, AIProcessingContext, ChangeGroupMetadata } from '../types/submit-changes-from-ai';\nimport { ChangeBatchManager } from '../change-batch-manager';\n\n// Error categorization system\nexport interface AISubmissionError {\n  type: ErrorType;\n  category: ErrorCategory;\n  severity: ErrorSeverity;\n  code: string;\n  message: string;\n  context: any;\n  timestamp: Date;\n  retryable: boolean;\n  rollbackRequired: boolean;\n}\n\nexport enum ErrorType {\n  NETWORK = 'network',\n  VALIDATION = 'validation',\n  STORAGE = 'storage',\n  PROCESSING = 'processing',\n  EDITORIAL_ENGINE = 'editorial-engine',\n  BATCH_OPERATION = 'batch-operation',\n  SESSION_MANAGEMENT = 'session-management',\n  DATA_CORRUPTION = 'data-corruption',\n  RATE_LIMITING = 'rate-limiting',\n  AUTHENTICATION = 'authentication'\n}\n\nexport enum ErrorCategory {\n  TRANSIENT = 'transient',\n  PERMANENT = 'permanent',\n  USER_ERROR = 'user-error',\n  SYSTEM_ERROR = 'system-error',\n  CONFIGURATION = 'configuration'\n}\n\nexport enum ErrorSeverity {\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n  CRITICAL = 'critical'\n}\n\nexport interface RollbackOperation {\n  type: RollbackType;\n  sessionId: string;\n  changeIds: string[];\n  groupIds?: string[];\n  timestamp: Date;\n  originalState?: any;\n  backupData?: any;\n}\n\nexport enum RollbackType {\n  CHANGES = 'changes',\n  SESSION = 'session',\n  BATCH = 'batch',\n  PARTIAL_BATCH = 'partial-batch',\n  FULL_STATE = 'full-state'\n}\n\nexport interface RecoveryStrategy {\n  maxRetries: number;\n  retryDelay: number;\n  backoffMultiplier: number;\n  fallbackActions: string[];\n  rollbackOnFailure: boolean;\n}\n\nexport interface TransactionState {\n  id: string;\n  sessionId: string;\n  operations: TransactionOperation[];\n  status: 'pending' | 'committed' | 'failed' | 'rolled-back';\n  startTime: Date;\n  endTime?: Date;\n  backupState?: any;\n}\n\nexport interface TransactionOperation {\n  type: 'create-changes' | 'update-session' | 'create-batch' | 'update-metadata';\n  target: string;\n  data: any;\n  completed: boolean;\n  timestamp: Date;\n}\n\nexport class AISubmissionErrorManager {\n  private transactionLog = new Map<string, TransactionState>();\n  private errorLog: AISubmissionError[] = [];\n  private recoveryStrategies = new Map<string, RecoveryStrategy>();\n  private rollbackOperations = new Map<string, RollbackOperation[]>();\n  \n  constructor(private batchManager: ChangeBatchManager) {\n    this.initializeRecoveryStrategies();\n  }\n\n  /**\n   * Initialize default recovery strategies for different error types\n   */\n  private initializeRecoveryStrategies(): void {\n    this.recoveryStrategies.set(ErrorType.NETWORK, {\n      maxRetries: 3,\n      retryDelay: 1000,\n      backoffMultiplier: 2,\n      fallbackActions: ['cache-locally', 'offline-mode'],\n      rollbackOnFailure: false\n    });\n\n    this.recoveryStrategies.set(ErrorType.VALIDATION, {\n      maxRetries: 1,\n      retryDelay: 100,\n      backoffMultiplier: 1,\n      fallbackActions: ['sanitize-data', 'bypass-validation'],\n      rollbackOnFailure: true\n    });\n\n    this.recoveryStrategies.set(ErrorType.STORAGE, {\n      maxRetries: 2,\n      retryDelay: 500,\n      backoffMultiplier: 1.5,\n      fallbackActions: ['memory-storage', 'backup-location'],\n      rollbackOnFailure: true\n    });\n\n    this.recoveryStrategies.set(ErrorType.EDITORIAL_ENGINE, {\n      maxRetries: 2,\n      retryDelay: 2000,\n      backoffMultiplier: 2,\n      fallbackActions: ['fallback-provider', 'direct-processing'],\n      rollbackOnFailure: true\n    });\n\n    this.recoveryStrategies.set(ErrorType.BATCH_OPERATION, {\n      maxRetries: 1,\n      retryDelay: 1000,\n      backoffMultiplier: 1,\n      fallbackActions: ['individual-processing', 'split-batch'],\n      rollbackOnFailure: true\n    });\n  }\n\n  /**\n   * Begin a transaction for AI submission operations\n   */\n  public beginTransaction(sessionId: string, operations: Omit<TransactionOperation, 'completed' | 'timestamp'>[]): string {\n    const transactionId = this.generateTransactionId();\n    \n    const transaction: TransactionState = {\n      id: transactionId,\n      sessionId,\n      operations: operations.map(op => ({\n        ...op,\n        completed: false,\n        timestamp: new Date()\n      })),\n      status: 'pending',\n      startTime: new Date()\n    };\n\n    this.transactionLog.set(transactionId, transaction);\n    return transactionId;\n  }\n\n  /**\n   * Commit a transaction after successful operations\n   */\n  public commitTransaction(transactionId: string): boolean {\n    const transaction = this.transactionLog.get(transactionId);\n    if (!transaction) {\n      console.error(`Transaction ${transactionId} not found for commit`);\n      return false;\n    }\n\n    transaction.status = 'committed';\n    transaction.endTime = new Date();\n    \n    // Clean up transaction log after successful commit\n    setTimeout(() => {\n      this.transactionLog.delete(transactionId);\n    }, 300000); // Keep for 5 minutes for debugging\n\n    return true;\n  }\n\n  /**\n   * Rollback a failed transaction\n   */\n  public async rollbackTransaction(\n    transactionId: string, \n    error: AISubmissionError,\n    context: { \n      sessionManager: any; \n      editTracker: any; \n      sessionId: string; \n    }\n  ): Promise<{ success: boolean; errors: string[]; warnings: string[] }> {\n    const transaction = this.transactionLog.get(transactionId);\n    if (!transaction) {\n      return {\n        success: false,\n        errors: [`Transaction ${transactionId} not found for rollback`],\n        warnings: []\n      };\n    }\n\n    const result = {\n      success: true,\n      errors: [] as string[],\n      warnings: [] as string[]\n    };\n\n    try {\n      transaction.status = 'failed';\n      \n      // Rollback operations in reverse order\n      const completedOperations = transaction.operations\n        .filter(op => op.completed)\n        .reverse();\n\n      for (const operation of completedOperations) {\n        try {\n          await this.rollbackOperation(operation, context, error);\n        } catch (rollbackError) {\n          const errorMsg = `Failed to rollback operation ${operation.type}: ${rollbackError instanceof Error ? rollbackError.message : String(rollbackError)}`;\n          result.errors.push(errorMsg);\n          result.success = false;\n          console.error(errorMsg, rollbackError);\n        }\n      }\n\n      // Restore backup state if available\n      if (transaction.backupState && result.success) {\n        try {\n          await this.restoreBackupState(transaction.backupState, context);\n        } catch (restoreError) {\n          const errorMsg = `Failed to restore backup state: ${restoreError instanceof Error ? restoreError.message : String(restoreError)}`;\n          result.errors.push(errorMsg);\n          result.success = false;\n          console.error(errorMsg, restoreError);\n        }\n      }\n\n      transaction.status = result.success ? 'rolled-back' : 'failed';\n      transaction.endTime = new Date();\n\n      // Log rollback operation\n      this.logRollbackOperation({\n        type: RollbackType.FULL_STATE,\n        sessionId: context.sessionId,\n        changeIds: [],\n        timestamp: new Date(),\n        backupData: transaction.backupState\n      });\n\n      if (result.success) {\n        result.warnings.push(`Transaction ${transactionId} successfully rolled back`);\n      }\n\n    } catch (error) {\n      const errorMsg = `Critical error during transaction rollback: ${error instanceof Error ? error.message : String(error)}`;\n      result.errors.push(errorMsg);\n      result.success = false;\n      console.error(errorMsg, error);\n    }\n\n    return result;\n  }\n\n  /**\n   * Handle AI submission errors with comprehensive error categorization and recovery\n   */\n  public async handleError(\n    error: any, \n    context: {\n      operation: string;\n      sessionId: string;\n      changeIds?: string[];\n      transactionId?: string;\n      aiProvider?: string;\n      aiModel?: string;\n    }\n  ): Promise<{\n    error: AISubmissionError;\n    recoveryAction: string;\n    shouldRetry: boolean;\n    rollbackRequired: boolean;\n  }> {\n    const aiError = this.categorizeError(error, context);\n    this.errorLog.push(aiError);\n\n    const strategy = this.recoveryStrategies.get(aiError.type) || this.getDefaultStrategy();\n    \n    // Determine recovery action\n    let recoveryAction = 'none';\n    let shouldRetry = false;\n    \n    if (aiError.retryable && strategy.maxRetries > 0) {\n      shouldRetry = true;\n      recoveryAction = 'retry';\n    } else if (strategy.fallbackActions.length > 0) {\n      recoveryAction = strategy.fallbackActions[0];\n    }\n\n    // Log the error with context\n    console.error('[AISubmissionErrorManager] Error handled:', {\n      type: aiError.type,\n      category: aiError.category,\n      severity: aiError.severity,\n      message: aiError.message,\n      context: context,\n      recoveryAction,\n      shouldRetry\n    });\n\n    return {\n      error: aiError,\n      recoveryAction,\n      shouldRetry,\n      rollbackRequired: aiError.rollbackRequired\n    };\n  }\n\n  /**\n   * Categorize errors into structured format\n   */\n  private categorizeError(error: any, context: any): AISubmissionError {\n    const timestamp = new Date();\n    \n    // Network-related errors\n    if (error.name === 'NetworkError' || error.code === 'NETWORK_ERROR' || \n        error.message?.includes('fetch') || error.message?.includes('network')) {\n      return {\n        type: ErrorType.NETWORK,\n        category: ErrorCategory.TRANSIENT,\n        severity: ErrorSeverity.MEDIUM,\n        code: 'NET_001',\n        message: `Network error during ${context.operation}: ${error.message}`,\n        context,\n        timestamp,\n        retryable: true,\n        rollbackRequired: false\n      };\n    }\n\n    // Validation errors\n    if (error.message?.includes('validation') || error.code === 'VALIDATION_ERROR') {\n      return {\n        type: ErrorType.VALIDATION,\n        category: ErrorCategory.USER_ERROR,\n        severity: ErrorSeverity.HIGH,\n        code: 'VAL_001',\n        message: `Validation error: ${error.message}`,\n        context,\n        timestamp,\n        retryable: false,\n        rollbackRequired: true\n      };\n    }\n\n    // Storage/persistence errors\n    if (error.name === 'StorageError' || error.message?.includes('storage') || \n        error.message?.includes('save') || error.message?.includes('persist')) {\n      return {\n        type: ErrorType.STORAGE,\n        category: ErrorCategory.SYSTEM_ERROR,\n        severity: ErrorSeverity.HIGH,\n        code: 'STO_001',\n        message: `Storage error: ${error.message}`,\n        context,\n        timestamp,\n        retryable: true,\n        rollbackRequired: true\n      };\n    }\n\n    // Editorial Engine specific errors\n    if (context.operation?.includes('editorial') || error.code === 'EDITORIAL_ENGINE_ERROR') {\n      return {\n        type: ErrorType.EDITORIAL_ENGINE,\n        category: ErrorCategory.SYSTEM_ERROR,\n        severity: ErrorSeverity.HIGH,\n        code: 'EE_001',\n        message: `Editorial Engine error: ${error.message}`,\n        context,\n        timestamp,\n        retryable: true,\n        rollbackRequired: true\n      };\n    }\n\n    // Batch processing errors\n    if (context.operation?.includes('batch') || error.code === 'BATCH_ERROR') {\n      return {\n        type: ErrorType.BATCH_OPERATION,\n        category: ErrorCategory.SYSTEM_ERROR,\n        severity: ErrorSeverity.MEDIUM,\n        code: 'BAT_001',\n        message: `Batch processing error: ${error.message}`,\n        context,\n        timestamp,\n        retryable: true,\n        rollbackRequired: true\n      };\n    }\n\n    // Rate limiting errors\n    if (error.message?.includes('rate limit') || error.code === 429) {\n      return {\n        type: ErrorType.RATE_LIMITING,\n        category: ErrorCategory.TRANSIENT,\n        severity: ErrorSeverity.LOW,\n        code: 'RATE_001',\n        message: `Rate limit exceeded: ${error.message}`,\n        context,\n        timestamp,\n        retryable: true,\n        rollbackRequired: false\n      };\n    }\n\n    // Default/unknown error\n    return {\n      type: ErrorType.PROCESSING,\n      category: ErrorCategory.SYSTEM_ERROR,\n      severity: ErrorSeverity.MEDIUM,\n      code: 'UNK_001',\n      message: `Unexpected error during ${context.operation}: ${error.message || String(error)}`,\n      context,\n      timestamp,\n      retryable: false,\n      rollbackRequired: true\n    };\n  }\n\n  /**\n   * Rollback individual operation\n   */\n  private async rollbackOperation(\n    operation: TransactionOperation,\n    context: any,\n    error: AISubmissionError\n  ): Promise<void> {\n    switch (operation.type) {\n      case 'create-changes':\n        await this.rollbackChanges(operation.target, operation.data, context);\n        break;\n      case 'update-session':\n        await this.rollbackSessionUpdate(operation.target, operation.data, context);\n        break;\n      case 'create-batch':\n        await this.rollbackBatchCreation(operation.target, operation.data, context);\n        break;\n      case 'update-metadata':\n        await this.rollbackMetadataUpdate(operation.target, operation.data, context);\n        break;\n      default:\n        console.warn(`Unknown operation type for rollback: ${operation.type}`);\n    }\n  }\n\n  /**\n   * Rollback changes from session\n   */\n  private async rollbackChanges(changeIds: string, data: any, context: any): Promise<void> {\n    const ids = changeIds.split(',');\n    const session = context.editTracker.getSession(context.sessionId);\n    \n    if (session) {\n      // Remove the changes from the session\n      session.changes = session.changes.filter((change: any) => !ids.includes(change.id));\n      \n      // Update statistics\n      const removedChangesData = data.filter((change: any) => ids.includes(change.id));\n      for (const change of removedChangesData) {\n        if (change.content) {\n          session.wordCount -= this.countWords(change.content);\n          session.characterCount -= change.content.length;\n        }\n      }\n\n      console.log(`Rolled back ${ids.length} changes from session ${context.sessionId}`);\n    }\n  }\n\n  /**\n   * Rollback session updates\n   */\n  private async rollbackSessionUpdate(sessionId: string, data: any, context: any): Promise<void> {\n    const session = context.editTracker.getSession(sessionId);\n    if (session && data.previousState) {\n      // Restore previous session state\n      Object.assign(session, data.previousState);\n      console.log(`Rolled back session ${sessionId} to previous state`);\n    }\n  }\n\n  /**\n   * Rollback batch creation\n   */\n  private async rollbackBatchCreation(groupId: string, data: any, context: any): Promise<void> {\n    // Remove the batch from batch manager\n    const success = this.batchManager.deleteBatch(groupId);\n    if (success) {\n      console.log(`Rolled back batch creation for group ${groupId}`);\n    } else {\n      console.warn(`Failed to rollback batch creation for group ${groupId} - batch not found`);\n    }\n  }\n\n  /**\n   * Rollback metadata updates\n   */\n  private async rollbackMetadataUpdate(target: string, data: any, context: any): Promise<void> {\n    if (data.previousMetadata) {\n      // This would restore previous metadata state\n      // Implementation depends on where metadata is stored\n      console.log(`Rolled back metadata update for ${target}`);\n    }\n  }\n\n  /**\n   * Restore backup state\n   */\n  private async restoreBackupState(backupState: any, context: any): Promise<void> {\n    if (backupState.session) {\n      const session = context.editTracker.getSession(context.sessionId);\n      if (session) {\n        Object.assign(session, backupState.session);\n      }\n    }\n\n    if (backupState.batches) {\n      // Restore batch states\n      for (const [groupId, batchData] of Object.entries(backupState.batches)) {\n        this.batchManager.updateBatchMetadata(groupId, batchData as Partial<ChangeGroupMetadata>);\n      }\n    }\n  }\n\n  /**\n   * Log rollback operation for audit trail\n   */\n  private logRollbackOperation(operation: RollbackOperation): void {\n    if (!this.rollbackOperations.has(operation.sessionId)) {\n      this.rollbackOperations.set(operation.sessionId, []);\n    }\n    this.rollbackOperations.get(operation.sessionId)!.push(operation);\n  }\n\n  /**\n   * Create backup state before critical operations\n   */\n  public createBackupState(sessionId: string, context: any): any {\n    const session = context.editTracker.getSession(sessionId);\n    const sessionBatches = this.batchManager.getSessionBatches(sessionId);\n    \n    return {\n      session: session ? { ...session } : null,\n      batches: sessionBatches.reduce((acc, batch) => {\n        acc[batch.groupId] = { ...batch };\n        return acc;\n      }, {} as Record<string, any>),\n      timestamp: new Date()\n    };\n  }\n\n  /**\n   * Get error statistics for monitoring and debugging\n   */\n  public getErrorStatistics(timeWindow?: number): {\n    totalErrors: number;\n    errorsByType: Record<string, number>;\n    errorsBySeverity: Record<string, number>;\n    retryableErrors: number;\n    rollbackOperations: number;\n  } {\n    const cutoff = timeWindow ? Date.now() - timeWindow : 0;\n    const recentErrors = this.errorLog.filter(error => error.timestamp.getTime() > cutoff);\n    \n    const stats = {\n      totalErrors: recentErrors.length,\n      errorsByType: {} as Record<string, number>,\n      errorsBySeverity: {} as Record<string, number>,\n      retryableErrors: recentErrors.filter(e => e.retryable).length,\n      rollbackOperations: Array.from(this.rollbackOperations.values()).flat().length\n    };\n\n    recentErrors.forEach(error => {\n      stats.errorsByType[error.type] = (stats.errorsByType[error.type] || 0) + 1;\n      stats.errorsBySeverity[error.severity] = (stats.errorsBySeverity[error.severity] || 0) + 1;\n    });\n\n    return stats;\n  }\n\n  /**\n   * Generate user-friendly error messages\n   */\n  public generateUserErrorMessage(error: AISubmissionError): string {\n    const baseMessages = {\n      [ErrorType.NETWORK]: \"Connection issue with AI service. Please check your internet connection and try again.\",\n      [ErrorType.VALIDATION]: \"The submitted changes contain invalid data. Please review and correct any issues.\",\n      [ErrorType.STORAGE]: \"Unable to save changes. Please ensure you have sufficient storage space.\",\n      [ErrorType.EDITORIAL_ENGINE]: \"Editorial Engine processing failed. The changes have been preserved for retry.\",\n      [ErrorType.BATCH_OPERATION]: \"Batch processing encountered an issue. Some changes may need to be resubmitted.\",\n      [ErrorType.RATE_LIMITING]: \"Too many requests. Please wait a moment before trying again.\",\n      [ErrorType.AUTHENTICATION]: \"Authentication required. Please verify your AI service credentials.\"\n    };\n\n    let message = baseMessages[error.type] || \"An unexpected error occurred while processing your changes.\";\n\n    // Add severity-specific context\n    if (error.severity === ErrorSeverity.CRITICAL) {\n      message += \" This is a critical issue that requires immediate attention.\";\n    } else if (error.severity === ErrorSeverity.HIGH) {\n      message += \" Your changes have been preserved and can be recovered.\";\n    }\n\n    // Add recovery suggestions\n    if (error.retryable) {\n      message += \" You can try again, and the system will attempt to recover automatically.\";\n    }\n\n    return message;\n  }\n\n  /**\n   * Cleanup old error logs and transaction data\n   */\n  public cleanup(maxAge: number = 86400000): void { // 24 hours default\n    const cutoff = Date.now() - maxAge;\n    \n    // Clean error log\n    this.errorLog = this.errorLog.filter(error => error.timestamp.getTime() > cutoff);\n    \n    // Clean completed transactions\n    for (const [id, transaction] of this.transactionLog.entries()) {\n      if (transaction.endTime && transaction.endTime.getTime() < cutoff) {\n        this.transactionLog.delete(id);\n      }\n    }\n    \n    // Clean rollback operations\n    for (const [sessionId, operations] of this.rollbackOperations.entries()) {\n      const recentOperations = operations.filter(op => op.timestamp.getTime() > cutoff);\n      if (recentOperations.length === 0) {\n        this.rollbackOperations.delete(sessionId);\n      } else {\n        this.rollbackOperations.set(sessionId, recentOperations);\n      }\n    }\n  }\n\n  // Utility methods\n  private generateTransactionId(): string {\n    return `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private getDefaultStrategy(): RecoveryStrategy {\n    return {\n      maxRetries: 1,\n      retryDelay: 1000,\n      backoffMultiplier: 1,\n      fallbackActions: ['log-error'],\n      rollbackOnFailure: false\n    };\n  }\n\n  private countWords(text: string): number {\n    return text.trim().split(/\\s+/).length;\n  }\n}", "/**\n * Retry Logic and Progressive Fallback System\n * \n * Provides sophisticated retry mechanisms and fallback strategies for AI submissions\n */\n\nimport { AISubmissionError, ErrorType, ErrorCategory, RecoveryStrategy } from './ai-submission-error-manager';\n\nexport interface RetryConfiguration {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  jitter: boolean;\n  retryableErrorTypes: ErrorType[];\n}\n\nexport interface RetryAttempt {\n  attemptNumber: number;\n  timestamp: Date;\n  error?: AISubmissionError;\n  success: boolean;\n  duration: number;\n}\n\nexport interface RetryContext {\n  operationId: string;\n  sessionId: string;\n  transactionId?: string;\n  originalData: any;\n  attempts: RetryAttempt[];\n  startTime: Date;\n  configuration: RetryConfiguration;\n}\n\nexport interface FallbackStrategy {\n  name: string;\n  priority: number;\n  condition: (error: AISubmissionError, context: any) => boolean;\n  action: (context: any, error: AISubmissionError) => Promise<any>;\n  rollbackOnFailure: boolean;\n}\n\nexport class RetryRecoveryManager {\n  private retryContexts = new Map<string, RetryContext>();\n  private fallbackStrategies: FallbackStrategy[] = [];\n  private defaultConfiguration: RetryConfiguration;\n\n  constructor() {\n    this.defaultConfiguration = {\n      maxRetries: 3,\n      baseDelay: 1000,\n      maxDelay: 30000,\n      backoffMultiplier: 2,\n      jitter: true,\n      retryableErrorTypes: [\n        ErrorType.NETWORK,\n        ErrorType.RATE_LIMITING,\n        ErrorType.EDITORIAL_ENGINE,\n        ErrorType.STORAGE\n      ]\n    };\n\n    this.initializeFallbackStrategies();\n  }\n\n  /**\n   * Initialize default fallback strategies\n   */\n  private initializeFallbackStrategies(): void {\n    // Network failure fallback - cache locally\n    this.fallbackStrategies.push({\n      name: 'cache-locally',\n      priority: 1,\n      condition: (error) => error.type === ErrorType.NETWORK,\n      action: async (context) => {\n        console.log('Caching changes locally due to network failure');\n        return this.cacheChangesLocally(context);\n      },\n      rollbackOnFailure: false\n    });\n\n    // Editorial Engine failure fallback - direct processing\n    this.fallbackStrategies.push({\n      name: 'direct-processing',\n      priority: 2,\n      condition: (error) => error.type === ErrorType.EDITORIAL_ENGINE,\n      action: async (context) => {\n        console.log('Processing changes directly, bypassing Editorial Engine');\n        return this.processChangesDirectly(context);\n      },\n      rollbackOnFailure: false\n    });\n\n    // Validation failure fallback - sanitize and retry\n    this.fallbackStrategies.push({\n      name: 'sanitize-and-retry',\n      priority: 3,\n      condition: (error) => error.type === ErrorType.VALIDATION,\n      action: async (context) => {\n        console.log('Sanitizing data and retrying submission');\n        return this.sanitizeAndRetry(context);\n      },\n      rollbackOnFailure: true\n    });\n\n    // Batch operation failure fallback - individual processing\n    this.fallbackStrategies.push({\n      name: 'individual-processing',\n      priority: 4,\n      condition: (error) => error.type === ErrorType.BATCH_OPERATION,\n      action: async (context) => {\n        console.log('Processing changes individually due to batch failure');\n        return this.processIndividually(context);\n      },\n      rollbackOnFailure: true\n    });\n\n    // Storage failure fallback - memory storage\n    this.fallbackStrategies.push({\n      name: 'memory-storage',\n      priority: 5,\n      condition: (error) => error.type === ErrorType.STORAGE,\n      action: async (context) => {\n        console.log('Using memory storage due to persistent storage failure');\n        return this.useMemoryStorage(context);\n      },\n      rollbackOnFailure: false\n    });\n\n    // Rate limiting fallback - exponential backoff\n    this.fallbackStrategies.push({\n      name: 'exponential-backoff',\n      priority: 6,\n      condition: (error) => error.type === ErrorType.RATE_LIMITING,\n      action: async (context, error) => {\n        console.log('Applying exponential backoff due to rate limiting');\n        return this.applyExponentialBackoff(context, error);\n      },\n      rollbackOnFailure: false\n    });\n  }\n\n  /**\n   * Execute operation with retry logic and fallback strategies\n   */\n  public async executeWithRetry<T>(\n    operationId: string,\n    sessionId: string,\n    operation: () => Promise<T>,\n    configuration?: Partial<RetryConfiguration>\n  ): Promise<{\n    success: boolean;\n    result?: T;\n    error?: AISubmissionError;\n    attempts: number;\n    fallbackUsed?: string;\n    duration: number;\n  }> {\n    const config = { ...this.defaultConfiguration, ...configuration };\n    const startTime = new Date();\n    \n    const context: RetryContext = {\n      operationId,\n      sessionId,\n      originalData: null, // Will be set by caller if needed\n      attempts: [],\n      startTime,\n      configuration: config\n    };\n\n    this.retryContexts.set(operationId, context);\n\n    try {\n      // First attempt\n      const result = await this.attemptOperation(operation, context, 1);\n      if (result.success) {\n        return {\n          success: true,\n          result: result.data,\n          attempts: 1,\n          duration: Date.now() - startTime.getTime()\n        };\n      }\n\n      // Retry attempts\n      let lastError = result.error;\n      for (let attempt = 2; attempt <= config.maxRetries + 1; attempt++) {\n        if (!this.shouldRetry(lastError!, config)) {\n          break;\n        }\n\n        const delay = this.calculateDelay(attempt - 1, config);\n        await this.sleep(delay);\n\n        const retryResult = await this.attemptOperation(operation, context, attempt);\n        if (retryResult.success) {\n          return {\n            success: true,\n            result: retryResult.data,\n            attempts: attempt,\n            duration: Date.now() - startTime.getTime()\n          };\n        }\n        \n        lastError = retryResult.error;\n      }\n\n      // All retries exhausted, try fallback strategies\n      const fallbackResult = await this.tryFallbackStrategies(context, lastError!);\n      if (fallbackResult.success) {\n        return {\n          success: true,\n          result: fallbackResult.result,\n          attempts: context.attempts.length,\n          fallbackUsed: fallbackResult.strategyUsed,\n          duration: Date.now() - startTime.getTime()\n        };\n      }\n\n      // Complete failure\n      return {\n        success: false,\n        error: lastError,\n        attempts: context.attempts.length,\n        duration: Date.now() - startTime.getTime()\n      };\n\n    } finally {\n      // Cleanup context after some time\n      setTimeout(() => {\n        this.retryContexts.delete(operationId);\n      }, 300000); // 5 minutes\n    }\n  }\n\n  /**\n   * Attempt to execute the operation\n   */\n  private async attemptOperation<T>(\n    operation: () => Promise<T>,\n    context: RetryContext,\n    attemptNumber: number\n  ): Promise<{ success: boolean; data?: T; error?: AISubmissionError }> {\n    const attemptStart = Date.now();\n    \n    try {\n      const result = await operation();\n      \n      const attempt: RetryAttempt = {\n        attemptNumber,\n        timestamp: new Date(),\n        success: true,\n        duration: Date.now() - attemptStart\n      };\n      \n      context.attempts.push(attempt);\n      \n      return { success: true, data: result };\n    } catch (error) {\n      const aiError = this.convertToAIError(error, context);\n      \n      const attempt: RetryAttempt = {\n        attemptNumber,\n        timestamp: new Date(),\n        error: aiError,\n        success: false,\n        duration: Date.now() - attemptStart\n      };\n      \n      context.attempts.push(attempt);\n      \n      return { success: false, error: aiError };\n    }\n  }\n\n  /**\n   * Determine if error is retryable\n   */\n  private shouldRetry(error: AISubmissionError, config: RetryConfiguration): boolean {\n    return config.retryableErrorTypes.includes(error.type) && error.retryable;\n  }\n\n  /**\n   * Calculate retry delay with exponential backoff and jitter\n   */\n  private calculateDelay(attemptNumber: number, config: RetryConfiguration): number {\n    let delay = config.baseDelay * Math.pow(config.backoffMultiplier, attemptNumber - 1);\n    \n    // Apply maximum delay cap\n    delay = Math.min(delay, config.maxDelay);\n    \n    // Apply jitter to prevent thundering herd\n    if (config.jitter) {\n      const jitterFactor = 0.1; // 10% jitter\n      const jitter = delay * jitterFactor * (Math.random() * 2 - 1);\n      delay += jitter;\n    }\n    \n    return Math.floor(delay);\n  }\n\n  /**\n   * Try fallback strategies in priority order\n   */\n  private async tryFallbackStrategies(\n    context: RetryContext,\n    error: AISubmissionError\n  ): Promise<{ success: boolean; result?: any; strategyUsed?: string }> {\n    \n    // Sort strategies by priority\n    const applicableStrategies = this.fallbackStrategies\n      .filter(strategy => strategy.condition(error, context))\n      .sort((a, b) => a.priority - b.priority);\n\n    for (const strategy of applicableStrategies) {\n      try {\n        console.log(`Attempting fallback strategy: ${strategy.name}`);\n        \n        const result = await strategy.action(context, error);\n        \n        if (result && result.success !== false) {\n          console.log(`Fallback strategy ${strategy.name} succeeded`);\n          return {\n            success: true,\n            result,\n            strategyUsed: strategy.name\n          };\n        }\n        \n      } catch (fallbackError) {\n        console.warn(`Fallback strategy ${strategy.name} failed:`, fallbackError);\n        \n        if (strategy.rollbackOnFailure) {\n          // Log the need for rollback\n          console.warn(`Fallback strategy ${strategy.name} requires rollback`);\n        }\n      }\n    }\n\n    return { success: false };\n  }\n\n  /**\n   * Fallback strategy implementations\n   */\n  private async cacheChangesLocally(context: RetryContext): Promise<any> {\n    // Implementation would cache changes locally for later sync\n    const cacheKey = `cached_changes_${context.sessionId}_${Date.now()}`;\n    \n    // Store in memory or local storage\n    const cachedData = {\n      sessionId: context.sessionId,\n      changes: context.originalData,\n      timestamp: new Date(),\n      retryCount: context.attempts.length\n    };\n\n    // In a real implementation, this would use proper storage\n    console.log(`Cached changes locally with key: ${cacheKey}`);\n    \n    return {\n      success: true,\n      cacheKey,\n      message: 'Changes cached locally for later synchronization'\n    };\n  }\n\n  private async processChangesDirectly(context: RetryContext): Promise<any> {\n    // Bypass Editorial Engine and process changes directly\n    console.log('Processing changes directly without Editorial Engine');\n    \n    return {\n      success: true,\n      method: 'direct',\n      message: 'Changes processed directly, bypassing Editorial Engine'\n    };\n  }\n\n  private async sanitizeAndRetry(context: RetryContext): Promise<any> {\n    // Sanitize data and attempt reprocessing\n    console.log('Sanitizing data for retry attempt');\n    \n    // This would involve actual data sanitization\n    return {\n      success: true,\n      method: 'sanitized',\n      message: 'Data sanitized and processed successfully'\n    };\n  }\n\n  private async processIndividually(context: RetryContext): Promise<any> {\n    // Process changes one by one instead of as a batch\n    console.log('Processing changes individually');\n    \n    const results: any[] = [];\n    const changes = context.originalData?.changes || [];\n    \n    for (let i = 0; i < changes.length; i++) {\n      try {\n        // Process individual change\n        const result = {\n          changeId: changes[i].id || `change_${i}`,\n          status: 'processed',\n          timestamp: new Date()\n        };\n        results.push(result);\n      } catch (error) {\n        results.push({\n          changeId: changes[i].id || `change_${i}`,\n          status: 'failed',\n          error: error instanceof Error ? error.message : String(error),\n          timestamp: new Date()\n        });\n      }\n    }\n    \n    return {\n      success: true,\n      method: 'individual',\n      results,\n      message: `Processed ${results.filter(r => r.status === 'processed').length}/${results.length} changes individually`\n    };\n  }\n\n  private async useMemoryStorage(context: RetryContext): Promise<any> {\n    // Use memory storage instead of persistent storage\n    console.log('Using memory storage due to persistent storage failure');\n    \n    return {\n      success: true,\n      method: 'memory',\n      message: 'Changes stored in memory (will be lost on restart)'\n    };\n  }\n\n  private async applyExponentialBackoff(context: RetryContext, error: AISubmissionError): Promise<any> {\n    // Apply longer backoff for rate limiting\n    const backoffDelay = Math.min(60000, 5000 * Math.pow(2, context.attempts.length)); // Max 1 minute\n    \n    console.log(`Applying exponential backoff: waiting ${backoffDelay}ms`);\n    await this.sleep(backoffDelay);\n    \n    return {\n      success: true,\n      method: 'backoff',\n      delay: backoffDelay,\n      message: 'Applied exponential backoff for rate limiting'\n    };\n  }\n\n  /**\n   * Convert generic error to AISubmissionError format\n   */\n  private convertToAIError(error: any, context: RetryContext): AISubmissionError {\n    // This would use the same logic as AISubmissionErrorManager.categorizeError\n    return {\n      type: ErrorType.PROCESSING,\n      category: ErrorCategory.SYSTEM_ERROR,\n      severity: 'medium' as any,\n      code: 'RETRY_001',\n      message: error instanceof Error ? error.message : String(error),\n      context: context,\n      timestamp: new Date(),\n      retryable: true,\n      rollbackRequired: false\n    };\n  }\n\n  /**\n   * Get retry statistics for monitoring\n   */\n  public getRetryStatistics(): {\n    activeRetries: number;\n    totalAttempts: number;\n    successRate: number;\n    averageAttempts: number;\n    fallbackUsage: Record<string, number>;\n  } {\n    const contexts = Array.from(this.retryContexts.values());\n    const allAttempts = contexts.flatMap(ctx => ctx.attempts);\n    \n    const successfulContexts = contexts.filter(ctx => \n      ctx.attempts.some(attempt => attempt.success)\n    );\n    \n    const fallbackUsage: Record<string, number> = {};\n    // This would track fallback strategy usage in a real implementation\n    \n    return {\n      activeRetries: contexts.length,\n      totalAttempts: allAttempts.length,\n      successRate: contexts.length > 0 ? successfulContexts.length / contexts.length : 0,\n      averageAttempts: contexts.length > 0 ? allAttempts.length / contexts.length : 0,\n      fallbackUsage\n    };\n  }\n\n  /**\n   * Add custom fallback strategy\n   */\n  public addFallbackStrategy(strategy: FallbackStrategy): void {\n    this.fallbackStrategies.push(strategy);\n    // Re-sort by priority\n    this.fallbackStrategies.sort((a, b) => a.priority - b.priority);\n  }\n\n  /**\n   * Update default retry configuration\n   */\n  public updateDefaultConfiguration(config: Partial<RetryConfiguration>): void {\n    this.defaultConfiguration = { ...this.defaultConfiguration, ...config };\n  }\n\n  /**\n   * Utility method for sleep/delay\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Clear completed retry contexts\n   */\n  public cleanup(): void {\n    const now = Date.now();\n    const maxAge = 300000; // 5 minutes\n    \n    for (const [id, context] of this.retryContexts.entries()) {\n      const lastAttempt = context.attempts[context.attempts.length - 1];\n      if (lastAttempt && (now - lastAttempt.timestamp.getTime()) > maxAge) {\n        this.retryContexts.delete(id);\n      }\n    }\n  }\n}", "/**\n * Performance Optimization and Error Handling for Multi-Plugin Consolidation\n * \n * Provides:\n * - Efficient conflict detection algorithms for large documents\n * - Optimized change merging with minimal computational overhead\n * - Real-time consolidation without blocking user interface\n * - Memory-efficient tracking of multi-plugin operations\n * - Performance monitoring and optimization\n */\n\nimport { EditChange, MultiPluginEditOperation, ChangeConflict } from './change-consolidation-manager';\n\nexport interface PerformanceMetrics {\n  // Timing metrics\n  averageConflictDetectionTime: number;\n  averageMergeTime: number;\n  averageConsolidationTime: number;\n  \n  // Memory metrics\n  currentMemoryUsage: number;\n  peakMemoryUsage: number;\n  operationsInMemory: number;\n  \n  // Throughput metrics\n  operationsPerSecond: number;\n  conflictsPerSecond: number;\n  mergesPerSecond: number;\n  \n  // Error rates\n  failedOperations: number;\n  failedConflictDetections: number;\n  failedMerges: number;\n  \n  // Resource utilization\n  cpuUsagePercent: number;\n  activeThreads: number;\n  queuedOperations: number;\n}\n\nexport interface OptimizationConfig {\n  // Performance tuning\n  maxConcurrentOperations: number;\n  batchProcessingSize: number;\n  memoryCleanupInterval: number;\n  \n  // Caching\n  enableResultCaching: boolean;\n  cacheExpirationTime: number;\n  maxCacheSize: number;\n  \n  // Algorithm optimization\n  useAsyncProcessing: boolean;\n  enableProgressiveLoading: boolean;\n  optimizeForLargeDocuments: boolean;\n  \n  // Resource limits\n  maxMemoryUsage: number; // MB\n  maxProcessingTime: number; // ms\n  backgroundProcessingThrottle: number; // ms between operations\n}\n\n/**\n * Performance Monitor for Multi-Plugin Operations\n */\nexport class ConsolidationPerformanceMonitor {\n  private metrics: PerformanceMetrics;\n  private config: OptimizationConfig;\n  private startTimes = new Map<string, number>();\n  private operationHistory: Array<{timestamp: number, duration: number, type: string}> = [];\n  private memoryUsageHistory: number[] = [];\n  \n  // Performance caches\n  private conflictDetectionCache = new Map<string, ChangeConflict[]>();\n  private mergeResultCache = new Map<string, EditChange[]>();\n  private documentHashCache = new Map<string, string>();\n\n  constructor(config: Partial<OptimizationConfig> = {}) {\n    this.config = {\n      maxConcurrentOperations: 5,\n      batchProcessingSize: 10,\n      memoryCleanupInterval: 60000, // 1 minute\n      enableResultCaching: true,\n      cacheExpirationTime: 300000, // 5 minutes\n      maxCacheSize: 1000,\n      useAsyncProcessing: true,\n      enableProgressiveLoading: true,\n      optimizeForLargeDocuments: true,\n      maxMemoryUsage: 512, // 512 MB\n      maxProcessingTime: 30000, // 30 seconds\n      backgroundProcessingThrottle: 100,\n      ...config\n    };\n\n    this.metrics = {\n      averageConflictDetectionTime: 0,\n      averageMergeTime: 0,\n      averageConsolidationTime: 0,\n      currentMemoryUsage: 0,\n      peakMemoryUsage: 0,\n      operationsInMemory: 0,\n      operationsPerSecond: 0,\n      conflictsPerSecond: 0,\n      mergesPerSecond: 0,\n      failedOperations: 0,\n      failedConflictDetections: 0,\n      failedMerges: 0,\n      cpuUsagePercent: 0,\n      activeThreads: 0,\n      queuedOperations: 0\n    };\n\n    this.startPerformanceMonitoring();\n  }\n\n  /**\n   * Start timing an operation\n   */\n  startTiming(operationId: string, type: 'conflict_detection' | 'merge' | 'consolidation'): void {\n    this.startTimes.set(`${operationId}:${type}`, performance.now());\n  }\n\n  /**\n   * End timing and update metrics\n   */\n  endTiming(operationId: string, type: 'conflict_detection' | 'merge' | 'consolidation', success: boolean): number {\n    const key = `${operationId}:${type}`;\n    const startTime = this.startTimes.get(key);\n    \n    if (!startTime) return 0;\n    \n    const duration = performance.now() - startTime;\n    this.startTimes.delete(key);\n    \n    // Update operation history\n    this.operationHistory.push({ timestamp: Date.now(), duration, type });\n    \n    // Keep only last 1000 operations for memory efficiency\n    if (this.operationHistory.length > 1000) {\n      this.operationHistory = this.operationHistory.slice(-1000);\n    }\n    \n    // Update metrics\n    if (success) {\n      this.updateAverageMetric(type, duration);\n    } else {\n      this.incrementFailureMetric(type);\n    }\n    \n    return duration;\n  }\n\n  /**\n   * Check if operation should be cached\n   */\n  shouldCacheResult(operationId: string, complexity: number): boolean {\n    if (!this.config.enableResultCaching) return false;\n    \n    // Cache complex operations or operations that take significant time\n    return complexity > 100 || this.operationHistory.some(op => \n      op.type === 'consolidation' && op.duration > 1000\n    );\n  }\n\n  /**\n   * Generate cache key for conflict detection\n   */\n  generateConflictCacheKey(operations: MultiPluginEditOperation[]): string {\n    // Create a hash of the operations for caching\n    const operationSummary = operations.map(op => ({\n      id: op.id,\n      pluginId: op.pluginId,\n      changeCount: op.changes.length,\n      timestamp: op.timestamp,\n      documentPath: op.documentPath\n    }));\n    \n    return btoa(JSON.stringify(operationSummary));\n  }\n\n  /**\n   * Get cached conflict detection result\n   */\n  getCachedConflictDetection(cacheKey: string): ChangeConflict[] | null {\n    const cached = this.conflictDetectionCache.get(cacheKey);\n    return cached || null;\n  }\n\n  /**\n   * Cache conflict detection result\n   */\n  cacheConflictDetection(cacheKey: string, conflicts: ChangeConflict[]): void {\n    if (this.conflictDetectionCache.size >= this.config.maxCacheSize) {\n      // Remove oldest entries\n      const keysToRemove = Array.from(this.conflictDetectionCache.keys()).slice(0, 100);\n      keysToRemove.forEach(key => this.conflictDetectionCache.delete(key));\n    }\n    \n    this.conflictDetectionCache.set(cacheKey, conflicts);\n    \n    // Set expiration\n    setTimeout(() => {\n      this.conflictDetectionCache.delete(cacheKey);\n    }, this.config.cacheExpirationTime);\n  }\n\n  /**\n   * Optimize change processing for large documents\n   */\n  async optimizeForLargeDocument(\n    changes: EditChange[], \n    callback: (batch: EditChange[]) => Promise<void>\n  ): Promise<void> {\n    if (!this.config.optimizeForLargeDocuments || changes.length <= this.config.batchProcessingSize) {\n      await callback(changes);\n      return;\n    }\n\n    // Process in batches to avoid blocking UI\n    const batches = this.createBatches(changes, this.config.batchProcessingSize);\n    \n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      \n      // Throttle processing to prevent UI blocking\n      if (i > 0) {\n        await this.throttle(this.config.backgroundProcessingThrottle);\n      }\n      \n      await callback(batch);\n      \n      // Update progress\n      this.updateProcessingProgress((i + 1) / batches.length);\n      \n      // Check memory usage and trigger cleanup if needed\n      if (this.shouldTriggerMemoryCleanup()) {\n        await this.performMemoryCleanup();\n      }\n    }\n  }\n\n  /**\n   * Create optimized range tree for efficient conflict detection\n   */\n  createRangeTree(changes: EditChange[]): RangeTree {\n    // Sort changes by position for efficient range queries\n    const sortedChanges = [...changes].sort((a, b) => a.from - b.from);\n    \n    return new RangeTree(sortedChanges);\n  }\n\n  /**\n   * Efficient overlap detection using range tree\n   */\n  findOverlappingChanges(\n    rangeTree: RangeTree, \n    targetChange: EditChange, \n    tolerance: number = 0\n  ): EditChange[] {\n    return rangeTree.findOverlapping(\n      targetChange.from - tolerance, \n      targetChange.to + tolerance\n    );\n  }\n\n  /**\n   * Memory-efficient change grouping\n   */\n  groupChangesByProximity(changes: EditChange[], proximityThreshold: number = 100): EditChange[][] {\n    if (changes.length === 0) return [];\n    \n    const sortedChanges = [...changes].sort((a, b) => a.from - b.from);\n    const groups: EditChange[][] = [];\n    let currentGroup: EditChange[] = [sortedChanges[0]];\n    \n    for (let i = 1; i < sortedChanges.length; i++) {\n      const currentChange = sortedChanges[i];\n      const lastChange = currentGroup[currentGroup.length - 1];\n      \n      if (currentChange.from - lastChange.to <= proximityThreshold) {\n        currentGroup.push(currentChange);\n      } else {\n        groups.push(currentGroup);\n        currentGroup = [currentChange];\n      }\n    }\n    \n    groups.push(currentGroup);\n    return groups;\n  }\n\n  /**\n   * Estimate processing complexity\n   */\n  estimateComplexity(operations: MultiPluginEditOperation[]): number {\n    let complexity = 0;\n    \n    // Base complexity from number of operations\n    complexity += operations.length * 10;\n    \n    // Add complexity for each change\n    for (const op of operations) {\n      complexity += op.changes.length * 5;\n      \n      // Add complexity for large text changes\n      for (const change of op.changes) {\n        const textLength = (change.text || change.removedText || '').length;\n        complexity += Math.min(textLength / 100, 50); // Cap at 50 points per change\n      }\n      \n      // Add complexity for semantic context processing\n      if (op.changes.some(c => c.semanticContext)) {\n        complexity += 25;\n      }\n    }\n    \n    return complexity;\n  }\n\n  /**\n   * Check if processing should be throttled\n   */\n  shouldThrottleProcessing(): boolean {\n    return this.metrics.currentMemoryUsage > this.config.maxMemoryUsage * 0.8 ||\n           this.metrics.cpuUsagePercent > 80 ||\n           this.metrics.queuedOperations > this.config.maxConcurrentOperations * 2;\n  }\n\n  /**\n   * Get performance recommendations\n   */\n  getPerformanceRecommendations(): string[] {\n    const recommendations: string[] = [];\n    \n    if (this.metrics.averageConflictDetectionTime > 500) {\n      recommendations.push('Consider enabling result caching to improve conflict detection performance');\n    }\n    \n    if (this.metrics.currentMemoryUsage > this.config.maxMemoryUsage * 0.7) {\n      recommendations.push('Memory usage is high - consider reducing batch size or enabling more aggressive cleanup');\n    }\n    \n    if (this.metrics.failedOperations / (this.operationHistory.length || 1) > 0.05) {\n      recommendations.push('Error rate is elevated - check for data quality issues or system resource constraints');\n    }\n    \n    if (this.metrics.operationsPerSecond < 1) {\n      recommendations.push('Processing throughput is low - consider enabling async processing or increasing batch size');\n    }\n    \n    return recommendations;\n  }\n\n  /**\n   * Export performance data for analysis\n   */\n  exportPerformanceData(): {\n    metrics: PerformanceMetrics;\n    config: OptimizationConfig;\n    operationHistory: Array<{timestamp: number, duration: number, type: string}>;\n    memoryHistory: number[];\n    recommendations: string[];\n  } {\n    return {\n      metrics: { ...this.metrics },\n      config: { ...this.config },\n      operationHistory: [...this.operationHistory],\n      memoryHistory: [...this.memoryUsageHistory],\n      recommendations: this.getPerformanceRecommendations()\n    };\n  }\n\n  // Private helper methods\n\n  private startPerformanceMonitoring(): void {\n    // Update metrics periodically\n    setInterval(() => {\n      this.updateRealTimeMetrics();\n      this.updateMemoryUsage();\n    }, 1000);\n    \n    // Cleanup old data periodically\n    setInterval(() => {\n      this.performPeriodicCleanup();\n    }, this.config.memoryCleanupInterval);\n  }\n\n  private updateAverageMetric(type: string, duration: number): void {\n    const recentOperations = this.operationHistory.filter(op => \n      op.type === type && op.timestamp > Date.now() - 60000 // Last minute\n    );\n    \n    if (recentOperations.length === 0) return;\n    \n    const averageDuration = recentOperations.reduce((sum, op) => sum + op.duration, 0) / recentOperations.length;\n    \n    switch (type) {\n      case 'conflict_detection':\n        this.metrics.averageConflictDetectionTime = averageDuration;\n        break;\n      case 'merge':\n        this.metrics.averageMergeTime = averageDuration;\n        break;\n      case 'consolidation':\n        this.metrics.averageConsolidationTime = averageDuration;\n        break;\n    }\n  }\n\n  private incrementFailureMetric(type: string): void {\n    switch (type) {\n      case 'conflict_detection':\n        this.metrics.failedConflictDetections++;\n        break;\n      case 'merge':\n        this.metrics.failedMerges++;\n        break;\n      case 'consolidation':\n        this.metrics.failedOperations++;\n        break;\n    }\n  }\n\n  private updateRealTimeMetrics(): void {\n    const now = Date.now();\n    const recentOperations = this.operationHistory.filter(op => \n      now - op.timestamp < 1000 // Last second\n    );\n    \n    this.metrics.operationsPerSecond = recentOperations.length;\n    this.metrics.conflictsPerSecond = recentOperations.filter(op => op.type === 'conflict_detection').length;\n    this.metrics.mergesPerSecond = recentOperations.filter(op => op.type === 'merge').length;\n  }\n\n  private updateMemoryUsage(): void {\n    // Estimate memory usage (in a real implementation, this would use actual memory APIs)\n    const estimatedUsage = \n      this.conflictDetectionCache.size * 0.1 + // Rough estimate\n      this.mergeResultCache.size * 0.05 +\n      this.operationHistory.length * 0.001;\n    \n    this.metrics.currentMemoryUsage = estimatedUsage;\n    this.metrics.peakMemoryUsage = Math.max(this.metrics.peakMemoryUsage, estimatedUsage);\n    \n    // Track memory history\n    this.memoryUsageHistory.push(estimatedUsage);\n    if (this.memoryUsageHistory.length > 1000) {\n      this.memoryUsageHistory = this.memoryUsageHistory.slice(-1000);\n    }\n  }\n\n  private shouldTriggerMemoryCleanup(): boolean {\n    return this.metrics.currentMemoryUsage > this.config.maxMemoryUsage * 0.8;\n  }\n\n  private async performMemoryCleanup(): Promise<void> {\n    // Clear old cache entries\n    const cacheEntries = Array.from(this.conflictDetectionCache.entries());\n    const entriesToRemove = cacheEntries.slice(0, Math.floor(cacheEntries.length * 0.3));\n    entriesToRemove.forEach(([key]) => this.conflictDetectionCache.delete(key));\n    \n    // Clear old operation history\n    if (this.operationHistory.length > 500) {\n      this.operationHistory = this.operationHistory.slice(-500);\n    }\n    \n    // Clear old memory history\n    if (this.memoryUsageHistory.length > 500) {\n      this.memoryUsageHistory = this.memoryUsageHistory.slice(-500);\n    }\n    \n    // Force garbage collection if available\n    if (global.gc) {\n      global.gc();\n    }\n  }\n\n  private performPeriodicCleanup(): void {\n    // Remove expired cache entries\n    this.cleanupExpiredCache();\n    \n    // Update metrics\n    this.updateRealTimeMetrics();\n    this.updateMemoryUsage();\n  }\n\n  private cleanupExpiredCache(): void {\n    // This would be implemented with timestamp tracking in a real scenario\n    if (this.conflictDetectionCache.size > this.config.maxCacheSize) {\n      const keysToRemove = Array.from(this.conflictDetectionCache.keys()).slice(0, 100);\n      keysToRemove.forEach(key => this.conflictDetectionCache.delete(key));\n    }\n  }\n\n  private createBatches<T>(items: T[], batchSize: number): T[][] {\n    const batches: T[][] = [];\n    for (let i = 0; i < items.length; i += batchSize) {\n      batches.push(items.slice(i, i + batchSize));\n    }\n    return batches;\n  }\n\n  private async throttle(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  private updateProcessingProgress(progress: number): void {\n    // This could emit events or update UI progress indicators\n    console.log(`Processing progress: ${Math.round(progress * 100)}%`);\n  }\n\n  // Getter methods\n  getMetrics(): PerformanceMetrics {\n    return { ...this.metrics };\n  }\n\n  getConfig(): OptimizationConfig {\n    return { ...this.config };\n  }\n\n  updateConfig(newConfig: Partial<OptimizationConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n}\n\n/**\n * Efficient Range Tree for fast overlap detection\n */\nclass RangeTree {\n  private changes: EditChange[];\n  private sortedByStart: EditChange[];\n  private sortedByEnd: EditChange[];\n\n  constructor(changes: EditChange[]) {\n    this.changes = changes;\n    this.sortedByStart = [...changes].sort((a, b) => a.from - b.from);\n    this.sortedByEnd = [...changes].sort((a, b) => a.to - b.to);\n  }\n\n  findOverlapping(start: number, end: number): EditChange[] {\n    const overlapping: EditChange[] = [];\n    \n    // Use binary search for efficient range queries\n    const startIndex = this.binarySearchStart(start);\n    const endIndex = this.binarySearchEnd(end);\n    \n    // Check all changes that might overlap\n    for (let i = startIndex; i <= endIndex && i < this.sortedByStart.length; i++) {\n      const change = this.sortedByStart[i];\n      if (change.from < end && change.to > start) {\n        overlapping.push(change);\n      }\n    }\n    \n    return overlapping;\n  }\n\n  private binarySearchStart(target: number): number {\n    let left = 0;\n    let right = this.sortedByStart.length - 1;\n    \n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.sortedByStart[mid].from <= target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    \n    return Math.max(0, right);\n  }\n\n  private binarySearchEnd(target: number): number {\n    let left = 0;\n    let right = this.sortedByEnd.length - 1;\n    \n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      if (this.sortedByEnd[mid].to < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n    \n    return Math.min(this.sortedByEnd.length - 1, left);\n  }\n}\n\n/**\n * Error Recovery and Resilience Manager\n */\nexport class ConsolidationErrorManager {\n  private errorHistory: Array<{timestamp: number, type: string, message: string, context?: any}> = [];\n  private recoveryStrategies = new Map<string, (error: Error, context?: any) => Promise<boolean>>();\n\n  constructor() {\n    this.initializeRecoveryStrategies();\n  }\n\n  /**\n   * Handle and attempt to recover from errors\n   */\n  async handleError(error: Error, context: any = {}): Promise<{recovered: boolean, fallbackApplied: boolean}> {\n    const errorType = this.categorizeError(error);\n    \n    // Log error\n    this.errorHistory.push({\n      timestamp: Date.now(),\n      type: errorType,\n      message: error.message,\n      context\n    });\n    \n    // Keep only recent errors\n    if (this.errorHistory.length > 1000) {\n      this.errorHistory = this.errorHistory.slice(-1000);\n    }\n    \n    // Attempt recovery\n    const recoveryStrategy = this.recoveryStrategies.get(errorType);\n    let recovered = false;\n    \n    if (recoveryStrategy) {\n      try {\n        recovered = await recoveryStrategy(error, context);\n      } catch (recoveryError) {\n        console.error('Recovery strategy failed:', recoveryError);\n      }\n    }\n    \n    // Apply fallback if recovery failed\n    const fallbackApplied = !recovered && await this.applyFallback(errorType, context);\n    \n    return { recovered, fallbackApplied };\n  }\n\n  private categorizeError(error: Error): string {\n    if (error.message.includes('memory')) return 'memory_error';\n    if (error.message.includes('timeout')) return 'timeout_error';\n    if (error.message.includes('conflict')) return 'conflict_error';\n    if (error.message.includes('merge')) return 'merge_error';\n    if (error.message.includes('permission')) return 'permission_error';\n    return 'unknown_error';\n  }\n\n  private initializeRecoveryStrategies(): void {\n    // Memory error recovery\n    this.recoveryStrategies.set('memory_error', async (error, context) => {\n      console.log('Attempting memory error recovery...');\n      \n      // Clear caches and trigger cleanup\n      if (global.gc) global.gc();\n      \n      // Retry with smaller batch size\n      if (context?.batchSize > 1) {\n        context.batchSize = Math.max(1, Math.floor(context.batchSize / 2));\n        return true;\n      }\n      \n      return false;\n    });\n\n    // Timeout error recovery\n    this.recoveryStrategies.set('timeout_error', async (error, context) => {\n      console.log('Attempting timeout error recovery...');\n      \n      // Increase timeout and retry\n      if (context?.timeout < 60000) {\n        context.timeout = Math.min(60000, context.timeout * 2);\n        return true;\n      }\n      \n      return false;\n    });\n\n    // Conflict error recovery\n    this.recoveryStrategies.set('conflict_error', async (error, context) => {\n      console.log('Attempting conflict error recovery...');\n      \n      // Switch to sequential processing\n      if (context?.processingMode !== 'sequential') {\n        context.processingMode = 'sequential';\n        return true;\n      }\n      \n      return false;\n    });\n  }\n\n  private async applyFallback(errorType: string, context: any): Promise<boolean> {\n    switch (errorType) {\n      case 'memory_error':\n        // Fall back to minimal processing\n        if (context?.operations) {\n          context.operations = context.operations.slice(0, 1);\n          return true;\n        }\n        break;\n        \n      case 'merge_error':\n        // Fall back to priority-based resolution\n        if (context?.strategy !== 'priority_wins') {\n          context.strategy = 'priority_wins';\n          return true;\n        }\n        break;\n        \n      default:\n        // Generic fallback - disable advanced features\n        if (context?.enableAdvanced !== false) {\n          context.enableAdvanced = false;\n          return true;\n        }\n    }\n    \n    return false;\n  }\n\n  getErrorStatistics(): {\n    totalErrors: number;\n    errorsByType: Record<string, number>;\n    recentErrorRate: number;\n    recoverySuccessRate: number;\n  } {\n    const now = Date.now();\n    const recentErrors = this.errorHistory.filter(e => now - e.timestamp < 3600000); // Last hour\n    \n    const errorsByType: Record<string, number> = {};\n    this.errorHistory.forEach(error => {\n      errorsByType[error.type] = (errorsByType[error.type] || 0) + 1;\n    });\n    \n    return {\n      totalErrors: this.errorHistory.length,\n      errorsByType,\n      recentErrorRate: recentErrors.length / 60, // Errors per minute\n      recoverySuccessRate: 0.85 // This would be tracked in a real implementation\n    };\n  }\n}", "/**\n * Change Conflict Detection Algorithms\n * \n * Advanced algorithms for detecting conflicts between simultaneous multi-plugin edits:\n * - Text overlap detection with semantic analysis\n * - Dependency violation detection\n * - Resource contention analysis\n * - Priority-based conflict identification\n */\n\nimport { \n  EditChange, \n  MultiPluginEditOperation, \n  ChangeConflict, \n  ConflictType, \n  ConflictSeverity,\n  SemanticContext,\n  OperationPriority \n} from './change-consolidation-manager';\n\nexport interface ConflictDetectionConfig {\n  enableSemanticAnalysis: boolean;\n  overlapTolerance: number; // Characters of overlap allowed\n  dependencyDepth: number; // How deep to analyze dependencies\n  temporalWindow: number; // Time window for considering operations simultaneous (ms)\n  priorityThreshold: number; // Priority difference threshold for conflicts\n}\n\nexport interface ConflictAnalysisResult {\n  hasConflict: boolean;\n  conflictType: ConflictType;\n  severity: ConflictSeverity;\n  details: ConflictDetails;\n  suggestedResolution?: string;\n}\n\nexport interface ConflictDetails {\n  overlappingRanges?: Array<{start: number, end: number, operations: string[]}>;\n  dependencyChain?: string[];\n  semanticConflicts?: Array<{intention1: string, intention2: string, compatibility: number}>;\n  resourceContention?: {resource: string, requestingPlugins: string[]};\n  priorityMismatch?: {operation1: OperationPriority, operation2: OperationPriority, threshold: number};\n}\n\n/**\n * Advanced Conflict Detection Engine\n */\nexport class ConflictDetectionEngine {\n  private config: ConflictDetectionConfig;\n  private semanticCompatibilityMatrix: Map<string, Map<string, number>>;\n\n  constructor(config: Partial<ConflictDetectionConfig> = {}) {\n    this.config = {\n      enableSemanticAnalysis: true,\n      overlapTolerance: 3, // Allow 3 characters of overlap\n      dependencyDepth: 5,\n      temporalWindow: 5000, // 5 seconds\n      priorityThreshold: 1,\n      ...config\n    };\n\n    this.initializeSemanticCompatibilityMatrix();\n  }\n\n  /**\n   * Detect all conflicts among a set of operations\n   */\n  async detectConflicts(operations: MultiPluginEditOperation[]): Promise<ChangeConflict[]> {\n    const conflicts: ChangeConflict[] = [];\n    \n    // Filter operations within temporal window\n    const simultaneousOps = this.filterSimultaneousOperations(operations);\n    \n    if (simultaneousOps.length < 2) {\n      return conflicts;\n    }\n\n    // Check all pairs of operations for conflicts\n    for (let i = 0; i < simultaneousOps.length; i++) {\n      for (let j = i + 1; j < simultaneousOps.length; j++) {\n        const op1 = simultaneousOps[i];\n        const op2 = simultaneousOps[j];\n        \n        const conflict = await this.analyzeOperationPair(op1, op2);\n        if (conflict) {\n          conflicts.push(conflict);\n        }\n      }\n    }\n\n    // Check for multi-operation conflicts\n    const multiOpConflicts = await this.detectMultiOperationConflicts(simultaneousOps);\n    conflicts.push(...multiOpConflicts);\n\n    // Sort by severity\n    return conflicts.sort((a, b) => this.getSeverityWeight(b.severity) - this.getSeverityWeight(a.severity));\n  }\n\n  /**\n   * Analyze a pair of operations for conflicts\n   */\n  private async analyzeOperationPair(\n    op1: MultiPluginEditOperation, \n    op2: MultiPluginEditOperation\n  ): Promise<ChangeConflict | null> {\n    // Skip if operations are from plugins that can merge\n    if (op1.capabilities.canMergeWith.includes(op2.pluginId) && \n        op2.capabilities.canMergeWith.includes(op1.pluginId)) {\n      return null;\n    }\n\n    const analyses = await Promise.all([\n      this.analyzeTextOverlap(op1, op2),\n      this.analyzeSemanticConflict(op1, op2),\n      this.analyzeDependencyViolation(op1, op2),\n      this.analyzeResourceContention(op1, op2),\n      this.analyzePriorityConflict(op1, op2)\n    ]);\n\n    // Find the most severe conflict\n    const conflictAnalysis = analyses.find(analysis => analysis.hasConflict);\n    \n    if (!conflictAnalysis) {\n      return null;\n    }\n\n    return {\n      id: `conflict_${op1.id}_${op2.id}_${Date.now()}`,\n      type: conflictAnalysis.conflictType,\n      severity: conflictAnalysis.severity,\n      operations: [op1, op2],\n      conflictingChanges: [...op1.changes, ...op2.changes],\n      detectedAt: Date.now(),\n      userVisible: this.shouldBeUserVisible(conflictAnalysis.severity, op1, op2)\n    };\n  }\n\n  /**\n   * Analyze text overlap between operations\n   */\n  private async analyzeTextOverlap(\n    op1: MultiPluginEditOperation, \n    op2: MultiPluginEditOperation\n  ): Promise<ConflictAnalysisResult> {\n    const overlappingRanges: Array<{start: number, end: number, operations: string[]}> = [];\n    \n    // Check each change in op1 against each change in op2\n    for (const change1 of op1.changes) {\n      for (const change2 of op2.changes) {\n        const overlap = this.calculateRangeOverlap(\n          {start: change1.from, end: change1.to},\n          {start: change2.from, end: change2.to}\n        );\n        \n        if (overlap && overlap.size > this.config.overlapTolerance) {\n          overlappingRanges.push({\n            start: overlap.start,\n            end: overlap.end,\n            operations: [op1.id, op2.id]\n          });\n        }\n      }\n    }\n    \n    if (overlappingRanges.length > 0) {\n      // Analyze the severity of overlap\n      const totalOverlap = overlappingRanges.reduce((sum, range) => sum + (range.end - range.start), 0);\n      const severity = this.calculateOverlapSeverity(totalOverlap, op1, op2);\n      \n      return {\n        hasConflict: true,\n        conflictType: ConflictType.OVERLAPPING_EDITS,\n        severity,\n        details: { overlappingRanges },\n        suggestedResolution: this.suggestOverlapResolution(overlappingRanges, op1, op2)\n      };\n    }\n    \n    return {\n      hasConflict: false,\n      conflictType: ConflictType.OVERLAPPING_EDITS,\n      severity: ConflictSeverity.INFO,\n      details: {}\n    };\n  }\n\n  /**\n   * Analyze semantic conflicts between operations\n   */\n  private async analyzeSemanticConflict(\n    op1: MultiPluginEditOperation, \n    op2: MultiPluginEditOperation\n  ): Promise<ConflictAnalysisResult> {\n    if (!this.config.enableSemanticAnalysis) {\n      return {\n        hasConflict: false,\n        conflictType: ConflictType.SEMANTIC_CONFLICT,\n        severity: ConflictSeverity.INFO,\n        details: {}\n      };\n    }\n\n    const semanticConflicts: Array<{intention1: string, intention2: string, compatibility: number}> = [];\n    \n    // Compare semantic contexts of overlapping or nearby changes\n    for (const change1 of op1.changes) {\n      for (const change2 of op2.changes) {\n        if (!change1.semanticContext || !change2.semanticContext) continue;\n        \n        // Check if changes are in the same semantic scope\n        const distance = Math.abs(change1.from - change2.from);\n        const inSameScope = this.areInSameSemanticScope(change1.semanticContext, change2.semanticContext, distance);\n        \n        if (inSameScope) {\n          const compatibility = this.calculateSemanticCompatibility(\n            change1.semanticContext.intention,\n            change2.semanticContext.intention\n          );\n          \n          if (compatibility < 0.3) { // Low compatibility threshold\n            semanticConflicts.push({\n              intention1: change1.semanticContext.intention,\n              intention2: change2.semanticContext.intention,\n              compatibility\n            });\n          }\n        }\n      }\n    }\n    \n    if (semanticConflicts.length > 0) {\n      const avgCompatibility = semanticConflicts.reduce((sum, conf) => sum + conf.compatibility, 0) / semanticConflicts.length;\n      const severity = avgCompatibility < 0.1 ? ConflictSeverity.HIGH : ConflictSeverity.MEDIUM;\n      \n      return {\n        hasConflict: true,\n        conflictType: ConflictType.SEMANTIC_CONFLICT,\n        severity,\n        details: { semanticConflicts },\n        suggestedResolution: this.suggestSemanticResolution(semanticConflicts, op1, op2)\n      };\n    }\n    \n    return {\n      hasConflict: false,\n      conflictType: ConflictType.SEMANTIC_CONFLICT,\n      severity: ConflictSeverity.INFO,\n      details: {}\n    };\n  }\n\n  /**\n   * Analyze dependency violations between operations\n   */\n  private async analyzeDependencyViolation(\n    op1: MultiPluginEditOperation, \n    op2: MultiPluginEditOperation\n  ): Promise<ConflictAnalysisResult> {\n    const dependencyChain: string[] = [];\n    \n    // Check if any changes in op1 depend on changes in op2 or vice versa\n    for (const change1 of op1.changes) {\n      if (change1.dependsOn) {\n        for (const dep of change1.dependsOn) {\n          const dependentChange = op2.changes.find(change => change.id === dep);\n          if (dependentChange) {\n            dependencyChain.push(`${change1.id} -> ${dep}`);\n          }\n        }\n      }\n    }\n    \n    // Check reverse dependencies\n    for (const change2 of op2.changes) {\n      if (change2.dependsOn) {\n        for (const dep of change2.dependsOn) {\n          const dependentChange = op1.changes.find(change => change.id === dep);\n          if (dependentChange) {\n            dependencyChain.push(`${change2.id} -> ${dep}`);\n          }\n        }\n      }\n    }\n    \n    // Check for circular dependencies\n    const hasCircularDependency = this.detectCircularDependencies([...op1.changes, ...op2.changes]);\n    \n    if (dependencyChain.length > 0 || hasCircularDependency) {\n      return {\n        hasConflict: true,\n        conflictType: ConflictType.DEPENDENCY_VIOLATION,\n        severity: hasCircularDependency ? ConflictSeverity.CRITICAL : ConflictSeverity.HIGH,\n        details: { dependencyChain },\n        suggestedResolution: hasCircularDependency ? \n          'Break circular dependency by sequential processing' : \n          'Process operations in dependency order'\n      };\n    }\n    \n    return {\n      hasConflict: false,\n      conflictType: ConflictType.DEPENDENCY_VIOLATION,\n      severity: ConflictSeverity.INFO,\n      details: {}\n    };\n  }\n\n  /**\n   * Analyze resource contention between operations\n   */\n  private async analyzeResourceContention(\n    op1: MultiPluginEditOperation, \n    op2: MultiPluginEditOperation\n  ): Promise<ConflictAnalysisResult> {\n    // Check if both operations require exclusive access to the same resources\n    const sharedResources = this.findSharedResources(op1, op2);\n    \n    if (sharedResources.length > 0) {\n      // Check if either operation requires exclusive access\n      const requiresExclusiveAccess = this.requiresExclusiveAccess(op1) || this.requiresExclusiveAccess(op2);\n      \n      if (requiresExclusiveAccess) {\n        return {\n          hasConflict: true,\n          conflictType: ConflictType.RESOURCE_CONTENTION,\n          severity: ConflictSeverity.HIGH,\n          details: { \n            resourceContention: { \n              resource: sharedResources[0], \n              requestingPlugins: [op1.pluginId, op2.pluginId] \n            } \n          },\n          suggestedResolution: 'Sequential processing required for exclusive resource access'\n        };\n      }\n    }\n    \n    return {\n      hasConflict: false,\n      conflictType: ConflictType.RESOURCE_CONTENTION,\n      severity: ConflictSeverity.INFO,\n      details: {}\n    };\n  }\n\n  /**\n   * Analyze priority conflicts between operations\n   */\n  private async analyzePriorityConflict(\n    op1: MultiPluginEditOperation, \n    op2: MultiPluginEditOperation\n  ): Promise<ConflictAnalysisResult> {\n    const priorityDiff = Math.abs(op1.priority - op2.priority);\n    \n    if (priorityDiff >= this.config.priorityThreshold) {\n      // Check if lower priority operation might interfere with higher priority one\n      const interference = await this.checkPriorityInterference(op1, op2);\n      \n      if (interference) {\n        return {\n          hasConflict: true,\n          conflictType: ConflictType.PRIORITY_CONFLICT,\n          severity: priorityDiff >= 2 ? ConflictSeverity.HIGH : ConflictSeverity.MEDIUM,\n          details: { \n            priorityMismatch: { \n              operation1: op1.priority, \n              operation2: op2.priority, \n              threshold: this.config.priorityThreshold \n            } \n          },\n          suggestedResolution: 'Process higher priority operation first'\n        };\n      }\n    }\n    \n    return {\n      hasConflict: false,\n      conflictType: ConflictType.PRIORITY_CONFLICT,\n      severity: ConflictSeverity.INFO,\n      details: {}\n    };\n  }\n\n  /**\n   * Detect multi-operation conflicts (more than 2 operations)\n   */\n  private async detectMultiOperationConflicts(operations: MultiPluginEditOperation[]): Promise<ChangeConflict[]> {\n    if (operations.length < 3) return [];\n    \n    const conflicts: ChangeConflict[] = [];\n    \n    // Look for operations that all affect the same document region\n    const regionConflicts = this.findRegionConflicts(operations);\n    conflicts.push(...regionConflicts);\n    \n    // Look for complex dependency chains\n    const dependencyConflicts = this.findComplexDependencyConflicts(operations);\n    conflicts.push(...dependencyConflicts);\n    \n    return conflicts;\n  }\n\n  // Utility methods\n  \n  private filterSimultaneousOperations(operations: MultiPluginEditOperation[]): MultiPluginEditOperation[] {\n    if (operations.length <= 1) return operations;\n    \n    const now = Date.now();\n    return operations.filter(op => (now - op.timestamp) <= this.config.temporalWindow);\n  }\n\n  private calculateRangeOverlap(range1: {start: number, end: number}, range2: {start: number, end: number}): {start: number, end: number, size: number} | null {\n    const start = Math.max(range1.start, range2.start);\n    const end = Math.min(range1.end, range2.end);\n    \n    if (start < end) {\n      return { start, end, size: end - start };\n    }\n    \n    return null;\n  }\n\n  private calculateOverlapSeverity(totalOverlap: number, op1: MultiPluginEditOperation, op2: MultiPluginEditOperation): ConflictSeverity {\n    // Consider the size of changes and their context\n    const totalChangeSize = [...op1.changes, ...op2.changes].reduce((sum, change) => \n      sum + (change.to - change.from), 0);\n    \n    const overlapRatio = totalOverlap / totalChangeSize;\n    \n    if (overlapRatio > 0.8) return ConflictSeverity.CRITICAL;\n    if (overlapRatio > 0.5) return ConflictSeverity.HIGH;\n    if (overlapRatio > 0.2) return ConflictSeverity.MEDIUM;\n    return ConflictSeverity.LOW;\n  }\n\n  private initializeSemanticCompatibilityMatrix(): void {\n    this.semanticCompatibilityMatrix = new Map();\n    \n    // Define compatibility scores between different semantic intentions\n    const intentions = ['correction', 'enhancement', 'formatting', 'content_addition', 'restructuring'];\n    const compatibilityScores = [\n      [0.8, 0.6, 0.7, 0.3, 0.2], // correction\n      [0.6, 0.9, 0.8, 0.7, 0.4], // enhancement  \n      [0.7, 0.8, 0.9, 0.5, 0.3], // formatting\n      [0.3, 0.7, 0.5, 0.8, 0.6], // content_addition\n      [0.2, 0.4, 0.3, 0.6, 0.9]  // restructuring\n    ];\n    \n    intentions.forEach((intent1, i) => {\n      const compatMap = new Map();\n      intentions.forEach((intent2, j) => {\n        compatMap.set(intent2, compatibilityScores[i][j]);\n      });\n      this.semanticCompatibilityMatrix.set(intent1, compatMap);\n    });\n  }\n\n  private calculateSemanticCompatibility(intention1: string, intention2: string): number {\n    const compatMap = this.semanticCompatibilityMatrix.get(intention1);\n    return compatMap?.get(intention2) ?? 0.5; // Default neutral compatibility\n  }\n\n  private areInSameSemanticScope(context1: SemanticContext, context2: SemanticContext, distance: number): boolean {\n    // Define scope distances\n    const scopeDistances = {\n      word: 10,\n      sentence: 100,\n      paragraph: 500,\n      section: 2000,\n      document: Infinity\n    };\n    \n    const maxScope = context1.scope === context2.scope ? context1.scope : \n      (scopeDistances[context1.scope] > scopeDistances[context2.scope] ? context1.scope : context2.scope);\n    \n    return distance <= scopeDistances[maxScope];\n  }\n\n  private detectCircularDependencies(changes: EditChange[]): boolean {\n    // Build dependency graph and check for cycles\n    const graph = new Map<string, string[]>();\n    \n    for (const change of changes) {\n      if (change.id && change.dependsOn) {\n        graph.set(change.id, change.dependsOn);\n      }\n    }\n    \n    // DFS to detect cycles\n    const visited = new Set<string>();\n    const recursionStack = new Set<string>();\n    \n    const hasCycle = (node: string): boolean => {\n      if (recursionStack.has(node)) return true;\n      if (visited.has(node)) return false;\n      \n      visited.add(node);\n      recursionStack.add(node);\n      \n      const dependencies = graph.get(node) || [];\n      for (const dep of dependencies) {\n        if (hasCycle(dep)) return true;\n      }\n      \n      recursionStack.delete(node);\n      return false;\n    };\n    \n    for (const node of graph.keys()) {\n      if (hasCycle(node)) return true;\n    }\n    \n    return false;\n  }\n\n  private findSharedResources(op1: MultiPluginEditOperation, op2: MultiPluginEditOperation): string[] {\n    // For now, consider the document itself as the primary resource\n    // Could be extended to include specific document sections, styles, etc.\n    return op1.documentPath === op2.documentPath ? [op1.documentPath] : [];\n  }\n\n  private requiresExclusiveAccess(operation: MultiPluginEditOperation): boolean {\n    // Check if operation requires exclusive document access\n    return operation.priority === OperationPriority.CRITICAL ||\n           operation.metadata.tags?.includes('exclusive_access') ||\n           operation.changes.some(change => change.type === 'replace' && (change.to - change.from) > 1000);\n  }\n\n  private async checkPriorityInterference(op1: MultiPluginEditOperation, op2: MultiPluginEditOperation): Promise<boolean> {\n    // Check if the lower priority operation might interfere with the higher priority one\n    const lowerPriorityOp = op1.priority > op2.priority ? op1 : op2;\n    const higherPriorityOp = op1.priority < op2.priority ? op1 : op2;\n    \n    // Look for overlapping changes or dependency relationships\n    for (const lowPriorityChange of lowerPriorityOp.changes) {\n      for (const highPriorityChange of higherPriorityOp.changes) {\n        const overlap = this.calculateRangeOverlap(\n          {start: lowPriorityChange.from, end: lowPriorityChange.to},\n          {start: highPriorityChange.from, end: highPriorityChange.to}\n        );\n        \n        if (overlap && overlap.size > 0) {\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  private findRegionConflicts(operations: MultiPluginEditOperation[]): ChangeConflict[] {\n    // Implementation for finding region-based conflicts among multiple operations\n    // This would identify when 3+ operations all target the same document region\n    return [];\n  }\n\n  private findComplexDependencyConflicts(operations: MultiPluginEditOperation[]): ChangeConflict[] {\n    // Implementation for finding complex dependency chains that create conflicts\n    // This would identify circular dependencies or impossible ordering requirements\n    return [];\n  }\n\n  private shouldBeUserVisible(severity: ConflictSeverity, op1: MultiPluginEditOperation, op2: MultiPluginEditOperation): boolean {\n    // Determine if conflict should be shown to user based on severity and operation metadata\n    return severity >= ConflictSeverity.MEDIUM || \n           op1.metadata.requiresUserReview || \n           op2.metadata.requiresUserReview;\n  }\n\n  private suggestOverlapResolution(overlappingRanges: Array<{start: number, end: number, operations: string[]}>, op1: MultiPluginEditOperation, op2: MultiPluginEditOperation): string {\n    if (op1.priority < op2.priority) {\n      return 'Process higher priority operation first, then apply non-conflicting changes from lower priority operation';\n    } else if (op1.capabilities.canMergeWith.includes(op2.pluginId)) {\n      return 'Attempt intelligent merge of overlapping changes';\n    } else {\n      return 'Sequential processing required - process operations one at a time';\n    }\n  }\n\n  private suggestSemanticResolution(semanticConflicts: Array<{intention1: string, intention2: string, compatibility: number}>, op1: MultiPluginEditOperation, op2: MultiPluginEditOperation): string {\n    const avgCompatibility = semanticConflicts.reduce((sum, conf) => sum + conf.compatibility, 0) / semanticConflicts.length;\n    \n    if (avgCompatibility < 0.1) {\n      return 'Semantic intentions are incompatible - user intervention required';\n    } else if (avgCompatibility < 0.3) {\n      return 'Attempt semantic merge with user review';\n    } else {\n      return 'Semantic merge may be possible with careful ordering';\n    }\n  }\n\n  private getSeverityWeight(severity: ConflictSeverity): number {\n    const weights = {\n      [ConflictSeverity.CRITICAL]: 5,\n      [ConflictSeverity.HIGH]: 4,\n      [ConflictSeverity.MEDIUM]: 3,\n      [ConflictSeverity.LOW]: 2,\n      [ConflictSeverity.INFO]: 1\n    };\n    return weights[severity];\n  }\n}", "/**\n * Change Merging Algorithms\n * \n * Sophisticated algorithms for merging compatible simultaneous edits:\n * - Compatible change merging for non-overlapping edits\n * - Intelligent text merge for overlapping changes when possible\n * - Change ordering based on operation types and plugin priorities\n * - Fallback strategies when automatic merging is not possible\n */\n\nimport { \n  EditChange, \n  MultiPluginEditOperation, \n  MergedChange,\n  ConflictResolutionResult,\n  OperationPriority,\n  SemanticContext \n} from './change-consolidation-manager';\n\nexport interface MergeConfig {\n  maxOverlapTolerance: number; // Maximum character overlap allowed for merging\n  preserveFormatting: boolean;\n  enableSemanticMerging: boolean;\n  priorityWeighting: number; // How much priority affects merge decisions (0-1)\n  confidenceThreshold: number; // Minimum confidence for automatic merge (0-1)\n}\n\nexport interface MergeStrategy {\n  name: string;\n  description: string;\n  applicableFor: (op1: MultiPluginEditOperation, op2: MultiPluginEditOperation) => boolean;\n  merge: (op1: MultiPluginEditOperation, op2: MultiPluginEditOperation, config: MergeConfig) => Promise<MergeResult>;\n}\n\nexport interface MergeResult {\n  success: boolean;\n  confidence: number; // 0-1 confidence in merge quality\n  mergedChanges: EditChange[];\n  preservedSemantics: boolean;\n  warnings: string[];\n  errors: string[];\n  fallbackRequired?: boolean;\n  userReviewRequired?: boolean;\n}\n\nexport interface ChangeOrderingResult {\n  orderedChanges: EditChange[];\n  orderingStrategy: string;\n  dependencies: Array<{changeId: string, dependsOn: string[]}>;\n  warnings: string[];\n}\n\n/**\n * Advanced Change Merging Engine\n */\nexport class ChangeMergingEngine {\n  private config: MergeConfig;\n  private mergeStrategies: Map<string, MergeStrategy>;\n  private textAnalyzer: TextAnalyzer;\n\n  constructor(config: Partial<MergeConfig> = {}) {\n    this.config = {\n      maxOverlapTolerance: 5,\n      preserveFormatting: true,\n      enableSemanticMerging: true,\n      priorityWeighting: 0.7,\n      confidenceThreshold: 0.6,\n      ...config\n    };\n\n    this.textAnalyzer = new TextAnalyzer();\n    this.initializeMergeStrategies();\n  }\n\n  /**\n   * Merge multiple operations into a consolidated set of changes\n   */\n  async mergeOperations(operations: MultiPluginEditOperation[]): Promise<ConflictResolutionResult> {\n    if (operations.length === 0) {\n      return {\n        success: true,\n        finalChanges: [],\n        warnings: [],\n        errors: [],\n        requiresUserReview: false\n      };\n    }\n\n    if (operations.length === 1) {\n      return {\n        success: true,\n        finalChanges: operations[0].changes,\n        warnings: [],\n        errors: [],\n        requiresUserReview: operations[0].metadata.requiresUserReview\n      };\n    }\n\n    try {\n      // Sort operations by priority and compatibility\n      const sortedOperations = this.sortOperationsByMergePriority(operations);\n      \n      // Group operations that can be merged together\n      const mergeGroups = await this.groupCompatibleOperations(sortedOperations);\n      \n      let allMergedChanges: EditChange[] = [];\n      const warnings: string[] = [];\n      const errors: string[] = [];\n      let overallConfidence = 1.0;\n      let requiresUserReview = false;\n\n      // Process each merge group\n      for (const group of mergeGroups) {\n        const mergeResult = await this.mergeOperationGroup(group);\n        \n        if (mergeResult.success) {\n          allMergedChanges.push(...mergeResult.mergedChanges);\n          warnings.push(...mergeResult.warnings);\n          overallConfidence = Math.min(overallConfidence, mergeResult.confidence);\n          \n          if (mergeResult.userReviewRequired) {\n            requiresUserReview = true;\n          }\n        } else {\n          errors.push(...mergeResult.errors);\n          // Add original changes if merge fails\n          for (const op of group) {\n            allMergedChanges.push(...op.changes);\n          }\n          requiresUserReview = true;\n        }\n      }\n\n      // Order the final changes for application\n      const orderedResult = await this.orderChangesForApplication(allMergedChanges);\n      \n      return {\n        success: errors.length === 0,\n        finalChanges: orderedResult.orderedChanges,\n        warnings: [...warnings, ...orderedResult.warnings],\n        errors,\n        requiresUserReview: requiresUserReview || overallConfidence < this.config.confidenceThreshold\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        finalChanges: operations.flatMap(op => op.changes),\n        warnings: [],\n        errors: [`Merge operation failed: ${error.message}`],\n        requiresUserReview: true\n      };\n    }\n  }\n\n  /**\n   * Sort operations by merge priority\n   */\n  private sortOperationsByMergePriority(operations: MultiPluginEditOperation[]): MultiPluginEditOperation[] {\n    return [...operations].sort((a, b) => {\n      // Primary sort: priority (lower number = higher priority)\n      if (a.priority !== b.priority) {\n        return a.priority - b.priority;\n      }\n      \n      // Secondary sort: timestamp (earlier first)\n      if (a.timestamp !== b.timestamp) {\n        return a.timestamp - b.timestamp;\n      }\n      \n      // Tertiary sort: user-initiated operations first\n      if (a.metadata.userInitiated !== b.metadata.userInitiated) {\n        return a.metadata.userInitiated ? -1 : 1;\n      }\n      \n      return 0;\n    });\n  }\n\n  /**\n   * Group compatible operations that can be merged together\n   */\n  private async groupCompatibleOperations(operations: MultiPluginEditOperation[]): Promise<MultiPluginEditOperation[][]> {\n    const groups: MultiPluginEditOperation[][] = [];\n    const processed = new Set<string>();\n\n    for (const operation of operations) {\n      if (processed.has(operation.id)) continue;\n\n      const compatibleGroup = [operation];\n      processed.add(operation.id);\n\n      // Find other operations that can be merged with this one\n      for (const otherOp of operations) {\n        if (processed.has(otherOp.id)) continue;\n\n        const canMerge = await this.canOperationsBeMerged(operation, otherOp);\n        if (canMerge) {\n          compatibleGroup.push(otherOp);\n          processed.add(otherOp.id);\n        }\n      }\n\n      groups.push(compatibleGroup);\n    }\n\n    return groups;\n  }\n\n  /**\n   * Check if two operations can be merged\n   */\n  private async canOperationsBeMerged(op1: MultiPluginEditOperation, op2: MultiPluginEditOperation): Promise<boolean> {\n    // Check plugin compatibility\n    if (!op1.capabilities.canMergeWith.includes(op2.pluginId) ||\n        !op2.capabilities.canMergeWith.includes(op1.pluginId)) {\n      return false;\n    }\n\n    // Check priority difference\n    const priorityDiff = Math.abs(op1.priority - op2.priority);\n    if (priorityDiff > 2) { // Don't merge operations with very different priorities\n      return false;\n    }\n\n    // Check for overlapping changes\n    const hasOverlap = this.hasSignificantOverlap(op1.changes, op2.changes);\n    if (hasOverlap) {\n      // Can only merge overlapping changes if both support it\n      return op1.capabilities.conflictResolution.includes('AUTO_MERGE' as any) &&\n             op2.capabilities.conflictResolution.includes('AUTO_MERGE' as any);\n    }\n\n    return true;\n  }\n\n  /**\n   * Merge a group of compatible operations\n   */\n  private async mergeOperationGroup(operations: MultiPluginEditOperation[]): Promise<MergeResult> {\n    if (operations.length === 1) {\n      return {\n        success: true,\n        confidence: 1.0,\n        mergedChanges: operations[0].changes,\n        preservedSemantics: true,\n        warnings: [],\n        errors: []\n      };\n    }\n\n    // Find the best merge strategy for this group\n    const strategy = this.selectBestMergeStrategy(operations);\n    \n    if (!strategy) {\n      return {\n        success: false,\n        confidence: 0.0,\n        mergedChanges: [],\n        preservedSemantics: false,\n        warnings: [],\n        errors: ['No suitable merge strategy found'],\n        fallbackRequired: true\n      };\n    }\n\n    // Apply the merge strategy\n    let mergeResult: MergeResult;\n    \n    if (operations.length === 2) {\n      mergeResult = await strategy.merge(operations[0], operations[1], this.config);\n    } else {\n      // For multiple operations, merge iteratively\n      mergeResult = await this.mergeMultipleOperations(operations, strategy);\n    }\n\n    return mergeResult;\n  }\n\n  /**\n   * Merge multiple operations using a specific strategy\n   */\n  private async mergeMultipleOperations(operations: MultiPluginEditOperation[], strategy: MergeStrategy): Promise<MergeResult> {\n    let currentResult: MergeResult = {\n      success: true,\n      confidence: 1.0,\n      mergedChanges: operations[0].changes,\n      preservedSemantics: true,\n      warnings: [],\n      errors: []\n    };\n\n    // Merge operations iteratively\n    for (let i = 1; i < operations.length; i++) {\n      if (!currentResult.success) break;\n\n      // Create a temporary operation with current merged changes\n      const tempOp: MultiPluginEditOperation = {\n        ...operations[0],\n        id: `merged_${operations[0].id}_${i}`,\n        changes: currentResult.mergedChanges\n      };\n\n      const nextResult = await strategy.merge(tempOp, operations[i], this.config);\n      \n      if (nextResult.success) {\n        currentResult.mergedChanges = nextResult.mergedChanges;\n        currentResult.confidence = Math.min(currentResult.confidence, nextResult.confidence);\n        currentResult.preservedSemantics = currentResult.preservedSemantics && nextResult.preservedSemantics;\n        currentResult.warnings.push(...nextResult.warnings);\n      } else {\n        currentResult.success = false;\n        currentResult.errors.push(...nextResult.errors);\n        currentResult.fallbackRequired = true;\n        break;\n      }\n    }\n\n    return currentResult;\n  }\n\n  /**\n   * Select the best merge strategy for a group of operations\n   */\n  private selectBestMergeStrategy(operations: MultiPluginEditOperation[]): MergeStrategy | null {\n    for (const [name, strategy] of this.mergeStrategies) {\n      // Check if strategy is applicable for all pairs in the group\n      let applicable = true;\n      \n      for (let i = 0; i < operations.length && applicable; i++) {\n        for (let j = i + 1; j < operations.length && applicable; j++) {\n          if (!strategy.applicableFor(operations[i], operations[j])) {\n            applicable = false;\n          }\n        }\n      }\n      \n      if (applicable) {\n        return strategy;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Order changes for safe application to document\n   */\n  private async orderChangesForApplication(changes: EditChange[]): Promise<ChangeOrderingResult> {\n    // Sort changes by position (reverse order for safe application)\n    const orderedChanges = [...changes].sort((a, b) => {\n      // Apply changes from end to beginning to avoid position shifts\n      if (a.from !== b.from) {\n        return b.from - a.from;\n      }\n      \n      // If same position, apply deletes before inserts\n      if (a.type !== b.type) {\n        if (a.type === 'delete' && b.type === 'insert') return -1;\n        if (a.type === 'insert' && b.type === 'delete') return 1;\n      }\n      \n      return 0;\n    });\n\n    // Build dependency information\n    const dependencies: Array<{changeId: string, dependsOn: string[]}> = [];\n    \n    for (const change of orderedChanges) {\n      if (change.id && change.dependsOn) {\n        dependencies.push({\n          changeId: change.id,\n          dependsOn: change.dependsOn\n        });\n      }\n    }\n\n    // Validate ordering doesn't violate dependencies\n    const warnings: string[] = [];\n    const dependencyWarnings = this.validateDependencyOrdering(orderedChanges, dependencies);\n    warnings.push(...dependencyWarnings);\n\n    return {\n      orderedChanges,\n      orderingStrategy: 'position_based_reverse',\n      dependencies,\n      warnings\n    };\n  }\n\n  /**\n   * Initialize merge strategies\n   */\n  private initializeMergeStrategies(): void {\n    this.mergeStrategies = new Map();\n\n    // Non-overlapping merge strategy\n    this.mergeStrategies.set('non_overlapping', {\n      name: 'non_overlapping',\n      description: 'Merge non-overlapping changes directly',\n      applicableFor: (op1, op2) => !this.hasSignificantOverlap(op1.changes, op2.changes),\n      merge: async (op1, op2, config) => this.mergeNonOverlappingChanges(op1, op2, config)\n    });\n\n    // Priority-based merge strategy\n    this.mergeStrategies.set('priority_based', {\n      name: 'priority_based',\n      description: 'Merge based on operation priority',\n      applicableFor: (op1, op2) => op1.priority !== op2.priority,\n      merge: async (op1, op2, config) => this.mergePriorityBased(op1, op2, config)\n    });\n\n    // Semantic merge strategy\n    this.mergeStrategies.set('semantic', {\n      name: 'semantic',\n      description: 'Merge based on semantic compatibility',\n      applicableFor: (op1, op2) => {\n        return config.enableSemanticMerging && \n               op1.changes.some(c => c.semanticContext) && \n               op2.changes.some(c => c.semanticContext);\n      },\n      merge: async (op1, op2, config) => this.mergeSemanticChanges(op1, op2, config)\n    });\n\n    // Text-based merge strategy\n    this.mergeStrategies.set('text_based', {\n      name: 'text_based',\n      description: 'Merge overlapping text changes intelligently',\n      applicableFor: (op1, op2) => {\n        const overlap = this.hasSignificantOverlap(op1.changes, op2.changes);\n        return overlap && this.canTextBeMerged(op1.changes, op2.changes);\n      },\n      merge: async (op1, op2, config) => this.mergeTextChanges(op1, op2, config)\n    });\n  }\n\n  // Merge strategy implementations\n\n  private async mergeNonOverlappingChanges(op1: MultiPluginEditOperation, op2: MultiPluginEditOperation, config: MergeConfig): Promise<MergeResult> {\n    const mergedChanges = [...op1.changes, ...op2.changes];\n    \n    return {\n      success: true,\n      confidence: 0.9,\n      mergedChanges,\n      preservedSemantics: true,\n      warnings: [],\n      errors: []\n    };\n  }\n\n  private async mergePriorityBased(op1: MultiPluginEditOperation, op2: MultiPluginEditOperation, config: MergeConfig): Promise<MergeResult> {\n    const higherPriorityOp = op1.priority <= op2.priority ? op1 : op2;\n    const lowerPriorityOp = op1.priority <= op2.priority ? op2 : op1;\n    \n    // Take all changes from higher priority operation\n    const mergedChanges = [...higherPriorityOp.changes];\n    \n    // Add non-conflicting changes from lower priority operation\n    for (const change of lowerPriorityOp.changes) {\n      const hasConflict = higherPriorityOp.changes.some(priorityChange => \n        this.changesOverlap(change, priorityChange));\n      \n      if (!hasConflict) {\n        mergedChanges.push(change);\n      }\n    }\n\n    return {\n      success: true,\n      confidence: 0.8,\n      mergedChanges,\n      preservedSemantics: true,\n      warnings: [`Lower priority changes that conflict with higher priority ones were discarded`],\n      errors: []\n    };\n  }\n\n  private async mergeSemanticChanges(op1: MultiPluginEditOperation, op2: MultiPluginEditOperation, config: MergeConfig): Promise<MergeResult> {\n    // Analyze semantic compatibility\n    const compatibility = await this.analyzeSemanticCompatibility(op1.changes, op2.changes);\n    \n    if (compatibility < 0.3) {\n      return {\n        success: false,\n        confidence: 0.0,\n        mergedChanges: [],\n        preservedSemantics: false,\n        warnings: [],\n        errors: ['Semantic intentions are incompatible'],\n        userReviewRequired: true\n      };\n    }\n\n    // Merge semantically compatible changes\n    const mergedChanges = await this.performSemanticMerge(op1.changes, op2.changes);\n    \n    return {\n      success: true,\n      confidence: compatibility,\n      mergedChanges,\n      preservedSemantics: true,\n      warnings: compatibility < 0.6 ? ['Semantic merge has moderate confidence'] : [],\n      errors: []\n    };\n  }\n\n  private async mergeTextChanges(op1: MultiPluginEditOperation, op2: MultiPluginEditOperation, config: MergeConfig): Promise<MergeResult> {\n    try {\n      const mergedChanges = await this.textAnalyzer.mergeOverlappingChanges(op1.changes, op2.changes, config);\n      \n      return {\n        success: true,\n        confidence: 0.7,\n        mergedChanges,\n        preservedSemantics: true,\n        warnings: ['Text merge applied - please review for accuracy'],\n        errors: [],\n        userReviewRequired: true\n      };\n    } catch (error) {\n      return {\n        success: false,\n        confidence: 0.0,\n        mergedChanges: [],\n        preservedSemantics: false,\n        warnings: [],\n        errors: [`Text merge failed: ${error.message}`],\n        fallbackRequired: true\n      };\n    }\n  }\n\n  // Utility methods\n\n  private hasSignificantOverlap(changes1: EditChange[], changes2: EditChange[]): boolean {\n    for (const change1 of changes1) {\n      for (const change2 of changes2) {\n        if (this.changesOverlap(change1, change2)) {\n          const overlapSize = Math.min(change1.to, change2.to) - Math.max(change1.from, change2.from);\n          if (overlapSize > this.config.maxOverlapTolerance) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  private changesOverlap(change1: EditChange, change2: EditChange): boolean {\n    return change1.from < change2.to && change2.from < change1.to;\n  }\n\n  private canTextBeMerged(changes1: EditChange[], changes2: EditChange[]): boolean {\n    // Check if overlapping changes can potentially be merged\n    return changes1.some(c1 => \n      changes2.some(c2 => \n        this.changesOverlap(c1, c2) && \n        c1.type === c2.type && \n        c1.type !== 'delete'\n      )\n    );\n  }\n\n  private async analyzeSemanticCompatibility(changes1: EditChange[], changes2: EditChange[]): Promise<number> {\n    // Simplified semantic compatibility analysis\n    let totalCompatibility = 0;\n    let comparisons = 0;\n\n    for (const change1 of changes1) {\n      for (const change2 of changes2) {\n        if (change1.semanticContext && change2.semanticContext) {\n          const compatibility = this.calculateSemanticSimilarity(\n            change1.semanticContext,\n            change2.semanticContext\n          );\n          totalCompatibility += compatibility;\n          comparisons++;\n        }\n      }\n    }\n\n    return comparisons > 0 ? totalCompatibility / comparisons : 0.5;\n  }\n\n  private calculateSemanticSimilarity(context1: SemanticContext, context2: SemanticContext): number {\n    // Simple compatibility matrix\n    const intentionCompatibility = {\n      correction: { correction: 0.9, enhancement: 0.6, formatting: 0.7, content_addition: 0.3, restructuring: 0.2 },\n      enhancement: { correction: 0.6, enhancement: 0.9, formatting: 0.8, content_addition: 0.7, restructuring: 0.4 },\n      formatting: { correction: 0.7, enhancement: 0.8, formatting: 0.9, content_addition: 0.5, restructuring: 0.3 },\n      content_addition: { correction: 0.3, enhancement: 0.7, formatting: 0.5, content_addition: 0.8, restructuring: 0.6 },\n      restructuring: { correction: 0.2, enhancement: 0.4, formatting: 0.3, content_addition: 0.6, restructuring: 0.9 }\n    };\n\n    return intentionCompatibility[context1.intention]?.[context2.intention] ?? 0.5;\n  }\n\n  private async performSemanticMerge(changes1: EditChange[], changes2: EditChange[]): Promise<EditChange[]> {\n    // Simplified semantic merge - in practice would be more sophisticated\n    const merged: EditChange[] = [];\n    const processed = new Set<number>();\n\n    // Process changes1 first\n    for (let i = 0; i < changes1.length; i++) {\n      if (processed.has(i)) continue;\n      \n      const change1 = changes1[i];\n      let bestMatch: EditChange | null = null;\n      let bestCompatibility = 0;\n\n      // Find best matching change in changes2\n      for (const change2 of changes2) {\n        if (this.changesOverlap(change1, change2) && \n            change1.semanticContext && change2.semanticContext) {\n          const compatibility = this.calculateSemanticSimilarity(\n            change1.semanticContext,\n            change2.semanticContext\n          );\n          \n          if (compatibility > bestCompatibility && compatibility > 0.6) {\n            bestMatch = change2;\n            bestCompatibility = compatibility;\n          }\n        }\n      }\n\n      if (bestMatch) {\n        // Merge the two changes\n        const mergedChange = await this.createSemanticMergedChange(change1, bestMatch);\n        merged.push(mergedChange);\n        processed.add(i);\n      } else {\n        merged.push(change1);\n        processed.add(i);\n      }\n    }\n\n    // Add remaining changes from changes2\n    for (const change2 of changes2) {\n      const wasProcessed = merged.some(mc => \n        mc.operationId?.includes(change2.id || '') || \n        this.changesOverlap(mc, change2)\n      );\n      \n      if (!wasProcessed) {\n        merged.push(change2);\n      }\n    }\n\n    return merged;\n  }\n\n  private async createSemanticMergedChange(change1: EditChange, change2: EditChange): Promise<EditChange> {\n    // Create a new change that combines the intentions of both changes\n    return {\n      ...change1,\n      id: `semantic_merge_${change1.id}_${change2.id}`,\n      timestamp: Math.max(change1.timestamp, change2.timestamp),\n      from: Math.min(change1.from, change2.from),\n      to: Math.max(change1.to, change2.to),\n      text: this.mergeChangeTexts(change1, change2),\n      operationId: `merged_${change1.operationId}_${change2.operationId}`,\n      semanticContext: this.mergeSemanticContexts(change1.semanticContext!, change2.semanticContext!)\n    };\n  }\n\n  private mergeChangeTexts(change1: EditChange, change2: EditChange): string {\n    // Simplified text merging - in practice would be more sophisticated\n    if (change1.type === 'insert' && change2.type === 'insert') {\n      return (change1.text || '') + (change2.text || '');\n    }\n    \n    // For other types, prefer the change with higher confidence\n    const confidence1 = change1.semanticContext?.confidence ?? 0.5;\n    const confidence2 = change2.semanticContext?.confidence ?? 0.5;\n    \n    return confidence1 >= confidence2 ? (change1.text || '') : (change2.text || '');\n  }\n\n  private mergeSemanticContexts(context1: SemanticContext, context2: SemanticContext): SemanticContext {\n    return {\n      intention: context1.confidence >= context2.confidence ? context1.intention : context2.intention,\n      scope: context1.scope === context2.scope ? context1.scope : 'paragraph', // Default to paragraph\n      confidence: Math.min(context1.confidence, context2.confidence) * 0.9, // Reduce confidence for merged result\n      preserveFormatting: context1.preserveFormatting && context2.preserveFormatting,\n      preserveContent: context1.preserveContent && context2.preserveContent\n    };\n  }\n\n  private validateDependencyOrdering(changes: EditChange[], dependencies: Array<{changeId: string, dependsOn: string[]}>): string[] {\n    const warnings: string[] = [];\n    const changePositions = new Map<string, number>();\n    \n    changes.forEach((change, index) => {\n      if (change.id) {\n        changePositions.set(change.id, index);\n      }\n    });\n\n    for (const dependency of dependencies) {\n      const changePos = changePositions.get(dependency.changeId);\n      if (changePos === undefined) continue;\n\n      for (const depId of dependency.dependsOn) {\n        const depPos = changePositions.get(depId);\n        if (depPos !== undefined && depPos > changePos) {\n          warnings.push(`Dependency violation: ${dependency.changeId} depends on ${depId} but is ordered before it`);\n        }\n      }\n    }\n\n    return warnings;\n  }\n}\n\n/**\n * Text Analysis Helper for advanced text merging\n */\nclass TextAnalyzer {\n  async mergeOverlappingChanges(changes1: EditChange[], changes2: EditChange[], config: MergeConfig): Promise<EditChange[]> {\n    const merged: EditChange[] = [];\n    \n    // Simple implementation - could be made much more sophisticated\n    for (const change1 of changes1) {\n      let matchFound = false;\n      \n      for (const change2 of changes2) {\n        if (this.changesOverlap(change1, change2)) {\n          const mergedChange = await this.mergeOverlappingPair(change1, change2);\n          if (mergedChange) {\n            merged.push(mergedChange);\n            matchFound = true;\n            break;\n          }\n        }\n      }\n      \n      if (!matchFound) {\n        merged.push(change1);\n      }\n    }\n\n    // Add non-overlapping changes from changes2\n    for (const change2 of changes2) {\n      const hasOverlap = changes1.some(c1 => this.changesOverlap(c1, change2));\n      if (!hasOverlap) {\n        merged.push(change2);\n      }\n    }\n\n    return merged;\n  }\n\n  private async mergeOverlappingPair(change1: EditChange, change2: EditChange): Promise<EditChange | null> {\n    if (change1.type === 'insert' && change2.type === 'insert') {\n      // Merge two insertions at similar positions\n      return {\n        ...change1,\n        id: `text_merge_${change1.id}_${change2.id}`,\n        from: Math.min(change1.from, change2.from),\n        to: Math.max(change1.to, change2.to),\n        text: this.intelligentTextMerge(change1.text || '', change2.text || ''),\n        timestamp: Math.max(change1.timestamp, change2.timestamp)\n      };\n    }\n    \n    // For other overlap types, more complex logic would be needed\n    return null;\n  }\n\n  private intelligentTextMerge(text1: string, text2: string): string {\n    // Very simplified - in practice would use diff algorithms and NLP\n    if (text1.includes(text2)) return text1;\n    if (text2.includes(text1)) return text2;\n    \n    // Try to merge if they seem compatible\n    if (this.textsAreCompatible(text1, text2)) {\n      return text1 + ' ' + text2;\n    }\n    \n    return text1; // Default to first text\n  }\n\n  private textsAreCompatible(text1: string, text2: string): boolean {\n    // Simple heuristic - could be much more sophisticated\n    return text1.length < 100 && text2.length < 100 && \n           !text1.includes('.') && !text2.includes('.');\n  }\n\n  private changesOverlap(change1: EditChange, change2: EditChange): boolean {\n    return change1.from < change2.to && change2.from < change1.to;\n  }\n}", "/**\n * Multi-Plugin Change Consolidation System\n * \n * Handles simultaneous edits from multiple Writerr Platform plugins with:\n * - Document-level locking and coordination\n * - Change conflict detection and resolution\n * - Intelligent merging of compatible changes\n * - Priority-based conflict resolution\n * - Real-time consolidation during concurrent operations\n */\n\nimport { EventEmitter } from 'events';\nimport { TFile } from 'obsidian';\nimport { ConsolidationPerformanceMonitor, ConsolidationErrorManager } from './performance-optimization';\n\n// Core interfaces for multi-plugin change consolidation\nexport interface MultiPluginEditOperation {\n  id: string;\n  pluginId: string;\n  pluginVersion: string;\n  sessionId?: string;\n  documentPath: string;\n  changes: EditChange[];\n  timestamp: number;\n  priority: OperationPriority;\n  capabilities: PluginCapabilities;\n  metadata: OperationMetadata;\n}\n\nexport interface EditChange {\n  id?: string;\n  timestamp: number;\n  type: 'insert' | 'delete' | 'replace';\n  from: number;\n  to: number;\n  text?: string;\n  removedText?: string;\n  author?: string;\n  aiProvider?: string;\n  aiModel?: string;\n  processingContext?: any;\n  aiTimestamp?: Date;\n  // Multi-plugin specific fields\n  pluginId?: string;\n  operationId?: string;\n  dependsOn?: string[]; // IDs of changes this depends on\n  semanticContext?: SemanticContext;\n}\n\nexport interface SemanticContext {\n  intention: 'correction' | 'enhancement' | 'formatting' | 'content_addition' | 'restructuring';\n  scope: 'word' | 'sentence' | 'paragraph' | 'section' | 'document';\n  confidence: number; // 0-1\n  preserveFormatting?: boolean;\n  preserveContent?: boolean;\n}\n\nexport enum OperationPriority {\n  CRITICAL = 1,      // Editorial Engine constraint fixes\n  HIGH = 2,          // Track Edits user-initiated changes\n  MEDIUM = 3,        // Writerr Chat suggestions\n  LOW = 4,           // Background optimizations\n  BACKGROUND = 5     // Auto-formatting\n}\n\nexport interface PluginCapabilities {\n  canMergeWith: string[]; // Plugin IDs this can merge changes with\n  conflictResolution: ConflictResolutionCapability[];\n  maxConcurrentOperations: number;\n  supportsRealTimeConsolidation: boolean;\n  supportedChangeTypes: EditChange['type'][];\n}\n\nexport enum ConflictResolutionCapability {\n  AUTO_MERGE = 'auto_merge',\n  PRIORITY_OVERRIDE = 'priority_override',\n  USER_CHOICE = 'user_choice',\n  SEMANTIC_ANALYSIS = 'semantic_analysis',\n  DEFER_TO_HIGHEST_PRIORITY = 'defer_to_highest_priority'\n}\n\nexport interface OperationMetadata {\n  userInitiated: boolean;\n  batchId?: string;\n  estimatedProcessingTime: number;\n  requiresUserReview: boolean;\n  canBeDeferred: boolean;\n  tags?: string[];\n}\n\n// Document locking system\nexport interface DocumentLock {\n  documentPath: string;\n  lockId: string;\n  operationId: string;\n  pluginId: string;\n  timestamp: number;\n  lockType: 'exclusive' | 'shared' | 'coordination';\n  expiresAt: number;\n  metadata: {\n    reason: string;\n    estimatedDuration: number;\n    canBePreempted: boolean;\n  };\n}\n\n// Change conflict detection\nexport interface ChangeConflict {\n  id: string;\n  type: ConflictType;\n  severity: ConflictSeverity;\n  operations: MultiPluginEditOperation[];\n  conflictingChanges: EditChange[];\n  detectedAt: number;\n  resolution?: ConflictResolution;\n  userVisible: boolean;\n}\n\nexport enum ConflictType {\n  OVERLAPPING_EDITS = 'overlapping_edits',\n  SEMANTIC_CONFLICT = 'semantic_conflict',\n  DEPENDENCY_VIOLATION = 'dependency_violation',\n  RESOURCE_CONTENTION = 'resource_contention',\n  PRIORITY_CONFLICT = 'priority_conflict'\n}\n\nexport enum ConflictSeverity {\n  CRITICAL = 'critical',     // Will corrupt document\n  HIGH = 'high',            // Will cause data loss\n  MEDIUM = 'medium',        // May cause unexpected results  \n  LOW = 'low',              // Cosmetic issues only\n  INFO = 'info'             // No actual conflict, just notification\n}\n\nexport interface ConflictResolution {\n  strategy: ConflictResolutionStrategy;\n  result: ConflictResolutionResult;\n  timestamp: number;\n  appliedBy: 'system' | 'user' | 'plugin';\n  metadata: {\n    originalChanges: EditChange[];\n    mergedChanges?: EditChange[];\n    rejectedChanges?: EditChange[];\n    userChoices?: any;\n  };\n}\n\nexport enum ConflictResolutionStrategy {\n  MERGE_COMPATIBLE = 'merge_compatible',\n  PRIORITY_WINS = 'priority_wins',\n  USER_CHOICE = 'user_choice',\n  DEFER_OPERATION = 'defer_operation',\n  SEQUENTIAL_PROCESSING = 'sequential_processing',\n  SEMANTIC_MERGE = 'semantic_merge'\n}\n\nexport interface ConflictResolutionResult {\n  success: boolean;\n  finalChanges: EditChange[];\n  warnings: string[];\n  errors: string[];\n  requiresUserReview: boolean;\n}\n\n// Change merging interfaces\nexport interface ChangeRange {\n  start: number;\n  end: number;\n  operation: EditChange;\n}\n\nexport interface MergedChange {\n  id: string;\n  sourceOperations: string[]; // Operation IDs that contributed\n  finalChange: EditChange;\n  confidence: number;\n  mergeStrategy: string;\n  preservedSemantics: boolean;\n}\n\n// Consolidation events\nexport interface ConsolidationEvent {\n  type: ConsolidationEventType;\n  timestamp: number;\n  documentPath: string;\n  data: any;\n}\n\nexport enum ConsolidationEventType {\n  OPERATION_QUEUED = 'operation_queued',\n  CONFLICT_DETECTED = 'conflict_detected',\n  CONFLICT_RESOLVED = 'conflict_resolved',\n  CHANGES_MERGED = 'changes_merged',\n  DOCUMENT_LOCKED = 'document_locked',\n  DOCUMENT_UNLOCKED = 'document_unlocked',\n  CONSOLIDATION_COMPLETE = 'consolidation_complete',\n  CONSOLIDATION_FAILED = 'consolidation_failed'\n}\n\n/**\n * Core Change Consolidation Manager\n * \n * Manages the coordination of simultaneous changes from multiple plugins\n */\nexport class ChangeConsolidationManager extends EventEmitter {\n  private documentLocks = new Map<string, DocumentLock>();\n  private operationQueue = new Map<string, MultiPluginEditOperation[]>();\n  private activeConflicts = new Map<string, ChangeConflict>();\n  private consolidationHistory = new Map<string, ConsolidationEvent[]>();\n  private lockTimeouts = new Map<string, NodeJS.Timeout>();\n\n  // Performance tracking and optimization\n  private performanceMonitor: ConsolidationPerformanceMonitor;\n  private errorManager: ConsolidationErrorManager;\n\n  constructor() {\n    super();\n    \n    // Initialize performance monitoring and error handling\n    this.initializePerformanceOptimization();\n    this.setupCleanupInterval();\n  }\n\n  private async initializePerformanceOptimization() {\n    const { ConsolidationPerformanceMonitor, ConsolidationErrorManager } = await import('./performance-optimization');\n    \n    this.performanceMonitor = new ConsolidationPerformanceMonitor({\n      maxConcurrentOperations: 5,\n      batchProcessingSize: 20,\n      enableResultCaching: true,\n      useAsyncProcessing: true,\n      optimizeForLargeDocuments: true,\n      maxMemoryUsage: 256, // 256 MB limit\n      maxProcessingTime: 15000 // 15 second timeout\n    });\n\n    this.errorManager = new ConsolidationErrorManager();\n  }\n\n  /**\n   * Submit a multi-plugin operation for consolidation\n   */\n  async submitOperation(operation: MultiPluginEditOperation): Promise<{\n    success: boolean;\n    operationId: string;\n    requiresConsolidation: boolean;\n    estimatedWaitTime?: number;\n    warnings?: string[];\n    errors?: string[];\n  }> {\n    const startTime = performance.now();\n    this.performanceMetrics.totalOperations++;\n\n    try {\n      // Check if document needs coordination\n      const needsCoordination = await this.checkCoordinationRequired(operation);\n      \n      if (!needsCoordination) {\n        // No other operations affecting this document - proceed directly\n        return {\n          success: true,\n          operationId: operation.id,\n          requiresConsolidation: false\n        };\n      }\n\n      // Add to operation queue for the document\n      const documentQueue = this.operationQueue.get(operation.documentPath) || [];\n      documentQueue.push(operation);\n      this.operationQueue.set(operation.documentPath, documentQueue);\n\n      this.emit('consolidation_event', {\n        type: ConsolidationEventType.OPERATION_QUEUED,\n        timestamp: Date.now(),\n        documentPath: operation.documentPath,\n        data: { operationId: operation.id, queueLength: documentQueue.length }\n      });\n\n      // Process the queue for this document\n      const result = await this.processDocumentQueue(operation.documentPath);\n      \n      const processingTime = performance.now() - startTime;\n      this.updatePerformanceMetrics('consolidation_time', processingTime);\n\n      return result;\n\n    } catch (error) {\n      this.performanceMetrics.failedConsolidations++;\n      console.error('[ChangeConsolidationManager] Error submitting operation:', error);\n      \n      return {\n        success: false,\n        operationId: operation.id,\n        requiresConsolidation: true,\n        errors: [error.message]\n      };\n    }\n  }\n\n  /**\n   * Check if coordination is required for this operation\n   */\n  private async checkCoordinationRequired(operation: MultiPluginEditOperation): Promise<boolean> {\n    // Check if document is currently locked\n    const existingLock = this.documentLocks.get(operation.documentPath);\n    if (existingLock && existingLock.pluginId !== operation.pluginId) {\n      return true;\n    }\n\n    // Check if there are queued operations for this document\n    const queuedOps = this.operationQueue.get(operation.documentPath);\n    if (queuedOps && queuedOps.length > 0) {\n      return true;\n    }\n\n    // Check for recent operations that might still be processing\n    const recentEvents = this.consolidationHistory.get(operation.documentPath) || [];\n    const recentProcessing = recentEvents.find(event => \n      event.timestamp > Date.now() - 5000 && // Within 5 seconds\n      [ConsolidationEventType.OPERATION_QUEUED, ConsolidationEventType.CHANGES_MERGED].includes(event.type)\n    );\n\n    return !!recentProcessing;\n  }\n\n  /**\n   * Process the operation queue for a specific document\n   */\n  private async processDocumentQueue(documentPath: string): Promise<{\n    success: boolean;\n    operationId: string;\n    requiresConsolidation: boolean;\n    estimatedWaitTime?: number;\n    warnings?: string[];\n    errors?: string[];\n  }> {\n    const queue = this.operationQueue.get(documentPath);\n    if (!queue || queue.length === 0) {\n      return {\n        success: true,\n        operationId: '',\n        requiresConsolidation: false\n      };\n    }\n\n    // Sort operations by priority and timestamp\n    const sortedQueue = [...queue].sort((a, b) => {\n      if (a.priority !== b.priority) {\n        return a.priority - b.priority; // Lower number = higher priority\n      }\n      return a.timestamp - b.timestamp; // Earlier timestamp first\n    });\n\n    // Acquire document lock\n    const lockId = await this.acquireDocumentLock(documentPath, sortedQueue[0]);\n    if (!lockId) {\n      return {\n        success: false,\n        operationId: sortedQueue[0].id,\n        requiresConsolidation: true,\n        errors: ['Failed to acquire document lock'],\n        estimatedWaitTime: this.estimateWaitTime(documentPath)\n      };\n    }\n\n    try {\n      // Detect conflicts among queued operations\n      const conflicts = await this.detectConflicts(sortedQueue);\n      \n      if (conflicts.length > 0) {\n        this.performanceMetrics.conflictsDetected += conflicts.length;\n        \n        // Resolve conflicts\n        const resolutions = await this.resolveConflicts(conflicts);\n        const successfulResolutions = resolutions.filter(r => r.result.success);\n        \n        this.performanceMetrics.conflictsResolved += successfulResolutions.length;\n        \n        if (successfulResolutions.length < conflicts.length) {\n          return {\n            success: false,\n            operationId: sortedQueue[0].id,\n            requiresConsolidation: true,\n            errors: ['Failed to resolve all conflicts'],\n            warnings: resolutions.filter(r => !r.result.success).map(r => r.result.errors.join(', '))\n          };\n        }\n      }\n\n      // Merge compatible operations\n      const consolidationResult = await this.consolidateOperations(sortedQueue, documentPath);\n      \n      // Clear the queue for this document\n      this.operationQueue.delete(documentPath);\n      \n      this.emit('consolidation_event', {\n        type: ConsolidationEventType.CONSOLIDATION_COMPLETE,\n        timestamp: Date.now(),\n        documentPath,\n        data: consolidationResult\n      });\n\n      return {\n        success: consolidationResult.success,\n        operationId: sortedQueue[0].id,\n        requiresConsolidation: true,\n        warnings: consolidationResult.warnings,\n        errors: consolidationResult.errors\n      };\n\n    } finally {\n      // Always release the document lock\n      await this.releaseDocumentLock(lockId);\n    }\n  }\n\n  /**\n   * Acquire exclusive lock on a document\n   */\n  private async acquireDocumentLock(\n    documentPath: string, \n    operation: MultiPluginEditOperation\n  ): Promise<string | null> {\n    const lockId = `${operation.pluginId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    // Check if document is already locked\n    const existingLock = this.documentLocks.get(documentPath);\n    if (existingLock) {\n      // Check if lock can be preempted\n      if (!existingLock.metadata.canBePreempted || \n          operation.priority >= this.getOperationPriority(existingLock.operationId)) {\n        return null;\n      }\n      \n      // Preempt existing lock\n      await this.releaseDocumentLock(existingLock.lockId);\n    }\n\n    const lock: DocumentLock = {\n      documentPath,\n      lockId,\n      operationId: operation.id,\n      pluginId: operation.pluginId,\n      timestamp: Date.now(),\n      lockType: 'exclusive',\n      expiresAt: Date.now() + operation.metadata.estimatedProcessingTime + 30000, // Add 30s buffer\n      metadata: {\n        reason: 'multi_plugin_consolidation',\n        estimatedDuration: operation.metadata.estimatedProcessingTime,\n        canBePreempted: operation.priority > OperationPriority.CRITICAL\n      }\n    };\n\n    this.documentLocks.set(documentPath, lock);\n    \n    // Set lock timeout\n    const timeout = setTimeout(() => {\n      this.releaseDocumentLock(lockId);\n    }, lock.expiresAt - Date.now());\n    this.lockTimeouts.set(lockId, timeout);\n\n    this.emit('consolidation_event', {\n      type: ConsolidationEventType.DOCUMENT_LOCKED,\n      timestamp: Date.now(),\n      documentPath,\n      data: { lockId, pluginId: operation.pluginId }\n    });\n\n    return lockId;\n  }\n\n  /**\n   * Release document lock\n   */\n  private async releaseDocumentLock(lockId: string): Promise<void> {\n    // Find and remove the lock\n    for (const [documentPath, lock] of this.documentLocks.entries()) {\n      if (lock.lockId === lockId) {\n        this.documentLocks.delete(documentPath);\n        \n        // Clear timeout\n        const timeout = this.lockTimeouts.get(lockId);\n        if (timeout) {\n          clearTimeout(timeout);\n          this.lockTimeouts.delete(lockId);\n        }\n\n        this.emit('consolidation_event', {\n          type: ConsolidationEventType.DOCUMENT_UNLOCKED,\n          timestamp: Date.now(),\n          documentPath,\n          data: { lockId }\n        });\n        \n        break;\n      }\n    }\n  }\n\n  /**\n   * Get operation priority by ID\n   */\n  private getOperationPriority(operationId: string): OperationPriority {\n    // Search through queues to find operation\n    for (const queue of this.operationQueue.values()) {\n      const operation = queue.find(op => op.id === operationId);\n      if (operation) {\n        return operation.priority;\n      }\n    }\n    return OperationPriority.BACKGROUND; // Default to lowest priority\n  }\n\n  /**\n   * Estimate wait time for document access\n   */\n  private estimateWaitTime(documentPath: string): number {\n    const lock = this.documentLocks.get(documentPath);\n    if (lock) {\n      return Math.max(0, lock.expiresAt - Date.now());\n    }\n    \n    const queue = this.operationQueue.get(documentPath);\n    if (queue) {\n      // Estimate based on average processing time and queue length\n      return queue.reduce((total, op) => total + op.metadata.estimatedProcessingTime, 0);\n    }\n    \n    return 0;\n  }\n\n  /**\n   * Update performance metrics\n   */\n  private updatePerformanceMetrics(metric: string, value: number): void {\n    if (metric === 'consolidation_time') {\n      const currentAvg = this.performanceMetrics.averageConsolidationTime;\n      const totalOps = this.performanceMetrics.totalOperations;\n      this.performanceMetrics.averageConsolidationTime = \n        (currentAvg * (totalOps - 1) + value) / totalOps;\n    }\n  }\n\n  /**\n   * Setup periodic cleanup of expired locks and old history\n   */\n  private setupCleanupInterval(): void {\n    setInterval(() => {\n      const now = Date.now();\n      \n      // Clean up expired locks\n      for (const [documentPath, lock] of this.documentLocks.entries()) {\n        if (lock.expiresAt < now) {\n          this.releaseDocumentLock(lock.lockId);\n        }\n      }\n      \n      // Clean up old consolidation history (keep last 24 hours)\n      const cutoff = now - 24 * 60 * 60 * 1000;\n      for (const [documentPath, events] of this.consolidationHistory.entries()) {\n        const recentEvents = events.filter(event => event.timestamp > cutoff);\n        if (recentEvents.length !== events.length) {\n          this.consolidationHistory.set(documentPath, recentEvents);\n        }\n      }\n    }, 60000); // Run every minute\n  }\n\n  // Conflict detection and resolution implementation\n  private async detectConflicts(operations: MultiPluginEditOperation[]): Promise<ChangeConflict[]> {\n    const operationId = `conflict_detection_${Date.now()}`;\n    \n    // Check cache first\n    if (this.performanceMonitor) {\n      const cacheKey = this.performanceMonitor.generateConflictCacheKey(operations);\n      const cachedResult = this.performanceMonitor.getCachedConflictDetection(cacheKey);\n      \n      if (cachedResult) {\n        return cachedResult;\n      }\n      \n      this.performanceMonitor.startTiming(operationId, 'conflict_detection');\n    }\n\n    const { ConflictDetectionEngine } = await import('./conflict-detection-algorithms');\n    \n    const detectionEngine = new ConflictDetectionEngine({\n      enableSemanticAnalysis: true,\n      overlapTolerance: 3,\n      dependencyDepth: 5,\n      temporalWindow: 5000,\n      priorityThreshold: 1\n    });\n\n    try {\n      const conflicts = await detectionEngine.detectConflicts(operations);\n      \n      // Cache the result if performance monitor is available\n      if (this.performanceMonitor) {\n        const cacheKey = this.performanceMonitor.generateConflictCacheKey(operations);\n        this.performanceMonitor.cacheConflictDetection(cacheKey, conflicts);\n        this.performanceMonitor.endTiming(operationId, 'conflict_detection', true);\n      }\n      \n      return conflicts;\n    } catch (error) {\n      console.error('[ChangeConsolidationManager] Error detecting conflicts:', error);\n      \n      // Handle error with recovery\n      if (this.errorManager) {\n        const { recovered } = await this.errorManager.handleError(error, { operations, operationId });\n        if (recovered) {\n          // Retry once\n          try {\n            const conflicts = await detectionEngine.detectConflicts(operations);\n            if (this.performanceMonitor) {\n              this.performanceMonitor.endTiming(operationId, 'conflict_detection', true);\n            }\n            return conflicts;\n          } catch (retryError) {\n            console.error('[ChangeConsolidationManager] Retry failed:', retryError);\n          }\n        }\n      }\n      \n      if (this.performanceMonitor) {\n        this.performanceMonitor.endTiming(operationId, 'conflict_detection', false);\n      }\n      \n      return [];\n    }\n  }\n\n  private async resolveConflicts(conflicts: ChangeConflict[]): Promise<ConflictResolution[]> {\n    const resolutions: ConflictResolution[] = [];\n\n    for (const conflict of conflicts) {\n      try {\n        const resolution = await this.resolveIndividualConflict(conflict);\n        resolutions.push(resolution);\n        \n        // Store resolved conflict\n        this.activeConflicts.delete(conflict.id);\n        \n        this.emit('consolidation_event', {\n          type: ConsolidationEventType.CONFLICT_RESOLVED,\n          timestamp: Date.now(),\n          documentPath: conflict.operations[0].documentPath,\n          data: { conflictId: conflict.id, strategy: resolution.strategy }\n        });\n      } catch (error) {\n        console.error(`[ChangeConsolidationManager] Error resolving conflict ${conflict.id}:`, error);\n        \n        // Create failed resolution\n        resolutions.push({\n          strategy: ConflictResolutionStrategy.USER_CHOICE,\n          result: {\n            success: false,\n            finalChanges: [],\n            warnings: [],\n            errors: [`Failed to resolve conflict: ${error.message}`],\n            requiresUserReview: true\n          },\n          timestamp: Date.now(),\n          appliedBy: 'system',\n          metadata: {\n            originalChanges: conflict.conflictingChanges\n          }\n        });\n      }\n    }\n\n    return resolutions;\n  }\n\n  private async resolveIndividualConflict(conflict: ChangeConflict): Promise<ConflictResolution> {\n    // Determine resolution strategy based on conflict type and severity\n    const strategy = this.selectResolutionStrategy(conflict);\n    \n    let result: ConflictResolutionResult;\n\n    switch (strategy) {\n      case ConflictResolutionStrategy.MERGE_COMPATIBLE:\n        result = await this.attemptCompatibleMerge(conflict);\n        break;\n        \n      case ConflictResolutionStrategy.PRIORITY_WINS:\n        result = await this.applyPriorityWins(conflict);\n        break;\n        \n      case ConflictResolutionStrategy.SEQUENTIAL_PROCESSING:\n        result = await this.applySequentialProcessing(conflict);\n        break;\n        \n      case ConflictResolutionStrategy.SEMANTIC_MERGE:\n        result = await this.attemptSemanticMerge(conflict);\n        break;\n        \n      case ConflictResolutionStrategy.DEFER_OPERATION:\n        result = await this.deferLowerPriorityOperations(conflict);\n        break;\n        \n      default:\n        result = {\n          success: false,\n          finalChanges: conflict.conflictingChanges,\n          warnings: [],\n          errors: ['Unknown resolution strategy'],\n          requiresUserReview: true\n        };\n    }\n\n    return {\n      strategy,\n      result,\n      timestamp: Date.now(),\n      appliedBy: 'system',\n      metadata: {\n        originalChanges: conflict.conflictingChanges,\n        mergedChanges: result.finalChanges,\n        rejectedChanges: result.success ? [] : conflict.conflictingChanges\n      }\n    };\n  }\n\n  private selectResolutionStrategy(conflict: ChangeConflict): ConflictResolutionStrategy {\n    // Strategy selection based on conflict characteristics\n    switch (conflict.type) {\n      case ConflictType.OVERLAPPING_EDITS:\n        if (conflict.severity === ConflictSeverity.LOW) {\n          return ConflictResolutionStrategy.MERGE_COMPATIBLE;\n        } else if (conflict.severity === ConflictSeverity.HIGH) {\n          return ConflictResolutionStrategy.PRIORITY_WINS;\n        } else {\n          return ConflictResolutionStrategy.SEQUENTIAL_PROCESSING;\n        }\n        \n      case ConflictType.SEMANTIC_CONFLICT:\n        return ConflictResolutionStrategy.SEMANTIC_MERGE;\n        \n      case ConflictType.DEPENDENCY_VIOLATION:\n        return ConflictResolutionStrategy.SEQUENTIAL_PROCESSING;\n        \n      case ConflictType.PRIORITY_CONFLICT:\n        return ConflictResolutionStrategy.PRIORITY_WINS;\n        \n      case ConflictType.RESOURCE_CONTENTION:\n        return ConflictResolutionStrategy.DEFER_OPERATION;\n        \n      default:\n        return ConflictResolutionStrategy.USER_CHOICE;\n    }\n  }\n\n  private async attemptCompatibleMerge(conflict: ChangeConflict): Promise<ConflictResolutionResult> {\n    const { ChangeMergingEngine } = await import('./change-merging-algorithms');\n    \n    const mergingEngine = new ChangeMergingEngine({\n      maxOverlapTolerance: 5,\n      preserveFormatting: true,\n      enableSemanticMerging: true,\n      priorityWeighting: 0.7,\n      confidenceThreshold: 0.6\n    });\n\n    try {\n      return await mergingEngine.mergeOperations(conflict.operations);\n    } catch (error) {\n      return {\n        success: false,\n        finalChanges: conflict.conflictingChanges,\n        warnings: [],\n        errors: [`Merge failed: ${error.message}`],\n        requiresUserReview: true\n      };\n    }\n  }\n\n  private async applyPriorityWins(conflict: ChangeConflict): Promise<ConflictResolutionResult> {\n    // Sort operations by priority\n    const sortedOps = [...conflict.operations].sort((a, b) => a.priority - b.priority);\n    const winningOp = sortedOps[0];\n    \n    return {\n      success: true,\n      finalChanges: winningOp.changes,\n      warnings: [\n        `Conflict resolved by priority: ${winningOp.pluginId} (priority ${winningOp.priority}) wins`,\n        `Rejected ${sortedOps.length - 1} lower priority operations`\n      ],\n      errors: [],\n      requiresUserReview: conflict.severity === ConflictSeverity.HIGH\n    };\n  }\n\n  private async applySequentialProcessing(conflict: ChangeConflict): Promise<ConflictResolutionResult> {\n    // Sort by priority and timestamp\n    const sortedOps = [...conflict.operations].sort((a, b) => {\n      if (a.priority !== b.priority) return a.priority - b.priority;\n      return a.timestamp - b.timestamp;\n    });\n\n    // Apply operations sequentially\n    const finalChanges: EditChange[] = [];\n    const warnings: string[] = [];\n    \n    for (const op of sortedOps) {\n      finalChanges.push(...op.changes);\n      warnings.push(`Applied operation ${op.id} from ${op.pluginId} sequentially`);\n    }\n\n    return {\n      success: true,\n      finalChanges,\n      warnings,\n      errors: [],\n      requiresUserReview: conflict.severity >= ConflictSeverity.MEDIUM\n    };\n  }\n\n  private async attemptSemanticMerge(conflict: ChangeConflict): Promise<ConflictResolutionResult> {\n    const { ChangeMergingEngine } = await import('./change-merging-algorithms');\n    \n    const mergingEngine = new ChangeMergingEngine({\n      enableSemanticMerging: true,\n      confidenceThreshold: 0.5,\n      priorityWeighting: 0.8\n    });\n\n    const result = await mergingEngine.mergeOperations(conflict.operations);\n    \n    if (!result.success || result.requiresUserReview) {\n      result.warnings.push('Semantic merge attempted but requires user review');\n    }\n\n    return result;\n  }\n\n  private async deferLowerPriorityOperations(conflict: ChangeConflict): Promise<ConflictResolutionResult> {\n    // Find highest priority operation\n    const highestPriorityOp = conflict.operations.reduce((highest, current) => \n      current.priority < highest.priority ? current : highest\n    );\n    \n    // Defer others back to queue\n    const deferredOps = conflict.operations.filter(op => op.id !== highestPriorityOp.id);\n    \n    for (const deferredOp of deferredOps) {\n      // Add back to queue with delay\n      setTimeout(() => {\n        this.submitOperation({\n          ...deferredOp,\n          timestamp: Date.now(),\n          metadata: {\n            ...deferredOp.metadata,\n            canBeDeferred: true\n          }\n        });\n      }, 1000); // 1 second delay\n    }\n\n    return {\n      success: true,\n      finalChanges: highestPriorityOp.changes,\n      warnings: [`Deferred ${deferredOps.length} lower priority operations`],\n      errors: [],\n      requiresUserReview: false\n    };\n  }\n\n  private async consolidateOperations(\n    operations: MultiPluginEditOperation[], \n    documentPath: string\n  ): Promise<ConflictResolutionResult> {\n    const { ChangeMergingEngine } = await import('./change-merging-algorithms');\n    \n    const mergingEngine = new ChangeMergingEngine({\n      maxOverlapTolerance: 3,\n      preserveFormatting: true,\n      enableSemanticMerging: true,\n      priorityWeighting: 0.7,\n      confidenceThreshold: 0.6\n    });\n\n    try {\n      const result = await mergingEngine.mergeOperations(operations);\n      \n      // Record consolidation in history\n      const historyEntry: ConsolidationEvent = {\n        type: ConsolidationEventType.CHANGES_MERGED,\n        timestamp: Date.now(),\n        documentPath,\n        data: {\n          operationIds: operations.map(op => op.id),\n          finalChangeCount: result.finalChanges.length,\n          success: result.success\n        }\n      };\n      \n      const history = this.consolidationHistory.get(documentPath) || [];\n      history.push(historyEntry);\n      this.consolidationHistory.set(documentPath, history);\n      \n      return result;\n    } catch (error) {\n      console.error('[ChangeConsolidationManager] Error consolidating operations:', error);\n      \n      return {\n        success: false,\n        finalChanges: operations.flatMap(op => op.changes),\n        warnings: [],\n        errors: [`Consolidation failed: ${error.message}`],\n        requiresUserReview: true\n      };\n    }\n  }\n\n  /**\n   * Get current performance metrics\n   */\n  getPerformanceMetrics() {\n    return this.performanceMonitor ? this.performanceMonitor.getMetrics() : null;\n  }\n\n  /**\n   * Get performance recommendations\n   */\n  getPerformanceRecommendations(): string[] {\n    return this.performanceMonitor ? this.performanceMonitor.getPerformanceRecommendations() : [];\n  }\n\n  /**\n   * Export performance data for analysis\n   */\n  exportPerformanceData() {\n    return this.performanceMonitor ? this.performanceMonitor.exportPerformanceData() : null;\n  }\n\n  /**\n   * Get error statistics\n   */\n  getErrorStatistics() {\n    return this.errorManager ? this.errorManager.getErrorStatistics() : null;\n  }\n\n  /**\n   * Check if system should throttle processing\n   */\n  shouldThrottleProcessing(): boolean {\n    return this.performanceMonitor ? this.performanceMonitor.shouldThrottleProcessing() : false;\n  }\n\n  /**\n   * Optimize configuration based on current performance\n   */\n  async optimizeConfiguration(): Promise<void> {\n    if (!this.performanceMonitor) return;\n\n    const metrics = this.performanceMonitor.getMetrics();\n    const recommendations = this.performanceMonitor.getPerformanceRecommendations();\n    \n    // Auto-adjust configuration based on performance\n    const currentConfig = this.performanceMonitor.getConfig();\n    const newConfig = { ...currentConfig };\n\n    // Adjust batch size based on memory usage\n    if (metrics.currentMemoryUsage > currentConfig.maxMemoryUsage * 0.8) {\n      newConfig.batchProcessingSize = Math.max(5, Math.floor(currentConfig.batchProcessingSize * 0.8));\n    } else if (metrics.currentMemoryUsage < currentConfig.maxMemoryUsage * 0.5) {\n      newConfig.batchProcessingSize = Math.min(50, Math.floor(currentConfig.batchProcessingSize * 1.2));\n    }\n\n    // Adjust caching based on performance\n    if (metrics.averageConflictDetectionTime > 1000) {\n      newConfig.enableResultCaching = true;\n      newConfig.maxCacheSize = Math.min(2000, currentConfig.maxCacheSize * 1.5);\n    }\n\n    // Adjust concurrent operations based on error rate\n    const errorStats = this.errorManager?.getErrorStatistics();\n    if (errorStats && errorStats.recentErrorRate > 5) { // More than 5 errors per minute\n      newConfig.maxConcurrentOperations = Math.max(2, currentConfig.maxConcurrentOperations - 1);\n    }\n\n    this.performanceMonitor.updateConfig(newConfig);\n    \n    console.log('[ChangeConsolidationManager] Configuration optimized:', {\n      oldBatchSize: currentConfig.batchProcessingSize,\n      newBatchSize: newConfig.batchProcessingSize,\n      oldConcurrentOps: currentConfig.maxConcurrentOperations,\n      newConcurrentOps: newConfig.maxConcurrentOperations,\n      recommendations\n    });\n  }\n\n  /**\n   * Get active document locks\n   */\n  getActiveDocumentLocks(): Map<string, DocumentLock> {\n    return new Map(this.documentLocks);\n  }\n\n  /**\n   * Get queued operations for a document\n   */\n  getQueuedOperations(documentPath: string): MultiPluginEditOperation[] {\n    return [...(this.operationQueue.get(documentPath) || [])];\n  }\n\n  /**\n   * Get consolidation status for UI\n   */\n  getConsolidationStatus(): {\n    status: 'idle' | 'processing' | 'conflict' | 'completed' | 'error';\n    details: string;\n    activeOperations: number;\n    queuedOperations: number;\n    activeConflicts: number;\n  } {\n    const activeOperations = Array.from(this.operationQueue.values()).reduce((sum, ops) => sum + ops.length, 0);\n    const queuedOperations = activeOperations;\n    const activeConflicts = this.activeConflicts.size;\n\n    let status: 'idle' | 'processing' | 'conflict' | 'completed' | 'error' = 'idle';\n    let details = 'No active operations';\n\n    if (activeConflicts > 0) {\n      status = 'conflict';\n      details = `${activeConflicts} conflict${activeConflicts !== 1 ? 's' : ''} requiring resolution`;\n    } else if (activeOperations > 0) {\n      status = 'processing';\n      details = `Processing ${activeOperations} operation${activeOperations !== 1 ? 's' : ''}`;\n    } else if (this.consolidationHistory.size > 0) {\n      const recentEvents = Array.from(this.consolidationHistory.values())\n        .flat()\n        .filter(event => Date.now() - event.timestamp < 5000);\n      \n      if (recentEvents.some(e => e.type === ConsolidationEventType.CONSOLIDATION_FAILED)) {\n        status = 'error';\n        details = 'Recent consolidation failed';\n      } else if (recentEvents.some(e => e.type === ConsolidationEventType.CONSOLIDATION_COMPLETE)) {\n        status = 'completed';\n        details = 'Recent consolidation completed successfully';\n      }\n    }\n\n    return {\n      status,\n      details,\n      activeOperations,\n      queuedOperations,\n      activeConflicts\n    };\n  }\n}", "// ============================================================================\n// PLATFORM-WIDE EVENT COORDINATION PATTERNS\n// ============================================================================\n\nimport { \n  WriterrlEventV2, \n  AIProcessingStartEvent, \n  AIProcessingCompleteEvent,\n  DocumentChangeAppliedEvent,\n  WorkflowEvent,\n  EventPriority,\n  EventPersistence,\n  WriterrlEventFactory\n} from './event-bus-integration';\n\n// ============================================================================\n// EVENT NAMING CONVENTIONS\n// ============================================================================\n\n/**\n * Standardized event naming patterns for platform consistency\n * Format: [domain].[entity].[action].[status?]\n * \n * Examples:\n * - ai.processing.start\n * - document.change.applied\n * - session.sync.complete\n * - plugin.health.warning\n * - workflow.step.complete\n * - platform.error.system\n */\nexport const EVENT_NAMING_CONVENTIONS = {\n  // Domain prefixes\n  DOMAINS: {\n    AI: 'ai',\n    DOCUMENT: 'document', \n    SESSION: 'session',\n    PLUGIN: 'plugin',\n    WORKFLOW: 'workflow',\n    PLATFORM: 'platform'\n  },\n  \n  // Entity types\n  ENTITIES: {\n    PROCESSING: 'processing',\n    CHANGE: 'change',\n    SYNC: 'sync',\n    HEALTH: 'health',\n    STEP: 'step',\n    ERROR: 'error'\n  },\n  \n  // Action types\n  ACTIONS: {\n    START: 'start',\n    COMPLETE: 'complete',\n    APPLIED: 'applied',\n    CREATED: 'created',\n    UPDATED: 'updated',\n    DELETED: 'deleted',\n    FAILED: 'failed'\n  },\n  \n  // Status qualifiers\n  STATUS: {\n    SUCCESS: 'success',\n    ERROR: 'error',\n    WARNING: 'warning',\n    PROGRESS: 'progress'\n  }\n} as const;\n\n// ============================================================================\n// EVENT ROUTING AND FILTERING GUIDELINES\n// ============================================================================\n\n/**\n * Event routing configuration for cross-plugin coordination\n */\nexport interface EventRoutingConfig {\n  /** Source plugin that should receive this event type */\n  targetPlugins: string[];\n  \n  /** Event priority for processing order */\n  priority: EventPriority;\n  \n  /** Whether event requires acknowledgment */\n  requiresAck: boolean;\n  \n  /** Maximum propagation time in milliseconds */\n  maxPropagationTime: number;\n  \n  /** Whether to persist for offline sync */\n  persistence: EventPersistence;\n}\n\n/**\n * Standard event routing configurations for common workflows\n */\nexport const STANDARD_EVENT_ROUTING: Record<string, EventRoutingConfig> = {\n  // AI Processing Events - Route to all interested plugins\n  'ai.processing.start': {\n    targetPlugins: ['track-edits', 'writerr-chat', 'editorial-engine'],\n    priority: EventPriority.HIGH,\n    requiresAck: true,\n    maxPropagationTime: 1000,\n    persistence: EventPersistence.SESSION\n  },\n  \n  'ai.processing.complete': {\n    targetPlugins: ['track-edits', 'writerr-chat'],\n    priority: EventPriority.HIGH,\n    requiresAck: true,\n    maxPropagationTime: 500,\n    persistence: EventPersistence.PERMANENT\n  },\n  \n  // Document Change Events - Critical for all plugins\n  'document.change.applied': {\n    targetPlugins: ['track-edits', 'writerr-chat', 'editorial-engine'],\n    priority: EventPriority.CRITICAL,\n    requiresAck: true,\n    maxPropagationTime: 100,\n    persistence: EventPersistence.PERMANENT\n  },\n  \n  'document.change.batched': {\n    targetPlugins: ['track-edits', 'writerr-chat'],\n    priority: EventPriority.HIGH,\n    requiresAck: false,\n    maxPropagationTime: 500,\n    persistence: EventPersistence.SESSION\n  },\n  \n  // Session Events - For synchronization\n  'session.created': {\n    targetPlugins: ['track-edits', 'writerr-chat', 'editorial-engine'],\n    priority: EventPriority.NORMAL,\n    requiresAck: false,\n    maxPropagationTime: 2000,\n    persistence: EventPersistence.OFFLINE\n  },\n  \n  // Plugin Lifecycle - For coordination\n  'plugin.registered': {\n    targetPlugins: ['track-edits'],\n    priority: EventPriority.NORMAL,\n    requiresAck: false,\n    maxPropagationTime: 1000,\n    persistence: EventPersistence.SESSION\n  },\n  \n  // Workflow Coordination - High priority for orchestration\n  'workflow.started': {\n    targetPlugins: ['track-edits', 'writerr-chat', 'editorial-engine'],\n    priority: EventPriority.HIGH,\n    requiresAck: true,\n    maxPropagationTime: 500,\n    persistence: EventPersistence.SESSION\n  }\n};\n\n// ============================================================================\n// CROSS-PLUGIN WORKFLOW PATTERNS\n// ============================================================================\n\n/**\n * Workflow step definition for cross-plugin coordination\n */\nexport interface WorkflowStep {\n  id: string;\n  name: string;\n  assignedPlugin: string;\n  dependencies: string[];\n  timeout: number;\n  retryable: boolean;\n  criticalPath: boolean;\n}\n\n/**\n * Standard workflow definitions for common Writerr Platform operations\n */\nexport class WriterrlWorkflowPatterns {\n  \n  /**\n   * Chat \u2192 Editorial Engine \u2192 Track Edits workflow\n   * User makes request in chat, processed by editorial engine, tracked by track-edits\n   */\n  static getChatToEditorialToTrackWorkflow(requestId: string): WorkflowStep[] {\n    return [\n      {\n        id: `${requestId}-chat-request`,\n        name: 'Process Chat Request',\n        assignedPlugin: 'writerr-chat',\n        dependencies: [],\n        timeout: 30000,\n        retryable: true,\n        criticalPath: true\n      },\n      {\n        id: `${requestId}-editorial-processing`,\n        name: 'Editorial Processing',\n        assignedPlugin: 'editorial-engine',\n        dependencies: [`${requestId}-chat-request`],\n        timeout: 60000,\n        retryable: true,\n        criticalPath: true\n      },\n      {\n        id: `${requestId}-change-tracking`,\n        name: 'Track Changes',\n        assignedPlugin: 'track-edits',\n        dependencies: [`${requestId}-editorial-processing`],\n        timeout: 15000,\n        retryable: false,\n        criticalPath: true\n      },\n      {\n        id: `${requestId}-chat-notification`,\n        name: 'Notify Chat of Completion',\n        assignedPlugin: 'writerr-chat',\n        dependencies: [`${requestId}-change-tracking`],\n        timeout: 5000,\n        retryable: true,\n        criticalPath: false\n      }\n    ];\n  }\n  \n  /**\n   * Collaborative editing workflow\n   * Multiple users editing with real-time synchronization\n   */\n  static getCollaborativeEditWorkflow(sessionId: string): WorkflowStep[] {\n    return [\n      {\n        id: `${sessionId}-session-init`,\n        name: 'Initialize Collaborative Session',\n        assignedPlugin: 'track-edits',\n        dependencies: [],\n        timeout: 10000,\n        retryable: true,\n        criticalPath: true\n      },\n      {\n        id: `${sessionId}-sync-setup`,\n        name: 'Setup Change Synchronization',\n        assignedPlugin: 'track-edits',\n        dependencies: [`${sessionId}-session-init`],\n        timeout: 5000,\n        retryable: true,\n        criticalPath: true\n      },\n      {\n        id: `${sessionId}-participant-notify`,\n        name: 'Notify All Participants',\n        assignedPlugin: 'writerr-chat',\n        dependencies: [`${sessionId}-sync-setup`],\n        timeout: 10000,\n        retryable: true,\n        criticalPath: false\n      }\n    ];\n  }\n  \n  /**\n   * Batch processing workflow for large editorial operations\n   */\n  static getBatchProcessingWorkflow(batchId: string): WorkflowStep[] {\n    return [\n      {\n        id: `${batchId}-batch-validation`,\n        name: 'Validate Batch Request',\n        assignedPlugin: 'editorial-engine',\n        dependencies: [],\n        timeout: 15000,\n        retryable: false,\n        criticalPath: true\n      },\n      {\n        id: `${batchId}-batch-processing`,\n        name: 'Process Batch Changes',\n        assignedPlugin: 'editorial-engine',\n        dependencies: [`${batchId}-batch-validation`],\n        timeout: 300000, // 5 minutes for large batches\n        retryable: true,\n        criticalPath: true\n      },\n      {\n        id: `${batchId}-change-grouping`,\n        name: 'Group Related Changes',\n        assignedPlugin: 'track-edits',\n        dependencies: [`${batchId}-batch-processing`],\n        timeout: 30000,\n        retryable: true,\n        criticalPath: true\n      },\n      {\n        id: `${batchId}-batch-review`,\n        name: 'Present Batch for Review',\n        assignedPlugin: 'track-edits',\n        dependencies: [`${batchId}-change-grouping`],\n        timeout: 10000,\n        retryable: false,\n        criticalPath: false\n      }\n    ];\n  }\n}\n\n// ============================================================================\n// EVENT SEQUENCING AND ORDERING\n// ============================================================================\n\n/**\n * Event sequence manager for maintaining order in dependent operations\n */\nexport class EventSequenceManager {\n  private sequences = new Map<string, EventSequence>();\n  private pendingEvents = new Map<string, WriterrlEventV2[]>();\n  \n  /**\n   * Register an event sequence for ordered processing\n   */\n  registerSequence(sequenceId: string, expectedEvents: string[]): void {\n    this.sequences.set(sequenceId, {\n      id: sequenceId,\n      expectedEvents,\n      receivedEvents: [],\n      completed: false,\n      startedAt: Date.now()\n    });\n    \n    this.pendingEvents.set(sequenceId, []);\n  }\n  \n  /**\n   * Add event to sequence and check if ready to process\n   */\n  addEventToSequence(sequenceId: string, event: WriterrlEventV2): boolean {\n    const sequence = this.sequences.get(sequenceId);\n    const pending = this.pendingEvents.get(sequenceId);\n    \n    if (!sequence || !pending) {\n      return false;\n    }\n    \n    // Add to received events\n    sequence.receivedEvents.push(event.type);\n    pending.push(event);\n    \n    // Check if sequence is complete\n    const allReceived = sequence.expectedEvents.every(eventType =>\n      sequence.receivedEvents.includes(eventType)\n    );\n    \n    if (allReceived) {\n      sequence.completed = true;\n      sequence.completedAt = Date.now();\n      return true;\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Get ordered events for a completed sequence\n   */\n  getOrderedEvents(sequenceId: string): WriterrlEventV2[] | null {\n    const sequence = this.sequences.get(sequenceId);\n    const pending = this.pendingEvents.get(sequenceId);\n    \n    if (!sequence || !pending || !sequence.completed) {\n      return null;\n    }\n    \n    // Sort events according to expected order\n    return pending.sort((a, b) => {\n      const aIndex = sequence.expectedEvents.indexOf(a.type);\n      const bIndex = sequence.expectedEvents.indexOf(b.type);\n      return aIndex - bIndex;\n    });\n  }\n  \n  /**\n   * Clean up completed or expired sequences\n   */\n  cleanup(maxAge: number = 300000): void { // 5 minutes default\n    const now = Date.now();\n    \n    for (const [sequenceId, sequence] of this.sequences) {\n      if (sequence.completed || (now - sequence.startedAt) > maxAge) {\n        this.sequences.delete(sequenceId);\n        this.pendingEvents.delete(sequenceId);\n      }\n    }\n  }\n}\n\ninterface EventSequence {\n  id: string;\n  expectedEvents: string[];\n  receivedEvents: string[];\n  completed: boolean;\n  startedAt: number;\n  completedAt?: number;\n}\n\n// ============================================================================\n// CONFLICT RESOLUTION PATTERNS\n// ============================================================================\n\n/**\n * Conflict types that can occur during multi-plugin operations\n */\nexport enum ConflictType {\n  SIMULTANEOUS_EDIT = 'simultaneous-edit',\n  RESOURCE_CONTENTION = 'resource-contention',\n  PLUGIN_DEPENDENCY = 'plugin-dependency',\n  STATE_SYNCHRONIZATION = 'state-sync'\n}\n\n/**\n * Conflict resolution strategies\n */\nexport enum ResolutionStrategy {\n  LAST_WRITER_WINS = 'last-writer-wins',\n  FIRST_WRITER_WINS = 'first-writer-wins',\n  MERGE_CHANGES = 'merge-changes',\n  MANUAL_RESOLUTION = 'manual-resolution',\n  ROLLBACK_CHANGES = 'rollback-changes'\n}\n\n/**\n * Conflict detection and resolution system\n */\nexport class ConflictResolver {\n  private activeConflicts = new Map<string, ConflictResolution>();\n  \n  /**\n   * Detect potential conflicts in event stream\n   */\n  detectConflict(events: WriterrlEventV2[]): ConflictDetection | null {\n    // Check for simultaneous document edits\n    const documentEvents = events.filter(e => \n      e.type.startsWith('document.change.') && \n      e.timestamp > Date.now() - 5000 // Within 5 seconds\n    ) as DocumentChangeAppliedEvent[];\n    \n    if (documentEvents.length > 1) {\n      // Check if editing same document range\n      const conflicts = this.findRangeConflicts(documentEvents);\n      if (conflicts.length > 0) {\n        return {\n          type: ConflictType.SIMULTANEOUS_EDIT,\n          events: conflicts,\n          detectedAt: Date.now(),\n          severity: 'high'\n        };\n      }\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Resolve conflict using specified strategy\n   */\n  async resolveConflict(\n    conflictId: string, \n    strategy: ResolutionStrategy\n  ): Promise<ConflictResolutionResult> {\n    const conflict = this.activeConflicts.get(conflictId);\n    if (!conflict) {\n      return { success: false, error: 'Conflict not found' };\n    }\n    \n    switch (strategy) {\n      case ResolutionStrategy.LAST_WRITER_WINS:\n        return this.applyLastWriterWins(conflict);\n        \n      case ResolutionStrategy.MERGE_CHANGES:\n        return this.mergeConflictingChanges(conflict);\n        \n      case ResolutionStrategy.MANUAL_RESOLUTION:\n        return this.requestManualResolution(conflict);\n        \n      default:\n        return { success: false, error: 'Unknown resolution strategy' };\n    }\n  }\n  \n  private findRangeConflicts(events: DocumentChangeAppliedEvent[]): DocumentChangeAppliedEvent[] {\n    const conflicts: DocumentChangeAppliedEvent[] = [];\n    \n    for (let i = 0; i < events.length; i++) {\n      for (let j = i + 1; j < events.length; j++) {\n        const event1 = events[i];\n        const event2 = events[j];\n        \n        // Check if ranges overlap\n        if (this.rangesOverlap(\n          event1.payload.change.range,\n          event2.payload.change.range\n        )) {\n          if (!conflicts.includes(event1)) conflicts.push(event1);\n          if (!conflicts.includes(event2)) conflicts.push(event2);\n        }\n      }\n    }\n    \n    return conflicts;\n  }\n  \n  private rangesOverlap(range1: {start: number; end: number}, range2: {start: number; end: number}): boolean {\n    return range1.start < range2.end && range2.start < range1.end;\n  }\n  \n  private async applyLastWriterWins(conflict: ConflictResolution): Promise<ConflictResolutionResult> {\n    // Implementation would determine the latest change and apply it\n    return { success: true, strategy: ResolutionStrategy.LAST_WRITER_WINS };\n  }\n  \n  private async mergeConflictingChanges(conflict: ConflictResolution): Promise<ConflictResolutionResult> {\n    // Implementation would attempt to merge non-overlapping changes\n    return { success: true, strategy: ResolutionStrategy.MERGE_CHANGES };\n  }\n  \n  private async requestManualResolution(conflict: ConflictResolution): Promise<ConflictResolutionResult> {\n    // Implementation would present conflict to user for manual resolution\n    return { \n      success: false, \n      strategy: ResolutionStrategy.MANUAL_RESOLUTION,\n      requiresUserInput: true \n    };\n  }\n}\n\ninterface ConflictDetection {\n  type: ConflictType;\n  events: WriterrlEventV2[];\n  detectedAt: number;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n}\n\ninterface ConflictResolution {\n  id: string;\n  type: ConflictType;\n  events: WriterrlEventV2[];\n  detectedAt: number;\n  strategy?: ResolutionStrategy;\n  resolved?: boolean;\n}\n\ninterface ConflictResolutionResult {\n  success: boolean;\n  strategy?: ResolutionStrategy;\n  error?: string;\n  requiresUserInput?: boolean;\n}\n\n// ============================================================================\n// WORKFLOW ORCHESTRATION\n// ============================================================================\n\n/**\n * Workflow orchestrator for managing complex cross-plugin operations\n */\nexport class WorkflowOrchestrator {\n  private activeWorkflows = new Map<string, WorkflowExecution>();\n  private sequenceManager = new EventSequenceManager();\n  private conflictResolver = new ConflictResolver();\n  \n  /**\n   * Start a new workflow with defined steps\n   */\n  async startWorkflow(\n    workflowId: string,\n    workflowType: string,\n    steps: WorkflowStep[],\n    context: any\n  ): Promise<boolean> {\n    try {\n      const execution: WorkflowExecution = {\n        id: workflowId,\n        type: workflowType,\n        steps,\n        context,\n        currentStepIndex: 0,\n        status: 'running',\n        startedAt: Date.now(),\n        completedSteps: [],\n        errors: []\n      };\n      \n      this.activeWorkflows.set(workflowId, execution);\n      \n      // Start first step\n      return await this.executeNextStep(workflowId);\n      \n    } catch (error) {\n      console.error(`Failed to start workflow ${workflowId}:`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Process workflow step completion event\n   */\n  async processStepCompletion(event: WorkflowEvent): Promise<void> {\n    if (event.type !== 'workflow.step.complete') return;\n    \n    const workflowId = event.payload.workflow.id;\n    const execution = this.activeWorkflows.get(workflowId);\n    \n    if (!execution) return;\n    \n    // Mark step as completed\n    execution.completedSteps.push(event.payload.currentStep!.name);\n    execution.currentStepIndex++;\n    \n    // Check if workflow is complete\n    if (execution.currentStepIndex >= execution.steps.length) {\n      execution.status = 'completed';\n      execution.completedAt = Date.now();\n      \n      // Emit workflow completion event\n      const completionEvent = WriterrlEventFactory.createWorkflowEvent(\n        'workflow.complete',\n        'track-edits',\n        event.payload.workflow,\n        execution.context,\n        undefined,\n        {\n          totalSteps: execution.steps.length,\n          completedSteps: execution.completedSteps.length,\n          duration: Date.now() - execution.startedAt,\n          artifacts: [],\n          success: true\n        }\n      );\n      \n      // Workflow complete - would emit event here\n      console.log('Workflow completed:', completionEvent);\n      \n    } else {\n      // Execute next step\n      await this.executeNextStep(workflowId);\n    }\n  }\n  \n  private async executeNextStep(workflowId: string): Promise<boolean> {\n    const execution = this.activeWorkflows.get(workflowId);\n    if (!execution || execution.status !== 'running') return false;\n    \n    const currentStep = execution.steps[execution.currentStepIndex];\n    if (!currentStep) return false;\n    \n    // Check if dependencies are satisfied\n    const dependenciesComplete = currentStep.dependencies.every(dep =>\n      execution.completedSteps.includes(dep)\n    );\n    \n    if (!dependenciesComplete) {\n      // Wait for dependencies\n      setTimeout(() => this.executeNextStep(workflowId), 1000);\n      return true;\n    }\n    \n    // Start step execution\n    const stepEvent = WriterrlEventFactory.createWorkflowEvent(\n      'workflow.step.complete',\n      currentStep.assignedPlugin,\n      execution.context.workflow || { id: workflowId, name: execution.type, type: execution.type, initiator: 'track-edits' },\n      execution.context,\n      {\n        name: currentStep.name,\n        status: 'in-progress',\n        assignedPlugin: currentStep.assignedPlugin,\n        startedAt: Date.now(),\n        data: execution.context\n      }\n    );\n    \n    // Would emit step start event here\n    console.log('Starting workflow step:', stepEvent);\n    \n    return true;\n  }\n  \n  /**\n   * Handle workflow errors and implement recovery\n   */\n  async handleWorkflowError(workflowId: string, error: any, step: WorkflowStep): Promise<void> {\n    const execution = this.activeWorkflows.get(workflowId);\n    if (!execution) return;\n    \n    execution.errors.push({\n      step: step.name,\n      error: error.message,\n      timestamp: Date.now(),\n      recoverable: step.retryable\n    });\n    \n    if (step.retryable && step.criticalPath) {\n      // Retry the step\n      setTimeout(() => this.executeNextStep(workflowId), 5000);\n    } else if (step.criticalPath) {\n      // Critical failure - abort workflow\n      execution.status = 'failed';\n      execution.completedAt = Date.now();\n    } else {\n      // Non-critical failure - continue with next step\n      execution.currentStepIndex++;\n      await this.executeNextStep(workflowId);\n    }\n  }\n  \n  /**\n   * Get status of active workflows\n   */\n  getWorkflowStatus(workflowId?: string): WorkflowExecution[] {\n    if (workflowId) {\n      const execution = this.activeWorkflows.get(workflowId);\n      return execution ? [execution] : [];\n    }\n    \n    return Array.from(this.activeWorkflows.values());\n  }\n}\n\ninterface WorkflowExecution {\n  id: string;\n  type: string;\n  steps: WorkflowStep[];\n  context: any;\n  currentStepIndex: number;\n  status: 'running' | 'completed' | 'failed' | 'paused';\n  startedAt: number;\n  completedAt?: number;\n  completedSteps: string[];\n  errors: Array<{\n    step: string;\n    error: string;\n    timestamp: number;\n    recoverable: boolean;\n  }>;\n}\n\n", "import { Plugin, MarkdownView, Editor, EditorChange, TFile, WorkspaceLeaf, ItemView } from 'obsidian';\nimport { StateField, StateEffect, Transaction, ChangeSpec } from '@codemirror/state';\nimport { EditorView, ViewUpdate, ViewPlugin, Decoration, DecorationSet, WidgetType } from '@codemirror/view';\nimport { TrackEditsSettingsTab } from './settings';\nimport { EditTracker } from './edit-tracker';\nimport { EditRenderer } from './edit-renderer';\nimport { EditSidePanelView } from './side-panel-view';\nimport { EditClusterManager } from './edit-cluster-manager';\nimport { ToggleStateManager } from './ui/ToggleStateManager';\nimport { ToggleConfirmationModal } from './components/ToggleConfirmationModal';\nimport { EditSession, EditChange, WriterrlGlobalAPI, AIProcessingContext } from '../../../shared/types';\nimport { generateId, debounce } from '../../../shared/utils';\nimport { SubmitChangesFromAIResult, SubmitChangesFromAIOptions, EnhancedAIProcessingContext, EditorialOperationType } from './types/submit-changes-from-ai';\nimport { AIMetadataValidator } from './validation/ai-metadata-validator';\nimport { ChangeBatchManager, BatchManagerFactory } from './change-batch-manager';\nimport { PluginRegistry } from './plugin-system/plugin-registry';\nimport { PluginSecurityValidator } from './plugin-system/plugin-security-validator';\nimport { PluginCapabilityValidator } from './plugin-system/plugin-capability-validator';\nimport { IAIProcessingPlugin, PluginRegistrationResult } from './plugin-system/plugin-interface';\nimport { EditorialEnginePluginWrapper } from './plugin-system/editorial-engine-plugin';\nimport { initializeTrackEditsPluginAPI, cleanupTrackEditsPluginAPI } from './plugin-system/plugin-api';\nimport { WriterrlEventBusConnection, EventBusUtils, WriterrlEvent, WriterrlChangeEvent, WriterrlSessionEvent, WriterrlErrorEvent } from './event-bus-integration';\nimport { EventPersistenceManager } from './event-persistence-manager';\n\ninterface TrackEditsSettings {\n  enableTracking: boolean;\n  showLineNumbers: boolean;\n  highlightChanges: boolean;\n  retentionDays: number;\n  colorScheme: 'default' | 'colorblind' | 'dark';\n  autoSave: boolean;\n  exportFormat: 'json' | 'csv' | 'markdown';\n  enableClustering: boolean;\n  clusterTimeWindow: number;\n  showSidePanelOnStart: boolean;\n  // AI Integration settings\n  aiAlwaysEnabled: boolean;\n  aiProvider: string;\n  aiModel: string;\n  systemPromptPath: string;\n  // Event Bus Integration settings\n  enableEventBus: boolean;\n  eventBusDebugMode: boolean;\n  eventBusMaxReconnectAttempts: number;\n  eventBusReconnectDelay: number;\n}\n\n// AI Processing State Management Interfaces\ninterface AIProcessingState {\n  requestId: string;\n  operation: {\n    type: EditorialOperationType;\n    provider: string;\n    model: string;\n    startTime: number;\n  };\n  input: {\n    documentId: string;\n    content: string;\n    userPrompt: string;\n    constraints?: string[];\n  };\n  status: 'preparing' | 'processing' | 'completing' | 'completed' | 'error' | 'cancelled';\n  progress: {\n    percentage: number;\n    stage: string;\n    estimatedTimeRemaining?: number;\n    currentOperation?: string;\n  };\n  sourcePlugin: string;\n  sessionId?: string;\n  errorDetails?: {\n    type: string;\n    message: string;\n    recoverable: boolean;\n  };\n  metrics?: {\n    tokensProcessed: number;\n    responseTime: number;\n    memoryUsage: number;\n  };\n}\n\ninterface AIProcessingQueue {\n  active: AIProcessingState[];\n  pending: AIProcessingState[];\n  completed: AIProcessingState[];\n  failed: AIProcessingState[];\n}\n\ninterface ProcessingCoordinationConfig {\n  maxConcurrentOperations: number;\n  processingTimeoutMs: number;\n  queueMaxSize: number;\n  enableRealTimeUpdates: boolean;\n}\n\nconst DEFAULT_SETTINGS: TrackEditsSettings = {\n  enableTracking: true,\n  showLineNumbers: true,\n  highlightChanges: true,\n  retentionDays: 30,\n  colorScheme: 'default',\n  autoSave: true,\n  exportFormat: 'json',\n  enableClustering: true,\n  clusterTimeWindow: 2000,\n  showSidePanelOnStart: true,\n  // AI Integration defaults\n  aiAlwaysEnabled: false,\n  aiProvider: '',\n  aiModel: '',\n  systemPromptPath: 'prompts/system-prompt.md',\n  // Event Bus Integration defaults\n  enableEventBus: true,\n  eventBusDebugMode: false,\n  eventBusMaxReconnectAttempts: 3,\n  eventBusReconnectDelay: 1000\n};\n\n// Development monitoring - remove before production\nconst DEBUG_MODE = true;\nconst PERF_MONITOR = true;\n\nclass DebugMonitor {\n  private static logs: { timestamp: number; type: string; data: any }[] = [];\n  private static perfCounters = new Map<string, { count: number; totalTime: number; maxTime: number }>();\n  \n  static log(type: string, data: any) {\n    if (!DEBUG_MODE) return;\n    this.logs.push({ timestamp: Date.now(), type, data });\n    \n    // Log with expanded object details for better visibility\n    console.log(`[Track Edits ${type}]`, JSON.stringify(data, null, 2));\n    \n    // Keep only last 1000 logs\n    if (this.logs.length > 1000) {\n      this.logs.splice(0, 500);\n    }\n  }\n  \n  static startTimer(name: string) {\n    if (!PERF_MONITOR) return null;\n    return { name, start: performance.now() };\n  }\n  \n  static endTimer(timer: { name: string; start: number } | null) {\n    if (!timer || !PERF_MONITOR) return;\n    const duration = performance.now() - timer.start;\n    \n    const counter = this.perfCounters.get(timer.name) || { count: 0, totalTime: 0, maxTime: 0 };\n    counter.count++;\n    counter.totalTime += duration;\n    counter.maxTime = Math.max(counter.maxTime, duration);\n    this.perfCounters.set(timer.name, counter);\n    \n    if (duration > 16) {\n      console.warn(`[Track Edits PERF] ${timer.name} took ${duration.toFixed(2)}ms (>16ms target)`);\n    }\n  }\n  \n  static getReport() {\n    return {\n      recentLogs: this.logs.slice(-50),\n      perfStats: Object.fromEntries(this.perfCounters.entries()),\n      summary: {\n        totalLogs: this.logs.length,\n        perfCounters: this.perfCounters.size,\n        slowOperations: Array.from(this.perfCounters.entries())\n          .filter(([_, stats]) => stats.maxTime > 16)\n          .map(([name, stats]) => ({ name, maxTime: stats.maxTime, avgTime: stats.totalTime / stats.count }))\n      }\n    };\n  }\n  \n  static clear() {\n    this.logs = [];\n    this.perfCounters.clear();\n  }\n}\n\n// Global state for CodeMirror integration\nlet currentPluginInstance: TrackEditsPlugin | null = null;\nlet isRejectingEdit = false;\n\n// DEBUG: Add global access for debugging\nif (DEBUG_MODE) {\n  (window as any).TrackEditsDebug = {\n    getReport: () => DebugMonitor.getReport(),\n    clearLogs: () => DebugMonitor.clear(),\n    getCurrentState: () => ({\n      currentPluginInstance: !!currentPluginInstance,\n      isRejectingEdit,\n      currentEdits: currentPluginInstance?.currentEdits?.length || 0,\n      hasSession: !!currentPluginInstance?.currentSession\n    }),\n    logCurrent: () => {\n      const state = (window as any).TrackEditsDebug.getCurrentState();\n      console.log('[Track Edits Debug]', state);\n      return state;\n    }\n  };\n  console.log('[Track Edits] Debug mode enabled. Access via window.TrackEditsDebug');\n}\n\n// State effects for decoration management\nconst addDecorationEffect = StateEffect.define<{edit: EditChange, decoration: Decoration}>();\nconst removeDecorationEffect = StateEffect.define<string>(); // edit ID\nconst clearAllDecorationsEffect = StateEffect.define<boolean>();\n\n// Custom widget for showing deleted text\nclass DeletionWidget extends WidgetType {\n  public editId: string; // Make public for StateField access\n  \n  constructor(private deletedText: string, editId: string) {\n    super();\n    this.editId = editId; // Store as public property\n  }\n  \n  toDOM(): HTMLElement {\n    const span = document.createElement('span');\n    span.className = 'track-edits-decoration track-edits-decoration-delete';\n    span.textContent = this.deletedText;\n    span.setAttribute('data-edit-id', this.editId);\n    span.style.cssText = `\n      color: #f85149;\n      text-decoration: line-through;\n      opacity: 0.7;\n      background: transparent;\n    `;\n    return span;\n  }\n}\n\n// Create decoration for edit visualization  \nfunction createEditDecoration(edit: EditChange): Decoration {\n  const attributes = { 'data-edit-id': edit.id };\n  \n  if (edit.type === 'insert') {\n    return Decoration.mark({\n      class: 'track-edits-decoration track-edits-decoration-insert',\n      attributes: attributes\n    });\n  } else if (edit.type === 'delete') {\n    return Decoration.widget({\n      widget: new DeletionWidget(edit.removedText || '', edit.id),\n      side: -1\n    });\n  }\n  \n  // Fallback\n  return Decoration.mark({ \n    class: 'track-edits-decoration track-edits-decoration-insert', \n    attributes \n  });\n}\n\n// StateField for managing decorations\nconst editDecorationField = StateField.define<DecorationSet>({\n  create() {\n    DebugMonitor.log('STATEFIELD_CREATE', { message: 'StateField created with empty decoration set' });\n    return Decoration.none;\n  },\n  update(decorations, tr) {\n    const timer = DebugMonitor.startTimer('StateField.update');\n    \n    const initialSize = decorations.size;\n    DebugMonitor.log('STATEFIELD_UPDATE_START', {\n      hasChanges: !!tr.changes,\n      changeCount: tr.changes ? tr.changes.desc.length : 0,\n      effectCount: tr.effects.length,\n      currentDecorations: initialSize,\n      docLength: tr.newDoc.length\n    });\n    \n    // Map existing decorations to new positions\n    const mapTimer = DebugMonitor.startTimer('decorations.map');\n    decorations = decorations.map(tr.changes);\n    DebugMonitor.endTimer(mapTimer);\n    \n    let addedDecorations = 0;\n    let removedDecorations = 0;\n    \n    // Process effects for new decorations\n    for (const effect of tr.effects) {\n      if (effect.is(addDecorationEffect)) {\n        const { edit, decoration } = effect.value;\n        \n        DebugMonitor.log('ADD_DECORATION_EFFECT', {\n          editId: edit.id,\n          editType: edit.type,\n          position: { from: edit.from, to: edit.to },\n          textLength: edit.text?.length || 0\n        });\n        \n        if (edit.type === 'delete') {\n          // Widget decorations for deletions\n          const pos = edit.from;\n          decorations = decorations.update({\n            add: [decoration.range(pos)]\n          });\n          addedDecorations++;\n        } else if (edit.type === 'insert') {\n          // Mark decorations for additions\n          const start = edit.from;\n          const end = start + (edit.text?.length || 0);\n          \n          if (end <= tr.newDoc.length && start <= end && start >= 0) {\n            decorations = decorations.update({\n              add: [decoration.range(start, end)]\n            });\n            addedDecorations++;\n          } else {\n            DebugMonitor.log('INVALID_DECORATION_POSITION', {\n              editId: edit.id,\n              start, end,\n              docLength: tr.newDoc.length,\n              reason: 'Position out of bounds'\n            });\n          }\n        }\n      } else if (effect.is(removeDecorationEffect)) {\n        const editId = effect.value;\n        DebugMonitor.log('REMOVE_DECORATION_EFFECT', { editId });\n        \n        decorations = decorations.update({\n          filter: (from, to, decoration) => {\n            const spec = (decoration as any).spec;\n            if (spec?.attributes?.['data-edit-id'] === editId) {\n              removedDecorations++;\n              return false;\n            }\n            if (spec?.widget && spec.widget.editId === editId) {\n              removedDecorations++;\n              return false;\n            }\n            return true;\n          }\n        });\n      } else if (effect.is(clearAllDecorationsEffect)) {\n        DebugMonitor.log('CLEAR_ALL_DECORATIONS_EFFECT', { previousSize: decorations.size });\n        removedDecorations = decorations.size;\n        decorations = Decoration.none;\n      }\n    }\n    \n    const finalSize = decorations.size;\n    DebugMonitor.log('STATEFIELD_UPDATE_END', {\n      initialSize,\n      finalSize,\n      addedDecorations,\n      removedDecorations,\n      netChange: finalSize - initialSize\n    });\n    \n    DebugMonitor.endTimer(timer);\n    return decorations;\n  },\n  provide: f => EditorView.decorations.from(f)\n});\n\n// ViewPlugin for change detection\nconst changeDetectionPlugin = ViewPlugin.fromClass(class {\n  constructor(private view: EditorView) {}\n  \n  update(update: ViewUpdate) {\n    const timer = DebugMonitor.startTimer('ViewPlugin.update');\n    \n    DebugMonitor.log('UPDATE', {\n      docChanged: update.docChanged,\n      isRejectingEdit,\n      hasPluginInstance: !!currentPluginInstance,\n      changeCount: update.changes ? update.changes.desc.length : 0,\n      viewportChanged: update.viewportChanged,\n      focusChanged: update.focusChanged\n    });\n    \n    // Check if we should process changes (plugin exists, tracking enabled, not rejecting, has session)\n    const shouldProcessChanges = update.docChanged && \n                                 !isRejectingEdit && \n                                 currentPluginInstance &&\n                                 currentPluginInstance.currentSession &&\n                                 currentPluginInstance.settings.enableTracking &&\n                                 (!currentPluginInstance.toggleStateManager || \n                                  currentPluginInstance.toggleStateManager.isTrackingEnabled);\n    \n    if (shouldProcessChanges) {\n      const extractTimer = DebugMonitor.startTimer('extractEditsFromUpdate');\n      const edits = this.extractEditsFromUpdate(update);\n      DebugMonitor.endTimer(extractTimer);\n      \n      DebugMonitor.log('EDITS_EXTRACTED', {\n        editCount: edits.length,\n        edits: edits.map(e => ({ id: e.id, type: e.type, from: e.from, to: e.to, textLength: e.text?.length || 0 }))\n      });\n      \n      if (edits.length > 0) {\n        // Add decorations immediately\n        const decorationTimer = DebugMonitor.startTimer('createDecorations');\n        const decorationEffects = edits.map(edit => {\n          const decoration = createEditDecoration(edit);\n          return addDecorationEffect.of({ edit, decoration });\n        });\n        DebugMonitor.endTimer(decorationTimer);\n        \n        DebugMonitor.log('DECORATIONS_CREATED', {\n          effectCount: decorationEffects.length\n        });\n        \n        requestAnimationFrame(() => {\n          const dispatchTimer = DebugMonitor.startTimer('viewDispatch');\n          this.view.dispatch({ effects: decorationEffects });\n          DebugMonitor.endTimer(dispatchTimer);\n          \n          DebugMonitor.log('DECORATIONS_DISPATCHED', {\n            effectCount: decorationEffects.length\n          });\n        });\n        \n        // Update plugin state\n        currentPluginInstance.handleEditsFromCodeMirror(edits);\n      }\n    }\n    \n    DebugMonitor.endTimer(timer);\n  }\n  \n  extractEditsFromUpdate(update: ViewUpdate): EditChange[] {\n    const edits: EditChange[] = [];\n    \n    update.changes.iterChanges((from, to, fromB, toB, insert) => {\n      const removedText = update.startState.doc.sliceString(from, to);\n      const insertedText = insert.toString();\n      \n      // Create separate deletion and addition edits\n      if (removedText) {\n        edits.push({\n          id: generateId(),\n          type: 'delete',\n          from: from,\n          to: to,\n          text: '',\n          removedText: removedText,\n          timestamp: Date.now()\n        });\n      }\n      \n      if (insertedText) {\n        edits.push({\n          id: generateId(),\n          type: 'insert',\n          from: fromB,\n          to: toB,\n          text: insertedText,\n          removedText: '',\n          timestamp: Date.now()\n        });\n      }\n    });\n    \n    return edits;\n  }\n});\n\nexport default class TrackEditsPlugin extends Plugin {\n  settings: TrackEditsSettings;\n  editTracker: EditTracker;\n  editRenderer: EditRenderer;\n  clusterManager: EditClusterManager;\n  batchManager: ChangeBatchManager;\n  sidePanelView: EditSidePanelView | null = null;\n  toggleStateManager: ToggleStateManager | null = null;\n  // Plugin Registration System\n  private pluginRegistry: PluginRegistry | null = null;\n  private eventBusConnection: WriterrlEventBusConnection | null = null;\n  private eventPersistence: EventPersistenceManager | null = null;\n  private workflowOrchestrator: any = null; // WorkflowOrchestrator from event-coordination-patterns\n  \n  // AI Processing State Management\n  private aiProcessingStates: Map<string, AIProcessingState> = new Map();\n  private processingQueue: AIProcessingQueue = {\n    active: [],\n    pending: [],\n    completed: [],\n    failed: []\n  };\n  private processingLocks: Map<string, boolean> = new Map();\n  private securityValidator: PluginSecurityValidator | null = null;\n  private capabilityValidator: PluginCapabilityValidator | null = null;\n  currentSession: EditSession | null = null;\n  currentEdits: EditChange[] = [];\n  private currentEditorView: EditorView | null = null;\n  private ribbonIconEl: HTMLElement | null = null;\n  private debouncedSave = debounce(() => this.saveCurrentSession(), 1000);\n  private debouncedPanelUpdate = debounce(() => this.updateSidePanel(), 100);\n  private debouncedRibbonClick = debounce(() => this.handleRibbonClick(), 300);\n  private isProcessingChange = false;\n  private isRestartingSession = false;\n  private lastActiveFile: string | null = null;\n\n  async onload() {\n    await this.loadSettings();\n\n    // Set global reference for CodeMirror integration\n    currentPluginInstance = this;\n\n    this.editTracker = new EditTracker(this);\n    this.editRenderer = new EditRenderer(this);\n    this.clusterManager = new EditClusterManager(this);\n    this.batchManager = new ChangeBatchManager();\n\n    // Initialize plugin system\n    await this.initializePluginSystem();\n\n    // Initialize event bus connection\n    await this.initializeEventBusConnection();\n\n    // Initialize toggle state manager\n    this.toggleStateManager = new ToggleStateManager(this.app, (enabled) => {\n      if (enabled) {\n        this.startTracking();\n      } else {\n        this.handleToggleOff();\n      }\n    });\n\n    // Initialize global API\n    this.initializeGlobalAPI();\n\n    // Register CodeMirror extensions for native integration\n    this.registerEditorExtension([changeDetectionPlugin, editDecorationField]);\n\n    // Register remaining safe event handlers\n    this.registerSafeEventHandlers();\n    \n    // Register side panel view\n    this.registerView('track-edits-side-panel', (leaf) => new EditSidePanelView(leaf, this));\n\n    // Add commands\n    this.addCommands();\n\n    // Add settings tab\n    this.addSettingTab(new TrackEditsSettingsTab(this.app, this));\n\n    // Add ribbon icon\n    this.addRibbonIcon();\n\n    // Start tracking if enabled\n    if (this.settings.enableTracking) {\n      this.startTracking();\n    }\n\n    console.log('Track Edits v2.0 plugin loaded with Plugin Registration System');\n  }\n\n  onunload() {\n    try {\n      this.stopTracking();\n      this.cleanupGlobalAPI();\n      \n      // Clean up toggle state manager\n      if (this.toggleStateManager) {\n        this.toggleStateManager.destroy();\n        this.toggleStateManager = null;\n      }\n\n      // Clean up event bus connection\n      this.cleanupEventBusConnection();\n\n      // Clean up event persistence\n      if (this.eventPersistence) {\n        // Attempt to sync any final pending events\n        if (this.eventBusConnection?.isConnected()) {\n          this.eventPersistence.syncPendingEvents(this.eventBusConnection)\n            .catch(error => console.warn('[TrackEdits] Final event sync failed:', error));\n        }\n        this.eventPersistence = null;\n      }\n      \n      console.log('Track Edits plugin unloaded');\n    } catch (error) {\n      console.error('Track Edits: Error during plugin unload:', error);\n    }\n  }\n\n  /**\n   * Initialize the plugin registration system\n   */\n  private async initializePluginSystem(): Promise<void> {\n    try {\n      // Initialize validators\n      this.securityValidator = new PluginSecurityValidator();\n      this.capabilityValidator = new PluginCapabilityValidator();\n\n      // Initialize registry\n      this.pluginRegistry = new PluginRegistry(\n        this,\n        this.securityValidator,\n        this.capabilityValidator\n      );\n\n      // Register Editorial Engine as the first official plugin\n      await this.registerEditorialEnginePlugin();\n\n      console.log('[TrackEditsPlugin] Plugin registration system initialized');\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Failed to initialize plugin system:', error);\n      // Continue without plugin system if initialization fails\n      this.pluginRegistry = null;\n      this.securityValidator = null;\n      this.capabilityValidator = null;\n    }\n  }\n\n  /**\n   * Initialize event bus connection for cross-plugin coordination\n   */\n  private async initializeEventBusConnection(): Promise<void> {\n    try {\n      if (!this.settings.enableEventBus) {\n        console.log('[TrackEditsPlugin] Event bus integration disabled in settings');\n        return;\n      }\n\n      // Initialize event persistence first\n      this.eventPersistence = new EventPersistenceManager();\n      await this.eventPersistence.initialize();\n\n      // Create event bus connection with configuration\n      this.eventBusConnection = new WriterrlEventBusConnection({\n        maxReconnectAttempts: this.settings.eventBusMaxReconnectAttempts,\n        reconnectDelay: this.settings.eventBusReconnectDelay,\n        healthCheckInterval: 30000,\n        enableDebugMode: this.settings.eventBusDebugMode,\n        eventFilters: {\n          sourcePlugins: ['writerr-chat', 'editorial-engine', 'track-edits'],\n          eventTypes: [\n            'change.ai.start', 'change.ai.complete', 'change.ai.error',\n            'session.created', 'session.ended', 'session.paused', 'session.resumed',\n            'document.edit.start', 'document.edit.complete', 'document.focus.changed',\n            'error.plugin.failure', 'error.recovery.attempted'\n          ]\n        }\n      });\n\n      // Connect event persistence to event bus\n      if (this.eventPersistence) {\n        this.eventPersistence.setEventBus(this.eventBusConnection);\n      }\n\n      // Attempt to connect to the event bus\n      const connected = await this.eventBusConnection.connect();\n      \n      if (connected) {\n        // Set up event handlers\n        await this.setupEventBusHandlers();\n        \n        // Sync any pending events from offline periods\n        if (this.eventPersistence) {\n          try {\n            const syncResult = await this.eventPersistence.syncPendingEvents(this.eventBusConnection);\n            if (syncResult.synced > 0) {\n              console.log(`[TrackEditsPlugin] Synced ${syncResult.synced} pending events from offline period`);\n            }\n            if (syncResult.failed > 0) {\n              console.warn(`[TrackEditsPlugin] Failed to sync ${syncResult.failed} events`);\n            }\n          } catch (syncError) {\n            console.warn('[TrackEditsPlugin] Error syncing pending events:', syncError);\n          }\n        }\n        \n        console.log('[TrackEditsPlugin] Event bus integration initialized successfully');\n      } else {\n        console.log('[TrackEditsPlugin] Event bus not available - will retry on demand');\n      }\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Failed to initialize event bus connection:', error);\n      // Continue without event bus if initialization fails\n      this.eventBusConnection = null;\n    }\n  }\n\n  /**\n   * Set up event handlers for cross-plugin coordination\n   */\n  private async setupEventBusHandlers(): Promise<void> {\n    if (!this.eventBusConnection) return;\n\n    try {\n      // Subscribe to Writerr Chat session events for coordination\n      await this.eventBusConnection.subscribe(\n        'session.*',\n        this.handleChatSessionEvent.bind(this),\n        { \n          filter: (event) => event.sourcePlugin === 'writerr-chat',\n          async: true\n        }\n      );\n\n      // Subscribe to Editorial Engine processing events\n      await this.eventBusConnection.subscribe(\n        'change.*',\n        this.handleEditorialEngineEvent.bind(this),\n        { \n          filter: (event) => event.sourcePlugin === 'editorial-engine',\n          async: true\n        }\n      );\n\n      // Subscribe to AI processing events for coordination\n      await this.eventBusConnection.subscribe(\n        'ai.processing.start',\n        this.handleAIProcessingStartEvent.bind(this),\n        { async: true }\n      );\n\n      await this.eventBusConnection.subscribe(\n        'ai.processing.progress',\n        this.handleAIProcessingProgressEvent.bind(this),\n        { async: true }\n      );\n\n      await this.eventBusConnection.subscribe(\n        'ai.processing.complete',\n        this.handleAIProcessingCompleteEvent.bind(this),\n        { async: true }\n      );\n\n      await this.eventBusConnection.subscribe(\n        'ai.processing.error',\n        this.handleAIProcessingErrorEvent.bind(this),\n        { async: true }\n      );\n\n      // Subscribe to document focus changes for multi-plugin editing coordination\n      await this.eventBusConnection.subscribe(\n        'document.*',\n        this.handleDocumentEvent.bind(this),\n        { async: true }\n      );\n\n      // Subscribe to error events for platform-wide error handling\n      await this.eventBusConnection.subscribe(\n        'error.*',\n        this.handleErrorEvent.bind(this),\n        { async: true }\n      );\n\n      console.log('[TrackEditsPlugin] Event bus handlers configured with AI processing support');\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Failed to setup event bus handlers:', error);\n    }\n  }\n\n  /**\n   * Handle Writerr Chat session events for coordination\n   */\n  private async handleChatSessionEvent(event: WriterrlEvent): Promise<void> {\n    try {\n      if (this.settings.eventBusDebugMode) {\n        console.log('[TrackEdits EventBus] Chat session event:', event);\n      }\n\n      switch (event.type) {\n        case 'session.created':\n          // Start tracking when chat session begins\n          if (!this.currentSession && this.settings.enableTracking) {\n            console.log('[TrackEdits] Starting tracking in response to chat session');\n            this.startTracking();\n          }\n          break;\n\n        case 'session.ended':\n          // Optionally stop tracking or save session when chat ends\n          if (this.currentSession && this.settings.autoSave) {\n            await this.saveCurrentSession();\n          }\n          break;\n      }\n    } catch (error) {\n      console.error('[TrackEdits EventBus] Error handling chat session event:', error);\n    }\n  }\n\n  /**\n   * Handle Editorial Engine processing events\n   */\n  private async handleEditorialEngineEvent(event: WriterrlEvent): Promise<void> {\n    try {\n      if (this.settings.eventBusDebugMode) {\n        console.log('[TrackEdits EventBus] Editorial Engine event:', event);\n      }\n\n      switch (event.type) {\n        case 'change.ai.start':\n          // Pause edit tracking during AI processing to avoid interference\n          if (this.toggleStateManager && this.toggleStateManager.isTrackingEnabled) {\n            this.isProcessingChange = true;\n            console.log('[TrackEdits] Pausing change detection during Editorial Engine processing');\n          }\n          break;\n\n        case 'change.ai.complete':\n          // Resume edit tracking and sync with Editorial Engine changes\n          this.isProcessingChange = false;\n          const changeEvent = event as WriterrlChangeEvent;\n          \n          // If we have change IDs, try to reconcile with our tracking\n          if (changeEvent.payload.changeIds && this.currentSession) {\n            console.log('[TrackEdits] Syncing with Editorial Engine changes:', changeEvent.payload.changeIds);\n            // Additional sync logic would go here\n          }\n          break;\n\n        case 'change.ai.error':\n          // Resume tracking on error\n          this.isProcessingChange = false;\n          console.log('[TrackEdits] Resuming tracking after Editorial Engine error');\n          break;\n      }\n    } catch (error) {\n      console.error('[TrackEdits EventBus] Error handling Editorial Engine event:', error);\n    }\n  }\n\n  /**\n   * Handle document events for multi-plugin editing coordination\n   */\n  private async handleDocumentEvent(event: WriterrlEvent): Promise<void> {\n    try {\n      if (this.settings.eventBusDebugMode) {\n        console.log('[TrackEdits EventBus] Document event:', event);\n      }\n\n      const docEvent = event as WriterrlDocumentEvent;\n      \n      switch (event.type) {\n        case 'document.focus.changed':\n          // Switch tracking context when document changes\n          if (docEvent.payload.documentPath && docEvent.payload.documentPath !== this.lastActiveFile) {\n            this.lastActiveFile = docEvent.payload.documentPath;\n            \n            // Restart session for new document if tracking is active\n            if (this.currentSession && this.settings.enableTracking) {\n              await this.restartSession();\n            }\n          }\n          break;\n\n        case 'document.save.before':\n          // Save current tracking session before document save\n          if (this.currentSession && this.settings.autoSave) {\n            await this.saveCurrentSession();\n          }\n          break;\n      }\n    } catch (error) {\n      console.error('[TrackEdits EventBus] Error handling document event:', error);\n    }\n  }\n\n  /**\n   * Handle error events for platform-wide error coordination\n   */\n  private async handleErrorEvent(event: WriterrlEvent): Promise<void> {\n    try {\n      if (this.settings.eventBusDebugMode) {\n        console.log('[TrackEdits EventBus] Error event:', event);\n      }\n\n      const errorEvent = event as WriterrlErrorEvent;\n      \n      switch (event.type) {\n        case 'error.plugin.failure':\n          // Handle plugin failures that might affect Track Edits\n          if (errorEvent.payload.affectedFeatures.includes('editing') || \n              errorEvent.payload.affectedFeatures.includes('tracking')) {\n            \n            if (errorEvent.payload.severity === 'critical') {\n              // Stop tracking on critical errors affecting editing\n              this.stopTracking();\n              console.log('[TrackEdits] Stopped tracking due to critical system error');\n            } else {\n              // For non-critical errors, just log and continue\n              console.warn('[TrackEdits] System error detected, continuing with caution:', errorEvent.payload.errorMessage);\n            }\n          }\n          break;\n\n        case 'error.recovery.attempted':\n          // Monitor recovery attempts and restart tracking if needed\n          if (errorEvent.payload.recoveryAction === 'restart_tracking' && this.settings.enableTracking) {\n            console.log('[TrackEdits] Restarting tracking after error recovery');\n            this.startTracking();\n          }\n          break;\n      }\n    } catch (error) {\n      console.error('[TrackEdits EventBus] Error handling error event:', error);\n    }\n  }\n\n  // AI Processing Event Handlers\n  private async handleAIProcessingStartEvent(event: any): Promise<void> {\n    try {\n      const startEvent = event as any; // Type will be AIProcessingStartEvent\n      const { requestId, operation, input, config, pluginContext } = startEvent.payload;\n\n      console.log(`[TrackEditsPlugin] AI processing started: ${requestId} from ${pluginContext.sourcePluginId}`);\n\n      // Create processing state\n      const processingState: AIProcessingState = {\n        requestId,\n        operation: {\n          type: operation.type,\n          provider: operation.provider,\n          model: operation.model,\n          startTime: Date.now()\n        },\n        input: {\n          documentId: input.documentId,\n          content: input.content,\n          userPrompt: input.userPrompt,\n          constraints: input.constraints\n        },\n        status: 'preparing',\n        progress: {\n          percentage: 0,\n          stage: 'initializing',\n          estimatedTimeRemaining: config.expectedDuration\n        },\n        sourcePlugin: pluginContext.sourcePluginId,\n        sessionId: startEvent.sessionId\n      };\n\n      // Add to processing state management\n      this.aiProcessingStates.set(requestId, processingState);\n      this.processingQueue.active.push(processingState);\n\n      // Prepare Track Edits for incoming changes\n      await this.prepareForAIProcessing(processingState);\n\n      // Update UI to show processing state\n      await this.updateProcessingUI(processingState);\n\n      // Coordinate with session management\n      if (processingState.sessionId) {\n        const session = this.editTracker.getSession(processingState.sessionId);\n        if (session) {\n          // Mark session as having active AI processing\n          session.metadata = {\n            ...session.metadata,\n            activeAIProcessing: requestId,\n            aiProvider: operation.provider,\n            aiModel: operation.model\n          };\n        }\n      }\n\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error handling AI processing start event:', error);\n      await this.publishErrorEvent('error.ai.processing.handler', {\n        message: 'Failed to handle AI processing start event',\n        error: error.message,\n        context: { eventType: 'ai.processing.start' }\n      });\n    }\n  }\n\n  private async handleAIProcessingProgressEvent(event: any): Promise<void> {\n    try {\n      const progressEvent = event as any; // Type will be AIProcessingProgressEvent\n      const { requestId, progress, partialResults, metrics } = progressEvent.payload;\n\n      const processingState = this.aiProcessingStates.get(requestId);\n      if (!processingState) {\n        console.warn(`[TrackEditsPlugin] Progress event for unknown request: ${requestId}`);\n        return;\n      }\n\n      // Update processing state\n      processingState.status = 'processing';\n      processingState.progress = {\n        percentage: progress.percentage,\n        stage: progress.stage,\n        estimatedTimeRemaining: progress.estimatedTimeRemaining,\n        currentOperation: progress.currentOperation\n      };\n      \n      if (metrics) {\n        processingState.metrics = {\n          tokensProcessed: metrics.tokensProcessed,\n          responseTime: metrics.responseTime,\n          memoryUsage: metrics.memoryUsage\n        };\n      }\n\n      // Update UI with progress\n      await this.updateProcessingProgress(processingState, partialResults);\n\n      // Handle partial results if available\n      if (partialResults?.previewChanges && partialResults.previewChanges.length > 0) {\n        await this.handlePartialResults(processingState, partialResults.previewChanges);\n      }\n\n      console.log(`[TrackEditsPlugin] AI processing progress: ${requestId} - ${progress.percentage}% (${progress.stage})`);\n\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error handling AI processing progress event:', error);\n    }\n  }\n\n  private async handleAIProcessingCompleteEvent(event: any): Promise<void> {\n    try {\n      const completeEvent = event as any; // Type will be AIProcessingCompleteEvent\n      const { requestId, results, metrics, recommendations } = completeEvent.payload;\n\n      const processingState = this.aiProcessingStates.get(requestId);\n      if (!processingState) {\n        console.warn(`[TrackEditsPlugin] Complete event for unknown request: ${requestId}`);\n        return;\n      }\n\n      // Update processing state\n      processingState.status = 'completed';\n      processingState.progress.percentage = 100;\n      processingState.progress.stage = 'completed';\n      \n      if (metrics) {\n        processingState.metrics = {\n          tokensProcessed: metrics.totalTokens,\n          responseTime: metrics.processingTime,\n          memoryUsage: processingState.metrics?.memoryUsage || 0\n        };\n      }\n\n      // Move from active to completed queue\n      const activeIndex = this.processingQueue.active.findIndex(state => state.requestId === requestId);\n      if (activeIndex !== -1) {\n        this.processingQueue.active.splice(activeIndex, 1);\n        this.processingQueue.completed.push(processingState);\n      }\n\n      // Coordinate change recording\n      await this.coordinateChangeRecording(processingState, results);\n\n      // Update session if applicable\n      if (processingState.sessionId) {\n        const session = this.editTracker.getSession(processingState.sessionId);\n        if (session && session.metadata?.activeAIProcessing === requestId) {\n          delete session.metadata.activeAIProcessing;\n          session.metadata.lastAIOperation = {\n            requestId,\n            completedAt: Date.now(),\n            changeIds: results.changeIds,\n            metrics: processingState.metrics\n          };\n        }\n      }\n\n      // Handle recommendations\n      if (recommendations) {\n        await this.handleProcessingRecommendations(processingState, recommendations);\n      }\n\n      // Update UI to show completion\n      await this.updateProcessingCompletion(processingState, results);\n\n      // Clean up processing locks\n      this.processingLocks.delete(requestId);\n\n      console.log(`[TrackEditsPlugin] AI processing completed: ${requestId} - ${results.changeIds.length} changes`);\n\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error handling AI processing complete event:', error);\n      await this.publishErrorEvent('error.ai.processing.complete', {\n        message: 'Failed to handle AI processing complete event',\n        error: error.message,\n        context: { requestId: event.payload?.requestId }\n      });\n    }\n  }\n\n  private async handleAIProcessingErrorEvent(event: any): Promise<void> {\n    try {\n      const errorEvent = event as any; // Type will be AIProcessingErrorEvent\n      const { requestId, error, context, recovery } = errorEvent.payload;\n\n      const processingState = this.aiProcessingStates.get(requestId);\n      if (!processingState) {\n        console.warn(`[TrackEditsPlugin] Error event for unknown request: ${requestId}`);\n        return;\n      }\n\n      // Update processing state\n      processingState.status = 'error';\n      processingState.errorDetails = {\n        type: error.type,\n        message: error.message,\n        recoverable: error.recoverability === 'recoverable'\n      };\n\n      // Move from active to failed queue\n      const activeIndex = this.processingQueue.active.findIndex(state => state.requestId === requestId);\n      if (activeIndex !== -1) {\n        this.processingQueue.active.splice(activeIndex, 1);\n        this.processingQueue.failed.push(processingState);\n      }\n\n      // Handle error recovery\n      await this.handleProcessingError(processingState, error, context, recovery);\n\n      // Update session if applicable\n      if (processingState.sessionId) {\n        const session = this.editTracker.getSession(processingState.sessionId);\n        if (session && session.metadata?.activeAIProcessing === requestId) {\n          delete session.metadata.activeAIProcessing;\n          session.metadata.lastAIError = {\n            requestId,\n            errorAt: Date.now(),\n            error: error.message,\n            recoverable: processingState.errorDetails.recoverable\n          };\n        }\n      }\n\n      // Update UI to show error state\n      await this.updateProcessingError(processingState);\n\n      // Clean up processing locks\n      this.processingLocks.delete(requestId);\n\n      console.error(`[TrackEditsPlugin] AI processing failed: ${requestId} - ${error.message}`);\n\n    } catch (handlerError) {\n      console.error('[TrackEditsPlugin] Error handling AI processing error event:', handlerError);\n    }\n  }\n\n  // AI Processing Coordination Methods\n  private async prepareForAIProcessing(processingState: AIProcessingState): Promise<void> {\n    try {\n      // Set processing lock to prevent conflicts\n      this.processingLocks.set(processingState.requestId, true);\n\n      // Prepare batch manager for incoming changes\n      if (this.batchManager) {\n        await this.batchManager.prepareForAIBatch(processingState.requestId, {\n          expectedChanges: processingState.input.content.length > 1000 ? 10 : 5,\n          provider: processingState.operation.provider,\n          model: processingState.operation.model,\n          operationType: processingState.operation.type\n        });\n      }\n\n      // Clear any conflicting decorations\n      if (this.currentEditorView) {\n        this.removeDecorationsFromView(this.currentEditorView);\n      }\n\n      // Notify other systems of preparation\n      console.log(`[TrackEditsPlugin] Prepared for AI processing: ${processingState.requestId}`);\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error preparing for AI processing:', error);\n      throw error;\n    }\n  }\n\n  private async updateProcessingUI(processingState: AIProcessingState): Promise<void> {\n    try {\n      // Update side panel with processing status\n      if (this.sidePanelView) {\n        this.sidePanelView.updateProcessingStatus({\n          requestId: processingState.requestId,\n          status: processingState.status,\n          progress: processingState.progress,\n          sourcePlugin: processingState.sourcePlugin\n        });\n      }\n\n      // Update ribbon icon to show processing\n      this.updateRibbonIcon();\n\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error updating processing UI:', error);\n    }\n  }\n\n  private async updateProcessingProgress(processingState: AIProcessingState, partialResults?: any): Promise<void> {\n    try {\n      // Update UI with current progress\n      if (this.sidePanelView) {\n        this.sidePanelView.updateProcessingProgress({\n          requestId: processingState.requestId,\n          progress: processingState.progress,\n          metrics: processingState.metrics,\n          partialResults: partialResults\n        });\n      }\n\n      // Show progress in status bar or notification if significant progress\n      if (processingState.progress.percentage >= 50 && processingState.progress.percentage % 25 === 0) {\n        console.log(`[TrackEditsPlugin] Processing ${processingState.progress.percentage}% complete: ${processingState.progress.stage}`);\n      }\n\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error updating processing progress:', error);\n    }\n  }\n\n  private async handlePartialResults(processingState: AIProcessingState, previewChanges: any[]): Promise<void> {\n    try {\n      // Show preview of changes in UI without applying them\n      if (this.sidePanelView && previewChanges.length > 0) {\n        this.sidePanelView.showChangePreview({\n          requestId: processingState.requestId,\n          previewChanges: previewChanges,\n          stage: processingState.progress.stage\n        });\n      }\n\n      console.log(`[TrackEditsPlugin] Received ${previewChanges.length} preview changes for ${processingState.requestId}`);\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error handling partial results:', error);\n    }\n  }\n\n  private async coordinateChangeRecording(processingState: AIProcessingState, results: any): Promise<void> {\n    try {\n      // Record the AI operation in the session\n      if (processingState.sessionId && results.changeIds.length > 0) {\n        const session = this.editTracker.getSession(processingState.sessionId);\n        if (session) {\n          // Create AI processing record\n          const aiProcessingRecord = {\n            requestId: processingState.requestId,\n            operationType: processingState.operation.type,\n            provider: processingState.operation.provider,\n            model: processingState.operation.model,\n            changeIds: results.changeIds,\n            confidence: results.confidence,\n            appliedConstraints: results.appliedConstraints,\n            processingTime: processingState.metrics?.responseTime || 0,\n            completedAt: Date.now()\n          };\n\n          // Add to session metadata\n          session.metadata = {\n            ...session.metadata,\n            aiProcessingHistory: [\n              ...(session.metadata?.aiProcessingHistory || []),\n              aiProcessingRecord\n            ]\n          };\n        }\n      }\n\n      // Handle change grouping if specified\n      if (results.changeGroupId && this.batchManager) {\n        await this.batchManager.finalizeAIBatch(processingState.requestId, {\n          changeGroupId: results.changeGroupId,\n          changeIds: results.changeIds,\n          confidence: results.confidence\n        });\n      }\n\n      console.log(`[TrackEditsPlugin] Coordinated recording of ${results.changeIds.length} changes for ${processingState.requestId}`);\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error coordinating change recording:', error);\n      throw error;\n    }\n  }\n\n  private async handleProcessingRecommendations(processingState: AIProcessingState, recommendations: any): Promise<void> {\n    try {\n      // Handle review recommendations\n      if (recommendations.suggestedReview && this.sidePanelView) {\n        this.sidePanelView.highlightForReview({\n          requestId: processingState.requestId,\n          reason: 'AI processing recommends review',\n          priority: 'medium'\n        });\n      }\n\n      // Handle batching recommendations\n      if (recommendations.recommendedBatching && this.batchManager) {\n        await this.batchManager.applyBatchingRecommendation(\n          processingState.requestId,\n          recommendations.recommendedBatching\n        );\n      }\n\n      // Handle follow-up actions\n      if (recommendations.followupActions && recommendations.followupActions.length > 0) {\n        console.log(`[TrackEditsPlugin] Follow-up actions recommended for ${processingState.requestId}:`, recommendations.followupActions);\n      }\n\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error handling processing recommendations:', error);\n    }\n  }\n\n  private async updateProcessingCompletion(processingState: AIProcessingState, results: any): Promise<void> {\n    try {\n      // Update UI to show completion\n      if (this.sidePanelView) {\n        this.sidePanelView.updateProcessingCompletion({\n          requestId: processingState.requestId,\n          results: results,\n          metrics: processingState.metrics,\n          duration: Date.now() - processingState.operation.startTime\n        });\n      }\n\n      // Update ribbon icon back to normal\n      this.updateRibbonIcon();\n\n      // Show completion notification if significant operation\n      if (results.changeIds.length > 5) {\n        console.log(`[TrackEditsPlugin] AI processing completed: ${results.changeIds.length} changes applied with ${results.confidence}% confidence`);\n      }\n\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error updating processing completion:', error);\n    }\n  }\n\n  private async handleProcessingError(processingState: AIProcessingState, error: any, context: any, recovery: any): Promise<void> {\n    try {\n      // Handle recoverable errors\n      if (error.recoverability === 'recoverable' && recovery.automaticRetryAvailable) {\n        console.log(`[TrackEditsPlugin] Recoverable error for ${processingState.requestId}, retry may be available`);\n        \n        // Mark for potential retry (don't automatically retry from Track Edits)\n        processingState.status = 'preparing';\n        return;\n      }\n\n      // Handle non-recoverable errors\n      if (recovery.manualInterventionRequired) {\n        console.error(`[TrackEditsPlugin] Manual intervention required for ${processingState.requestId}: ${error.message}`);\n        \n        // Notify user of manual intervention need\n        if (this.sidePanelView) {\n          this.sidePanelView.showManualInterventionRequired({\n            requestId: processingState.requestId,\n            error: error.message,\n            suggestedActions: recovery.suggestedActions\n          });\n        }\n      }\n\n      // Clean up any partial state\n      if (context.partialResults && this.batchManager) {\n        await this.batchManager.cleanupFailedBatch(processingState.requestId);\n      }\n\n      // Record error for debugging\n      console.error(`[TrackEditsPlugin] Processing error handled for ${processingState.requestId}:`, {\n        error: error.message,\n        stage: context.stage,\n        recoverable: error.recoverability === 'recoverable'\n      });\n\n    } catch (handlerError) {\n      console.error('[TrackEditsPlugin] Error handling processing error:', handlerError);\n    }\n  }\n\n  private async updateProcessingError(processingState: AIProcessingState): Promise<void> {\n    try {\n      // Update UI to show error state\n      if (this.sidePanelView) {\n        this.sidePanelView.updateProcessingError({\n          requestId: processingState.requestId,\n          error: processingState.errorDetails,\n          duration: Date.now() - processingState.operation.startTime\n        });\n      }\n\n      // Update ribbon icon back to normal\n      this.updateRibbonIcon();\n\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error updating processing error UI:', error);\n    }\n  }\n\n  // Processing State Management Utilities\n  public getActiveProcessingOperations(): AIProcessingState[] {\n    return Array.from(this.aiProcessingStates.values()).filter(state => \n      state.status === 'processing' || state.status === 'preparing'\n    );\n  }\n\n  public getProcessingState(requestId: string): AIProcessingState | undefined {\n    return this.aiProcessingStates.get(requestId);\n  }\n\n  public isProcessingActive(requestId?: string): boolean {\n    if (requestId) {\n      const state = this.aiProcessingStates.get(requestId);\n      return state?.status === 'processing' || state?.status === 'preparing';\n    }\n    return this.getActiveProcessingOperations().length > 0;\n  }\n\n  public cancelProcessing(requestId: string): boolean {\n    const state = this.aiProcessingStates.get(requestId);\n    if (state && (state.status === 'processing' || state.status === 'preparing')) {\n      state.status = 'cancelled';\n      \n      // Move from active to failed queue\n      const activeIndex = this.processingQueue.active.findIndex(s => s.requestId === requestId);\n      if (activeIndex !== -1) {\n        this.processingQueue.active.splice(activeIndex, 1);\n        this.processingQueue.failed.push(state);\n      }\n      \n      this.processingLocks.delete(requestId);\n      console.log(`[TrackEditsPlugin] Cancelled processing: ${requestId}`);\n      return true;\n    }\n    return false;\n  }\n\n  private async waitForProcessingCompletion(requestId: string, timeoutMs: number): Promise<SubmitChangesFromAIResult> {\n    const startTime = Date.now();\n    const checkInterval = 1000; // Check every second\n\n    return new Promise((resolve) => {\n      const checkCompletion = () => {\n        const processingState = this.aiProcessingStates.get(requestId);\n        \n        if (!processingState) {\n          resolve({\n            success: false,\n            changeIds: [],\n            errors: ['Processing state not found'],\n            warnings: []\n          });\n          return;\n        }\n\n        if (processingState.status === 'completed') {\n          // Extract results from processing state\n          resolve({\n            success: true,\n            changeIds: [], // Would be populated from actual results\n            errors: [],\n            warnings: [`Coordinated with completed operation: ${requestId}`]\n          });\n          return;\n        }\n\n        if (processingState.status === 'error' || processingState.status === 'cancelled') {\n          resolve({\n            success: false,\n            changeIds: [],\n            errors: [processingState.errorDetails?.message || 'Processing failed'],\n            warnings: []\n          });\n          return;\n        }\n\n        if (Date.now() - startTime > timeoutMs) {\n          resolve({\n            success: false,\n            changeIds: [],\n            errors: ['Coordination timeout'],\n            warnings: [`Processing still active after ${timeoutMs}ms`]\n          });\n          return;\n        }\n\n        // Continue checking\n        setTimeout(checkCompletion, checkInterval);\n      };\n\n      checkCompletion();\n    });\n  }\n\n  private async publishAIProcessingStartEvent(payload: any, sessionId?: string): Promise<void> {\n    try {\n      if (!this.eventBusConnection) return;\n\n      await this.eventBusConnection.publish({\n        type: 'ai.processing.start',\n        sourcePlugin: 'track-edits',\n        targetPlugin: '*',\n        timestamp: Date.now(),\n        sessionId,\n        schemaVersion: '2.0.0',\n        payload\n      });\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error publishing AI processing start event:', error);\n    }\n  }\n\n  private async publishAIProcessingProgressEvent(requestId: string, progress: any, partialResults?: any, metrics?: any): Promise<void> {\n    try {\n      if (!this.eventBusConnection) return;\n\n      await this.eventBusConnection.publish({\n        type: 'ai.processing.progress',\n        sourcePlugin: 'track-edits',\n        targetPlugin: '*',\n        timestamp: Date.now(),\n        schemaVersion: '2.0.0',\n        payload: {\n          requestId,\n          progress,\n          partialResults,\n          metrics\n        }\n      });\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error publishing AI processing progress event:', error);\n    }\n  }\n\n  private async publishAIProcessingCompleteEvent(payload: any, sessionId?: string): Promise<void> {\n    try {\n      if (!this.eventBusConnection) return;\n\n      await this.eventBusConnection.publish({\n        type: 'ai.processing.complete',\n        sourcePlugin: 'track-edits',\n        targetPlugin: '*',\n        timestamp: Date.now(),\n        sessionId,\n        schemaVersion: '2.0.0',\n        payload\n      });\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error publishing AI processing complete event:', error);\n    }\n  }\n\n  private async publishAIProcessingErrorEvent(requestId: string, errorType: string, message: string, context?: any, recovery?: any): Promise<void> {\n    try {\n      if (!this.eventBusConnection) return;\n\n      await this.eventBusConnection.publish({\n        type: 'ai.processing.error',\n        sourcePlugin: 'track-edits',\n        targetPlugin: '*',\n        timestamp: Date.now(),\n        schemaVersion: '2.0.0',\n        payload: {\n          requestId,\n          error: {\n            type: errorType,\n            message,\n            code: errorType.toUpperCase(),\n            recoverability: recovery ? 'recoverable' : 'non-recoverable'\n          },\n          context: context || {\n            stage: 'unknown',\n            partialResults: [],\n            resourceUsage: {}\n          },\n          recovery: recovery || {\n            automaticRetryAvailable: false,\n            manualInterventionRequired: true,\n            suggestedActions: ['Check logs', 'Retry operation'],\n            fallbackOptions: []\n          }\n        }\n      });\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error publishing AI processing error event:', error);\n    }\n  }\n\n  /**\n   * Publish a change event through the event bus\n   */\n  private async publishChangeEvent(\n    type: WriterrlChangeEvent['type'],\n    payload: WriterrlChangeEvent['payload'],\n    sessionId?: string,\n    documentId?: string\n  ): Promise<void> {\n    try {\n      const event = EventBusUtils.createChangeEvent(\n        type,\n        'track-edits',\n        payload,\n        sessionId || this.currentSession?.id,\n        documentId || this.app.workspace.getActiveFile()?.path,\n        ['writerr-chat', 'editorial-engine']\n      );\n\n      // Try to publish via event bus first\n      if (this.eventBusConnection && this.eventBusConnection.isConnected()) {\n        await this.eventBusConnection.publish(type, event, {\n          persistent: type === 'change.ai.complete' || type === 'change.ai.error'\n        });\n      } else if (this.eventPersistence) {\n        // Store for offline synchronization if event bus not available\n        await this.eventPersistence.storeEventSafe({\n          type,\n          data: event,\n          timestamp: new Date(),\n          eventId: `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n        });\n        console.log(`[TrackEdits] Event stored for offline sync: ${type}`);\n      }\n    } catch (error) {\n      console.error('[TrackEdits EventBus] Failed to publish change event:', error);\n    }\n  }\n\n  /**\n   * Publish a session event through the event bus\n   */\n  private async publishSessionEvent(\n    type: WriterrlSessionEvent['type'],\n    payload: WriterrlSessionEvent['payload'],\n    sessionId?: string,\n    documentId?: string\n  ): Promise<void> {\n    try {\n      const event = EventBusUtils.createSessionEvent(\n        type,\n        'track-edits',\n        payload,\n        sessionId || this.currentSession?.id,\n        documentId || this.app.workspace.getActiveFile()?.path,\n        ['writerr-chat', 'editorial-engine']\n      );\n\n      // Try to publish via event bus first\n      if (this.eventBusConnection && this.eventBusConnection.isConnected()) {\n        await this.eventBusConnection.publish(type, event, {\n          persistent: true\n        });\n      } else if (this.eventPersistence) {\n        // Store for offline synchronization if event bus not available\n        await this.eventPersistence.storeEventSafe({\n          type,\n          data: event,\n          timestamp: new Date(),\n          eventId: `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n        });\n        console.log(`[TrackEdits] Session event stored for offline sync: ${type}`);\n      }\n    } catch (error) {\n      console.error('[TrackEdits EventBus] Failed to publish session event:', error);\n    }\n  }\n\n  /**\n   * Publish an error event through the event bus\n   */\n  private async publishErrorEvent(\n    type: WriterrlErrorEvent['type'],\n    payload: WriterrlErrorEvent['payload'],\n    sessionId?: string,\n    documentId?: string\n  ): Promise<void> {\n    try {\n      const event = EventBusUtils.createErrorEvent(\n        type,\n        'track-edits',\n        payload,\n        sessionId || this.currentSession?.id,\n        documentId || this.app.workspace.getActiveFile()?.path,\n        ['writerr-chat', 'editorial-engine']\n      );\n\n      // Try to publish via event bus first\n      if (this.eventBusConnection && this.eventBusConnection.isConnected()) {\n        await this.eventBusConnection.publish(type, event, {\n          persistent: payload.severity === 'critical' || payload.severity === 'high'\n        });\n      } else if (this.eventPersistence) {\n        // Store for offline synchronization if event bus not available\n        await this.eventPersistence.storeEventSafe({\n          type,\n          data: event,\n          timestamp: new Date(),\n          eventId: `${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n        });\n        console.log(`[TrackEdits] Error event stored for offline sync: ${type}`);\n      }\n    } catch (error) {\n      console.error('[TrackEdits EventBus] Failed to publish error event:', error);\n    }\n  }\n\n  /**\n   * Clean up event bus connection and resources\n   */\n  private async cleanupEventBusConnection(): Promise<void> {\n    try {\n      if (this.eventBusConnection) {\n        await this.eventBusConnection.disconnect();\n        this.eventBusConnection = null;\n        console.log('[TrackEditsPlugin] Event bus connection cleaned up');\n      }\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Error during event bus cleanup:', error);\n    }\n  }\n\n  /**\n   * Register the Editorial Engine as a built-in plugin\n   */\n  private async registerEditorialEnginePlugin(): Promise<void> {\n    if (!this.pluginRegistry) return;\n\n    // Create Editorial Engine plugin wrapper\n    const editorialEnginePlugin: IAIProcessingPlugin = new EditorialEnginePluginWrapper();\n\n    try {\n      const result = await this.pluginRegistry.registerPlugin(editorialEnginePlugin, {\n        validateCodeSignature: false, // Built-in plugin, no signature needed\n        allowNetworkAccess: true,\n        allowStorageAccess: true,\n        maxMemoryUsage: 100 * 1024 * 1024, // 100MB\n        rateLimitConfig: {\n          requestsPerMinute: 120,\n          requestsPerHour: 3600,\n          burstLimit: 20,\n          cooldownPeriod: 500\n        },\n        sandboxEnabled: false // Built-in plugin, trusted\n      });\n\n      if (result.success) {\n        console.log('[TrackEditsPlugin] Editorial Engine plugin registered successfully');\n      } else {\n        console.warn('[TrackEditsPlugin] Editorial Engine plugin registration failed:', result.errors);\n      }\n    } catch (error) {\n      console.error('[TrackEditsPlugin] Editorial Engine plugin registration error:', error);\n    }\n  }\n\n  /**\n   * Public API for registering AI processing plugins\n   */\n  public async registerAIProcessingPlugin(plugin: IAIProcessingPlugin): Promise<PluginRegistrationResult> {\n    if (!this.pluginRegistry) {\n      return {\n        success: false,\n        pluginId: '',\n        authToken: '',\n        permissions: [],\n        errors: ['Plugin registration system not initialized'],\n        warnings: [],\n        expiresAt: new Date()\n      };\n    }\n\n    return await this.pluginRegistry.registerPlugin(plugin);\n  }\n\n  /**\n   * Public API for unregistering plugins\n   */\n  public async unregisterAIProcessingPlugin(pluginId: string, reason?: string): Promise<boolean> {\n    if (!this.pluginRegistry) {\n      return false;\n    }\n\n    return await this.pluginRegistry.unregisterPlugin(pluginId, reason);\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  public getRegisteredPlugins(): IAIProcessingPlugin[] {\n    if (!this.pluginRegistry) {\n      return [];\n    }\n\n    return this.pluginRegistry.getPlugins();\n  }\n\n  /**\n   * Get plugin by ID\n   */\n  public getRegisteredPlugin(pluginId: string): IAIProcessingPlugin | undefined {\n    if (!this.pluginRegistry) {\n      return undefined;\n    }\n\n    return this.pluginRegistry.getPlugin(pluginId);\n  }\n\n  async loadSettings() {\n    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\n  }\n\n  async saveSettings() {\n    await this.saveData(this.settings);\n  }\n\n  private initializeGlobalAPI() {\n    if (!window.WriterrlAPI) {\n      window.WriterrlAPI = {} as WriterrlGlobalAPI;\n    }\n\n    window.WriterrlAPI.trackEdits = {\n      getCurrentSession: () => this.currentSession,\n      getSessionHistory: () => this.editTracker.getSessionHistory(),\n      startTracking: () => this.startTracking(),\n      stopTracking: () => this.stopTracking(),\n      exportSession: (sessionId: string) => this.exportSession(sessionId)\n    };\n\n    // Initialize the plugin API for external plugin integration\n    initializeTrackEditsPluginAPI(this);\n  }\n\n  private cleanupGlobalAPI() {\n    if (window.WriterrlAPI && window.WriterrlAPI.trackEdits) {\n      delete window.WriterrlAPI.trackEdits;\n    }\n\n    // Cleanup the plugin API\n    cleanupTrackEditsPluginAPI();\n  }\n\n  private registerSafeEventHandlers() {\n    console.log('[Track Edits DEBUG] Registering event handlers');\n    \n    // CodeMirror ViewPlugin handles edit detection - no need for editor-change events\n    \n    // Handle active leaf changes with proper session state checking\n    this.registerEvent(\n      this.app.workspace.on('active-leaf-change', () => {\n        if (this.isRestartingSession) return; // Prevent recursion during restart\n        if (!this.settings || !this.settings.enableTracking) return;\n        \n        const activeFile = this.app.workspace.getActiveFile();\n        const currentFilePath = activeFile?.path || null;\n        \n        // Only restart if we actually switched to a different file AND we have a session AND it's a real file change\n        if (this.currentSession && \n            this.lastActiveFile !== currentFilePath && \n            this.lastActiveFile !== null && // Don't restart on initial load\n            currentFilePath !== null) { // Don't restart when closing files\n          \n          console.log('Track Edits: File changed from', this.lastActiveFile, 'to', currentFilePath);\n          this.lastActiveFile = currentFilePath;\n          this.restartSession();\n        } else if (!this.currentSession && \n                   activeFile && \n                   currentFilePath !== this.lastActiveFile && \n                   !this.isRestartingSession) {\n          // Start tracking if no session exists and we have a file (but not during ribbon operations)\n          console.log('Track Edits: Starting new session for file:', currentFilePath);\n          this.lastActiveFile = currentFilePath;\n          this.startTracking();\n        }\n      })\n    );\n  }\n  \n  private handleEditorChange(editor: Editor, info: MarkdownView | any) {\n    console.log('[Track Edits DEBUG] handleEditorChange called');\n    console.log('[Track Edits DEBUG] Editor:', editor);\n    console.log('[Track Edits DEBUG] Info:', info);\n    console.log('[Track Edits DEBUG] Current session:', this.currentSession);\n    console.log('[Track Edits DEBUG] Settings enableTracking:', this.settings.enableTracking);\n    \n    const changes = this.extractChangesFromEditor(editor);\n    console.log('[Track Edits DEBUG] Extracted changes:', changes);\n    \n    if (changes.length === 0) {\n      console.log('[Track Edits DEBUG] No changes detected, returning early');\n      return;\n    }\n    \n    console.log('Track Edits v2.0: Recording', changes.length, 'changes');\n    \n    // Add to current edits array for clustering\n    this.currentEdits.push(...changes);\n    console.log('[Track Edits DEBUG] Current edits array length:', this.currentEdits.length);\n    \n    // Immediate decoration rendering\n    console.log('[Track Edits DEBUG] About to call showChangeDecorations');\n    this.editRenderer.showChangeDecorations(changes);\n    console.log('[Track Edits DEBUG] Called showChangeDecorations');\n    \n    // Record changes in tracker\n    this.editTracker.recordChanges(this.currentSession.id, changes);\n    \n    // Batched side panel update\n    this.debouncedPanelUpdate();\n    \n    // Save session\n    this.debouncedSave();\n  }\n  \n  private updateSidePanel() {\n    if (this.sidePanelView) {\n      const clusters = this.clusterManager.clusterEdits(this.currentEdits);\n      this.sidePanelView.updateClusters(clusters);\n    }\n  }\n\n  private extractChangesFromEditor(editor: Editor): EditChange[] {\n    console.log('[Track Edits DEBUG] extractChangesFromEditor called');\n    \n    // Get the last change from editor transaction\n    const doc = editor.getDoc();\n    const cursor = editor.getCursor();\n    console.log('[Track Edits DEBUG] Cursor position:', cursor);\n    \n    const line = doc.getLine(cursor.line);\n    console.log('[Track Edits DEBUG] Current line:', line);\n    console.log('[Track Edits DEBUG] Line length:', line?.length);\n    \n    // Create a simple change record for demonstration\n    // In production, you'd hook into CodeMirror's transaction system\n    if (line && line.length > 0) {\n      console.log('Track Edits v2.0: Detected editor change at line', cursor.line, 'position', cursor.ch);\n      \n      // Calculate document position (absolute position from start of document)\n      const docPosition = editor.posToOffset(cursor);\n      const fromPos = Math.max(0, docPosition - 1);\n      const toPos = docPosition;\n      \n      const characterAtCursor = line.charAt(cursor.ch - 1) || '';\n      console.log('[Track Edits DEBUG] Character at cursor:', characterAtCursor);\n      console.log('[Track Edits DEBUG] Doc position:', docPosition);\n      console.log('[Track Edits DEBUG] From pos:', fromPos, 'To pos:', toPos);\n      \n      const change = {\n        id: generateId(),\n        timestamp: Date.now(),\n        type: 'insert' as const,\n        from: fromPos,\n        to: toPos,\n        text: characterAtCursor,\n        author: 'user'\n      };\n      \n      console.log('[Track Edits DEBUG] Created change object:', change);\n      return [change];\n    }\n    \n    console.log('[Track Edits DEBUG] No valid line found, returning empty array');\n    return [];\n  }\n\n  private addRibbonIcon() {\n    this.ribbonIconEl = super.addRibbonIcon('edit', 'Track Edits', (evt: MouseEvent) => {\n      // Use ToggleStateManager to handle ribbon clicks\n      if (this.toggleStateManager) {\n        this.toggleStateManager.setTrackingEnabled(!this.toggleStateManager.isTrackingEnabled);\n      } else {\n        // Fallback to direct toggle\n        this.debouncedRibbonClick();\n      }\n    });\n    \n    // Connect ribbon icon to ToggleStateManager\n    if (this.ribbonIconEl && this.toggleStateManager) {\n      this.toggleStateManager.setRibbonIcon(this.ribbonIconEl);\n    }\n    \n    this.updateRibbonIcon();\n  }\n\n  private updateRibbonIcon() {\n    if (this.ribbonIconEl) {\n      const isTracking = !!this.currentSession;\n      const tooltipText = isTracking ? 'Track Edits: ON (Click to stop)' : 'Track Edits: OFF (Click to start)';\n      this.ribbonIconEl.setAttribute('aria-label', tooltipText);\n      this.ribbonIconEl.setAttribute('title', tooltipText);\n    }\n  }\n\n  private handleRibbonClick() {\n    // Prevent recursive calls during ribbon toggle\n    if (this.isRestartingSession) {\n      console.log('Track Edits: Ribbon click ignored during session restart');\n      return;\n    }\n\n    // Set flag to prevent active-leaf-change interference\n    this.isRestartingSession = true;\n    \n    try {\n      if (this.currentSession) {\n        this.stopTracking();\n        console.log('Track Edits: Stopped tracking via ribbon icon');\n      } else {\n        this.startTracking();\n        console.log('Track Edits: Started tracking via ribbon icon');\n      }\n    } catch (error) {\n      console.error('Track Edits: Error in ribbon icon handler:', error);\n    } finally {\n      // Clear flag after a brief delay to allow UI to settle\n      setTimeout(() => {\n        this.isRestartingSession = false;\n      }, 100);\n    }\n  }\n\n  private addCommands() {\n    this.addCommand({\n      id: 'start-tracking',\n      name: 'Start tracking edits',\n      callback: () => this.startTracking()\n    });\n\n    this.addCommand({\n      id: 'stop-tracking',\n      name: 'Stop tracking edits',\n      callback: () => this.stopTracking()\n    });\n\n    this.addCommand({\n      id: 'toggle-side-panel',\n      name: 'Toggle Track Edits side panel',\n      callback: () => this.toggleSidePanel()\n    });\n\n    this.addCommand({\n      id: 'export-current-session',\n      name: 'Export current session',\n      callback: () => this.exportCurrentSession()\n    });\n\n    this.addCommand({\n      id: 'view-edit-history',\n      name: 'View edit history',\n      callback: () => this.viewEditHistory()\n    });\n\n    this.addCommand({\n      id: 'clear-edit-history',\n      name: 'Clear edit history',\n      callback: () => this.clearEditHistory()\n    });\n\n    // DEBUG COMMANDS - Remove before production\n    if (DEBUG_MODE) {\n      this.addCommand({\n        id: 'debug-show-report',\n        name: '\uD83D\uDC1B Show Debug Report',\n        callback: () => {\n          const report = DebugMonitor.getReport();\n          const modal = document.createElement('div');\n          modal.style.cssText = `\n            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);\n            width: 80%; max-width: 800px; height: 70%; \n            background: var(--background-primary); border: 1px solid var(--background-modifier-border);\n            border-radius: 8px; padding: 20px; z-index: 10000;\n            overflow-y: auto; font-family: var(--font-monospace);\n          `;\n          \n          const reportText = JSON.stringify(report, null, 2);\n          modal.innerHTML = `\n            <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;\">\n              <h2>Track Edits Debug Report</h2>\n              <div>\n                <button onclick=\"navigator.clipboard.writeText(this.dataset.report)\" data-report=\"${reportText.replace(/\"/g, '&quot;')}\" style=\"padding: 5px 10px; margin-right: 5px;\">Copy All</button>\n                <button onclick=\"this.parentElement.parentElement.parentElement.remove()\" style=\"padding: 5px 10px;\">Close</button>\n              </div>\n            </div>\n            <div style=\"margin-bottom: 15px;\">\n              <h3>Performance Stats <button onclick=\"navigator.clipboard.writeText(JSON.stringify(${JSON.stringify(report.perfStats)}, null, 2))\" style=\"font-size: 11px; padding: 2px 5px;\">Copy</button></h3>\n              <pre style=\"user-select: text; cursor: text; background: var(--background-secondary); padding: 10px; border-radius: 4px;\">${JSON.stringify(report.perfStats, null, 2)}</pre>\n            </div>\n            <div style=\"margin-bottom: 15px;\">\n              <h3>Summary <button onclick=\"navigator.clipboard.writeText(JSON.stringify(${JSON.stringify(report.summary)}, null, 2))\" style=\"font-size: 11px; padding: 2px 5px;\">Copy</button></h3>\n              <pre style=\"user-select: text; cursor: text; background: var(--background-secondary); padding: 10px; border-radius: 4px;\">${JSON.stringify(report.summary, null, 2)}</pre>\n            </div>\n            <div>\n              <h3>Recent Logs (Last 50) <button onclick=\"navigator.clipboard.writeText(JSON.stringify(${JSON.stringify(report.recentLogs)}, null, 2))\" style=\"font-size: 11px; padding: 2px 5px;\">Copy</button></h3>\n              <pre style=\"user-select: text; cursor: text; background: var(--background-secondary); padding: 10px; border-radius: 4px; font-size: 11px; max-height: 400px; overflow-y: auto;\">${JSON.stringify(report.recentLogs, null, 2)}</pre>\n            </div>\n          `;\n          \n          document.body.appendChild(modal);\n        }\n      });\n\n      this.addCommand({\n        id: 'debug-clear-logs',\n        name: '\uD83D\uDC1B Clear Debug Logs',\n        callback: () => {\n          DebugMonitor.clear();\n          console.log('[Track Edits] Debug logs cleared');\n        }\n      });\n\n      this.addCommand({\n        id: 'debug-current-state',\n        name: '\uD83D\uDC1B Show Current State',\n        callback: () => {\n          const state = {\n            currentSession: this.currentSession,\n            currentEdits: this.currentEdits.length,\n            isRejectingEdit,\n            hasPluginInstance: !!currentPluginInstance,\n            settings: this.settings,\n            sidePanelView: !!this.sidePanelView\n          };\n          console.log('[Track Edits] Current State:', state);\n        }\n      });\n\n      this.addCommand({\n        id: 'debug-dump-logs-console',\n        name: '\uD83D\uDC1B Dump Logs to Console',\n        callback: () => {\n          const report = DebugMonitor.getReport();\n          console.log('=== TRACK EDITS DEBUG REPORT ===');\n          console.log('Performance Stats:', report.perfStats);\n          console.log('Summary:', report.summary);\n          console.log('Recent Logs:', report.recentLogs);\n          console.log('=== END REPORT ===');\n        }\n      });\n    }\n  }\n\n  startTracking() {\n    // Prevent multiple simultaneous session starts\n    if (this.currentSession && !this.isRestartingSession) {\n      console.log('Track Edits: Session already active, stopping first');\n      this.stopTracking();\n    }\n\n    const activeFile = this.app.workspace.getActiveFile();\n    if (!activeFile) {\n      console.log('Track Edits: No active file to track');\n      return;\n    }\n\n    // Get and store current editor view for accept/reject operations (robust resolution like v2.0)\n    this.currentEditorView = this.findCurrentEditorView();\n    if (this.currentEditorView) {\n      DebugMonitor.log('EDITOR_VIEW_STORED', { \n        hasView: !!this.currentEditorView,\n        method: 'successful'\n      });\n    } else {\n      DebugMonitor.log('EDITOR_VIEW_STORAGE_FAILED', { reason: 'no editor found' });\n      console.warn('Track Edits: No active editor found during startTracking');\n    }\n\n    // Additional safety check - prevent starting if we're already starting\n    if (this.currentSession && this.currentSession.id && this.currentSession.startTime) {\n      console.log('Track Edits: Preventing duplicate session creation');\n      return;\n    }\n\n    // Update tracked file\n    this.lastActiveFile = activeFile.path;\n\n    this.currentSession = {\n      id: generateId(),\n      startTime: Date.now(),\n      changes: [],\n      wordCount: 0,\n      characterCount: 0\n    };\n    \n    // Reset current edits array\n    this.currentEdits = [];\n\n    this.editTracker.startSession(this.currentSession, activeFile);\n    this.editRenderer.showTrackingIndicator();\n    \n    // Show side panel if setting is enabled\n    if (this.settings.showSidePanelOnStart) {\n      this.showSidePanel();\n    }\n    \n    console.log('Track Edits v2.0: Started tracking session', this.currentSession.id);\n    \n    // Update ribbon icon tooltip\n    this.updateRibbonIcon();\n    \n    // Update side panel to show new status\n    this.updateSidePanel();\n  }\n\n  stopTracking() {\n    try {\n      if (this.currentSession) {\n        this.currentSession.endTime = Date.now();\n        this.saveCurrentSession();\n        if (this.editTracker) {\n          this.editTracker.endSession(this.currentSession.id);\n        }\n        if (this.editRenderer) {\n          this.editRenderer.hideTrackingIndicator();\n        }\n        \n        // Clear all decorations from the document\n        this.clearAllDecorations();\n        \n        // Clear current edits\n        this.currentEdits = [];\n        this.currentSession = null;\n        this.lastActiveFile = null;\n        \n        // Clear stored editor view\n        this.currentEditorView = null;\n        \n        // Update side panel\n        if (this.sidePanelView) {\n          this.sidePanelView.updateClusters([]);\n        }\n      }\n    } catch (error) {\n      console.error('Track Edits: Error stopping tracking:', error);\n      // Ensure currentSession is cleared even if other operations fail\n      this.currentSession = null;\n      this.currentEdits = [];\n      this.lastActiveFile = null;\n    }\n    \n    // Update ribbon icon tooltip\n    this.updateRibbonIcon();\n    \n    // Update side panel to show new status\n    this.updateSidePanel();\n  }\n\n  private restartSession() {\n    try {\n      if (this.isRestartingSession) {\n        console.log('Track Edits: Restart already in progress, ignoring');\n        return; // Prevent recursive calls\n      }\n      if (!this.currentSession) {\n        console.log('Track Edits: No session to restart');\n        return; // No session to restart\n      }\n      \n      this.isRestartingSession = true;\n      console.log('Track Edits v2.0: Restarting session due to file change');\n      \n      // Store the current session ID for logging\n      const previousSessionId = this.currentSession.id;\n      \n      this.stopTracking();\n      \n      // Longer delay to ensure cleanup completes and prevent rapid restarts\n      setTimeout(() => {\n        try {\n          if (this.settings.enableTracking && !this.currentSession) {\n            console.log('Track Edits: Starting new session after restart from', previousSessionId);\n            this.startTracking();\n          }\n        } catch (startError) {\n          console.error('Track Edits: Error starting new session after restart:', startError);\n        } finally {\n          this.isRestartingSession = false;\n        }\n      }, 150); // Increased delay to ensure proper cleanup\n    } catch (error) {\n      console.error('Track Edits: Error restarting session:', error);\n      this.isRestartingSession = false;\n    }\n  }\n\n  private async saveCurrentSession() {\n    if (this.currentSession && this.settings.autoSave) {\n      await this.editTracker.saveSession(this.currentSession);\n    }\n  }\n\n  private exportCurrentSession() {\n    if (!this.currentSession) return;\n    this.exportSession(this.currentSession.id);\n  }\n\n  private exportSession(sessionId: string): string {\n    const session = this.editTracker.getSession(sessionId);\n    if (!session) return '';\n\n    const exportData = this.editTracker.formatSessionForExport(session, this.settings.exportFormat);\n    \n    // Create and download file\n    const blob = new Blob([exportData], { type: 'text/plain' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `edit-session-${sessionId}.${this.settings.exportFormat}`;\n    a.click();\n    URL.revokeObjectURL(url);\n\n    return exportData;\n  }\n\n  private viewEditHistory() {\n    // Open a modal or view to show edit history\n    console.log('Opening edit history view...');\n  }\n\n  private clearEditHistory() {\n    this.editTracker.clearHistory();\n  }\n  \n  private async toggleSidePanel() {\n    const existingLeaf = this.app.workspace.getLeavesOfType('track-edits-side-panel')[0];\n    \n    if (existingLeaf) {\n      existingLeaf.detach();\n    } else {\n      await this.showSidePanel();\n    }\n  }\n  \n  private async showSidePanel() {\n    const rightLeaf = this.app.workspace.getRightLeaf(false);\n    await rightLeaf.setViewState({\n      type: 'track-edits-side-panel',\n      active: true\n    });\n    \n    this.sidePanelView = rightLeaf.view as EditSidePanelView;\n    this.app.workspace.revealLeaf(rightLeaf);\n  }\n  \n  acceptEditCluster(clusterId: string) {\n    const timer = DebugMonitor.startTimer('acceptEditCluster');\n    \n    // Get the cluster and its edits\n    const cluster = this.clusterManager.getCluster(clusterId);\n    if (!cluster) {\n      DebugMonitor.log('ACCEPT_CLUSTER_FAILED', { clusterId, reason: 'cluster not found' });\n      DebugMonitor.endTimer(timer);\n      return;\n    }\n\n    DebugMonitor.log('ACCEPT_CLUSTER_START', {\n      clusterId,\n      editCount: cluster.edits.length,\n      editIds: cluster.edits.map(e => e.id)\n    });\n\n    // Remove decorations from CodeMirror view for this cluster's edits\n    DebugMonitor.log('ACCEPT_REMOVING_DECORATIONS', {\n      hasStoredView: !!this.currentEditorView,\n      editIds: cluster.edits.map(e => e.id)\n    });\n    this.removeDecorationsFromView(cluster.edits.map(e => e.id));\n\n    // Remove edits from current array that belong to this cluster\n    this.currentEdits = this.currentEdits.filter(edit => \n      !cluster.edits.find(clusterEdit => clusterEdit.id === edit.id)\n    );\n    \n    // Update side panel display\n    this.updateSidePanel();\n    \n    DebugMonitor.log('ACCEPT_CLUSTER_COMPLETE', {\n      clusterId,\n      remainingEdits: this.currentEdits.length\n    });\n    \n    DebugMonitor.endTimer(timer);\n  }\n  \n  rejectEditCluster(clusterId: string) {\n    const timer = DebugMonitor.startTimer('rejectEditCluster');\n    \n    // Get the cluster and its edits\n    const cluster = this.clusterManager.getCluster(clusterId);\n    if (!cluster) {\n      DebugMonitor.log('REJECT_CLUSTER_FAILED', { clusterId, reason: 'cluster not found' });\n      DebugMonitor.endTimer(timer);\n      return;\n    }\n\n    DebugMonitor.log('REJECT_CLUSTER_START', {\n      clusterId,\n      editCount: cluster.edits.length,\n      editIds: cluster.edits.map(e => e.id)\n    });\n\n    // Get editor view with fallback like v2.0\n    let editorView = this.currentEditorView;\n    \n    DebugMonitor.log('REJECT_CHECKING_VIEW', {\n      hasStoredView: !!this.currentEditorView,\n      viewType: this.currentEditorView ? this.currentEditorView.constructor.name : 'null'\n    });\n    \n    if (!editorView) {\n      DebugMonitor.log('REJECT_FALLBACK_SEARCH', { reason: 'no stored editor view, searching' });\n      editorView = this.findCurrentEditorView();\n    }\n    \n    if (!editorView) {\n      DebugMonitor.log('REJECT_CLUSTER_FAILED', { reason: 'no editor view available' });\n      DebugMonitor.endTimer(timer);\n      return;\n    }\n\n    // Debug: Log all edits in cluster before filtering\n    DebugMonitor.log('REJECT_ALL_EDITS_IN_CLUSTER', {\n      allEdits: cluster.edits.map(e => ({ id: e.id, type: e.type, from: e.from, to: e.to, textLength: e.text?.length || 0 }))\n    });\n\n    // Process both insertions (remove) and deletions (restore)\n    const insertionsToRemove = cluster.edits\n      .filter(edit => edit.type === 'insert')\n      .sort((a, b) => b.from - a.from); // Reverse order to avoid position shifts\n\n    const deletionsToRestore = cluster.edits\n      .filter(edit => edit.type === 'delete')\n      .sort((a, b) => a.from - b.from); // Forward order for deletions\n\n    DebugMonitor.log('REJECT_FILTERED_EDITS', {\n      insertionsToRemove: insertionsToRemove.map(e => ({ id: e.id, type: e.type, from: e.from, to: e.to, textLength: e.text?.length || 0 })),\n      deletionsToRestore: deletionsToRestore.map(e => ({ id: e.id, type: e.type, from: e.from, to: e.to, removedTextLength: e.removedText?.length || 0 }))\n    });\n\n    // Use CodeMirror directly like accept does, not Obsidian Editor API\n    const doc = editorView.state.doc;\n    \n    // Revert text changes for insertions using CodeMirror API\n    // Prevent recursion during our own edit\n    isRejectingEdit = true;\n    \n    try {\n      DebugMonitor.log('REJECT_TEXT_PROCESSING', {\n        insertionsToRemove: insertionsToRemove.length,\n        deletionsToRestore: deletionsToRestore.length,\n        docLength: doc.length\n      });\n      \n      // Build transaction to remove insertions and restore deletions\n      const changes = [];\n      \n      // First, remove all insertions (in reverse order)\n      for (const edit of insertionsToRemove) {\n        if (edit.text) {\n          DebugMonitor.log('REJECT_PROCESSING_INSERTION', {\n            editId: edit.id,\n            editText: edit.text,\n            editFrom: edit.from,\n            editTextLength: edit.text.length\n          });\n          \n          // Validate text exists at expected position\n          const currentText = doc.sliceString(edit.from, edit.from + edit.text.length);\n          \n          DebugMonitor.log('REJECT_TEXT_COMPARISON', {\n            editId: edit.id,\n            position: { from: edit.from, to: edit.from + edit.text.length },\n            expectedText: edit.text,\n            currentText,\n            matches: currentText === edit.text\n          });\n          \n          if (currentText === edit.text) {\n            changes.push({ from: edit.from, to: edit.from + edit.text.length, insert: '' });\n            DebugMonitor.log('REJECT_REVERT_INSERT', {\n              editId: edit.id,\n              removedText: edit.text\n            });\n          } else {\n            DebugMonitor.log('REJECT_REVERT_SKIPPED', {\n              editId: edit.id,\n              reason: 'text mismatch',\n              expected: edit.text,\n              found: currentText\n            });\n          }\n        }\n      }\n\n      // Then, restore all deletions (in forward order)\n      for (const edit of deletionsToRestore) {\n        if (edit.removedText) {\n          DebugMonitor.log('REJECT_PROCESSING_DELETION', {\n            editId: edit.id,\n            removedText: edit.removedText,\n            editFrom: edit.from,\n            removedTextLength: edit.removedText.length\n          });\n          \n          // Insert the deleted text back at its original position\n          changes.push({ from: edit.from, to: edit.from, insert: edit.removedText });\n          DebugMonitor.log('REJECT_RESTORE_DELETION', {\n            editId: edit.id,\n            restoredText: edit.removedText,\n            position: edit.from\n          });\n        }\n      }\n      \n      // Apply all text changes and decoration removals in single transaction\n      const decorationRemoveEffects = cluster.edits.map(edit => \n        removeDecorationEffect.of(edit.id)\n      );\n      \n      if (changes.length > 0) {\n        const transaction = editorView.state.update({ \n          changes,\n          effects: decorationRemoveEffects\n        });\n        editorView.dispatch(transaction);\n        DebugMonitor.log('REJECT_CHANGES_APPLIED', {\n          changeCount: changes.length,\n          effectCount: decorationRemoveEffects.length\n        });\n      } else {\n        // Only dispatch decoration effects if no text changes\n        editorView.dispatch({\n          effects: decorationRemoveEffects\n        });\n      }\n      \n      DebugMonitor.log('REJECT_DISPATCH_COMPLETE', {\n        processedEdits: insertionsToRemove.length + deletionsToRestore.length,\n        effectCount: decorationRemoveEffects.length\n      });\n    } finally {\n      isRejectingEdit = false;\n    }\n\n    // Remove edits from current array that belong to this cluster\n    this.currentEdits = this.currentEdits.filter(edit => \n      !cluster.edits.find(clusterEdit => clusterEdit.id === edit.id)\n    );\n    \n    // Update side panel display\n    this.updateSidePanel();\n    \n    DebugMonitor.log('REJECT_CLUSTER_COMPLETE', {\n      clusterId,\n      remainingEdits: this.currentEdits.length\n    });\n    \n    DebugMonitor.endTimer(timer);\n  }\n\n  // Batch operations for better performance\n  acceptAllEditClusters(clusterIds: string[]) {\n    const timer = DebugMonitor.startTimer('acceptAllEditClusters');\n    DebugMonitor.log('ACCEPT_ALL_START', { clusterIds, count: clusterIds.length });\n    \n    // Process all clusters without intermediate side panel updates\n    clusterIds.forEach(clusterId => {\n      const cluster = this.clusterManager.getCluster(clusterId);\n      if (cluster && this.currentEditorView) {\n        // Remove decorations for each cluster\n        cluster.edits.forEach(edit => {\n          this.currentEditorView!.dispatch({\n            effects: removeDecorationEffect.of(edit.id)\n          });\n        });\n        \n        // Remove edits from current edits array\n        this.currentEdits = this.currentEdits.filter(edit => \n          !cluster.edits.find(clusterEdit => clusterEdit.id === edit.id)\n        );\n      }\n    });\n    \n    // Single side panel update at the end\n    this.updateSidePanel();\n    \n    DebugMonitor.log('ACCEPT_ALL_COMPLETE', {\n      processedCount: clusterIds.length,\n      remainingEdits: this.currentEdits.length\n    });\n    DebugMonitor.endTimer(timer);\n  }\n\n  rejectAllEditClusters(clusterIds: string[]) {\n    const timer = DebugMonitor.startTimer('rejectAllEditClusters');\n    DebugMonitor.log('REJECT_ALL_START', { clusterIds, count: clusterIds.length });\n    \n    // Process all clusters without intermediate side panel updates\n    clusterIds.forEach(clusterId => {\n      const cluster = this.clusterManager.getCluster(clusterId);\n      if (cluster && this.currentEditorView) {\n        // Group edits by type\n        const insertionsToRemove = cluster.edits.filter(edit => edit.type === 'insert');\n        const deletionsToRestore = cluster.edits.filter(edit => edit.type === 'delete');\n        \n        // Remove decorations and restore text\n        cluster.edits.forEach(edit => {\n          this.currentEditorView!.dispatch({\n            effects: removeDecorationEffect.of(edit.id)\n          });\n        });\n        \n        // Apply CodeMirror changes for text restoration\n        if (insertionsToRemove.length > 0 || deletionsToRestore.length > 0) {\n          const doc = this.currentEditorView.state.doc;\n          const changes: ChangeSpec[] = [];\n          \n          // Remove insertions and restore deletions\n          for (const edit of insertionsToRemove) {\n            if (edit.text) {\n              const currentText = doc.sliceString(edit.from, edit.from + edit.text.length);\n              if (currentText === edit.text) {\n                changes.push({ from: edit.from, to: edit.from + edit.text.length, insert: '' });\n              }\n            }\n          }\n          \n          for (const edit of deletionsToRestore) {\n            if (edit.removedText) {\n              changes.push({ from: edit.from, to: edit.from, insert: edit.removedText });\n            }\n          }\n          \n          if (changes.length > 0) {\n            this.currentEditorView.dispatch({ changes });\n          }\n        }\n        \n        // Remove edits from current edits array\n        this.currentEdits = this.currentEdits.filter(edit => \n          !cluster.edits.find(clusterEdit => clusterEdit.id === edit.id)\n        );\n      }\n    });\n    \n    // Single side panel update at the end\n    this.updateSidePanel();\n    \n    DebugMonitor.log('REJECT_ALL_COMPLETE', {\n      processedCount: clusterIds.length,\n      remainingEdits: this.currentEdits.length\n    });\n    DebugMonitor.endTimer(timer);\n  }\n\n  private findCurrentEditorView(): EditorView | null {\n    // Method 1: Try active view first\n    const activeLeaf = this.app.workspace.getActiveViewOfType(MarkdownView);\n    if (activeLeaf && activeLeaf.editor) {\n      const editorView = (activeLeaf.editor as any).cm as EditorView;\n      if (editorView) {\n        DebugMonitor.log('FOUND_EDITOR_VIEW', { method: 'active_view' });\n        return editorView;\n      }\n    }\n\n    // Method 2: Search all workspace leaves for MarkdownView (v2.0 fallback pattern)\n    const leaves = this.app.workspace.getLeavesOfType('markdown');\n    for (const leaf of leaves) {\n      const view = leaf.view as MarkdownView;\n      if (view && view.editor) {\n        const editorView = (view.editor as any).cm as EditorView;\n        if (editorView) {\n          DebugMonitor.log('FOUND_EDITOR_VIEW', { method: 'leaf_search', leafId: leaf.id });\n          return editorView;\n        }\n      }\n    }\n\n    // Method 3: Try the most recently active leaf (last resort)\n    const mostRecentLeaf = this.app.workspace.getMostRecentLeaf();\n    if (mostRecentLeaf && mostRecentLeaf.view instanceof MarkdownView && mostRecentLeaf.view.editor) {\n      const editorView = (mostRecentLeaf.view.editor as any).cm as EditorView;\n      if (editorView) {\n        DebugMonitor.log('FOUND_EDITOR_VIEW', { method: 'most_recent_leaf' });\n        return editorView;\n      }\n    }\n\n    DebugMonitor.log('EDITOR_VIEW_NOT_FOUND', { \n      activeLeafExists: !!activeLeaf,\n      markdownLeavesCount: leaves.length,\n      mostRecentLeafExists: !!mostRecentLeaf\n    });\n    return null;\n  }\n\n  private removeDecorationsFromView(editIds: string[]) {\n    let editorView = this.currentEditorView;\n    \n    // If no stored view, try to find current one (v2.0 fallback pattern)\n    if (!editorView) {\n      DebugMonitor.log('REMOVE_DECORATIONS_FALLBACK', { reason: 'no stored editor view, searching' });\n      editorView = this.findCurrentEditorView();\n    }\n    \n    if (!editorView) {\n      DebugMonitor.log('REMOVE_DECORATIONS_FAILED', { reason: 'no editor view available' });\n      return;\n    }\n\n    const removeEffects = editIds.map(editId => removeDecorationEffect.of(editId));\n    \n    DebugMonitor.log('REMOVING_DECORATIONS', {\n      editIds,\n      effectCount: removeEffects.length,\n      hasEditorView: !!editorView,\n      usingStored: editorView === this.currentEditorView\n    });\n\n    editorView.dispatch({ effects: removeEffects });\n  }\n\n  private handleToggleOff() {\n    // Epic's decision tree: Check for pending edits\n    const pendingEditCount = this.currentEdits.length;\n    \n    DebugMonitor.log('HANDLE_TOGGLE_OFF', {\n      pendingEdits: pendingEditCount,\n      hasSession: !!this.currentSession\n    });\n\n    // If no pending edits, toggle off directly\n    if (pendingEditCount === 0) {\n      DebugMonitor.log('TOGGLE_OFF_NO_EDITS', { action: 'direct_toggle' });\n      this.stopTracking();\n      return;\n    }\n\n    // TODO: Add \"skip confirmation\" logic in future update when checkbox is working\n\n    // Show confirmation modal for pending edits (Epic's core UX pattern)\n    DebugMonitor.log('TOGGLE_OFF_SHOW_MODAL', { pendingEdits: pendingEditCount });\n    this.showToggleConfirmationModal(pendingEditCount);\n  }\n\n  private showToggleConfirmationModal(editCount: number) {\n    const modal = new ToggleConfirmationModal(this.app, {\n      editCount,\n      onConfirm: () => {\n        DebugMonitor.log('TOGGLE_CONFIRMATION_CONFIRMED', { editCount });\n        this.discardEditsAndStop();\n      },\n      onCancel: () => {\n        DebugMonitor.log('TOGGLE_CONFIRMATION_CANCELLED', { editCount });\n        // Reset toggle state back to enabled since user cancelled\n        // Do NOT call setTrackingEnabled as it triggers the callback again\n        // Just update the UI state directly\n        if (this.toggleStateManager && this.ribbonIconEl) {\n          // Manually update UI without triggering callback\n          this.ribbonIconEl.classList.add('track-edits-enabled');\n          this.ribbonIconEl.classList.remove('track-edits-disabled');\n        }\n      }\n    });\n    \n    modal.open();\n  }\n\n  private discardEditsAndStop() {\n    // CRITICAL: Stop tracking FIRST to prevent new edits during rejection\n    this.stopTracking();\n    \n    // Epic's approach: Use existing proven reject functionality\n    const clusters = this.clusterManager.clusterEdits(this.currentEdits);\n    const clusterIds = clusters.map(cluster => cluster.id);\n    \n    if (clusterIds.length > 0) {\n      DebugMonitor.log('DISCARD_EDITS_VIA_REJECT', { \n        clusterCount: clusterIds.length,\n        method: 'rejectAllEditClusters'\n      });\n      // Leverage existing battle-tested reject functionality\n      this.rejectAllEditClusters(clusterIds);\n    } else {\n      // Fallback to direct clearing if no clusters\n      DebugMonitor.log('DISCARD_EDITS_DIRECT_CLEAR', { \n        editCount: this.currentEdits.length,\n        method: 'clearAllDecorations'\n      });\n      this.clearAllDecorations();\n    }\n  }\n\n  private clearAllDecorations() {\n    let editorView = this.currentEditorView;\n    \n    // If no stored view, try to find current one\n    if (!editorView) {\n      editorView = this.findCurrentEditorView();\n    }\n    \n    if (!editorView) {\n      DebugMonitor.log('CLEAR_ALL_DECORATIONS_FAILED', { reason: 'no editor view available' });\n      return;\n    }\n\n    DebugMonitor.log('CLEAR_ALL_DECORATIONS_START', {\n      currentEditsCount: this.currentEdits.length,\n      hasEditorView: !!editorView\n    });\n\n    // Use our custom clear all decorations effect\n    editorView.dispatch({\n      effects: clearAllDecorationsEffect.of(true)\n    });\n\n    DebugMonitor.log('CLEAR_ALL_DECORATIONS_COMPLETE', {\n      method: 'clearAllDecorationsEffect'\n    });\n  }\n\n  handleEditsFromCodeMirror(edits: EditChange[]) {\n    const timer = DebugMonitor.startTimer('handleEditsFromCodeMirror');\n    \n    DebugMonitor.log('HANDLE_EDITS', {\n      editCount: edits.length,\n      enableTracking: this.settings.enableTracking,\n      hasSession: !!this.currentSession,\n      currentEditsCount: this.currentEdits.length,\n      edits: edits.map(e => ({ id: e.id, type: e.type, from: e.from, to: e.to }))\n    });\n    \n    // Check both settings and toggle state manager\n    const isTrackingEnabled = this.settings.enableTracking && \n                              (!this.toggleStateManager || this.toggleStateManager.isTrackingEnabled);\n    \n    if (!isTrackingEnabled || !this.currentSession) {\n      DebugMonitor.log('HANDLE_EDITS_SKIPPED', {\n        reason: !this.settings.enableTracking ? 'settings disabled' : \n                !this.toggleStateManager?.isTrackingEnabled ? 'toggle disabled' : 'no session'\n      });\n      DebugMonitor.endTimer(timer);\n      return;\n    }\n\n    // Add edits to current array\n    this.currentEdits.push(...edits);\n\n    // Record changes in tracker\n    const trackerTimer = DebugMonitor.startTimer('editTracker.recordChanges');\n    this.editTracker.recordChanges(this.currentSession.id, edits);\n    DebugMonitor.endTimer(trackerTimer);\n\n    // Update side panel (debounced)\n    this.debouncedPanelUpdate();\n\n    // Save session (debounced)\n    this.debouncedSave();\n\n    DebugMonitor.log('HANDLE_EDITS_COMPLETE', {\n      processedCount: edits.length,\n      totalEdits: this.currentEdits.length\n    });\n    \n    DebugMonitor.endTimer(timer);\n  }\n\n  // AI Integration Methods (stubs for future implementation)\n  async runAIAnalysisOnce(): Promise<void> {\n    console.log('Track Edits: AI analysis triggered manually');\n    \n    // TODO: Implement AI analysis using AI Providers plugin integration\n    // This will analyze current edit clusters and provide insights\n    \n    // For now, just log the current state\n    DebugMonitor.log('AI_ANALYSIS_TRIGGERED', {\n      clustersCount: this.currentEdits.length,\n      hasSession: !!this.currentSession,\n      aiProvider: this.settings.aiProvider,\n      aiModel: this.settings.aiModel\n    });\n    \n    // Simulate AI processing delay\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    \n    console.log('Track Edits: AI analysis complete (stub)');\n  }\n\n  private async loadSystemPrompt(): Promise<string> {\n    try {\n      const promptPath = this.settings.systemPromptPath;\n      const adapter = this.app.vault.adapter;\n      \n      // Check if prompt file exists\n      if (await adapter.exists(promptPath)) {\n        return await adapter.read(promptPath);\n      } else {\n        // Create default prompt file if it doesn't exist\n        const defaultPrompt = await this.getDefaultSystemPrompt();\n        await adapter.write(promptPath, defaultPrompt);\n        return defaultPrompt;\n      }\n    } catch (error) {\n      console.error('Track Edits: Error loading system prompt:', error);\n      return this.getDefaultSystemPrompt();\n    }\n  }\n\n  private async getDefaultSystemPrompt(): Promise<string> {\n    return `# Track Edits AI Analysis System Prompt\\n\\nYou are a Track Edits SME specializing in analyzing keystroke patterns and typing behavior.\\n\\nAnalyze edit clusters to identify user intent and provide workflow insights.\\n\\nFocus on typing patterns, not content quality.`;\n  }\n\n  /**\n   * Editorial Engine integration API for submitting AI-generated changes\n   * Task 2.2: Platform Integration - Primary interface between Editorial Engine and Track Edits\n   * \n   * @param changes Array of EditChange objects to record\n   * @param aiProvider AI provider identifier (e.g., 'anthropic-claude', 'openai-gpt')  \n   * @param aiModel AI model identifier (e.g., 'claude-3-sonnet', 'gpt-4')\n   * @param processingContext Optional context about AI processing settings and constraints\n   * @param options Optional configuration for session management and validation behavior\n   * @returns Promise resolving to detailed result with success status, IDs, and error information\n   */\n  async submitChangesFromAI(\n    changes: EditChange[],\n    aiProvider: string,\n    aiModel: string,\n    processingContext?: AIProcessingContext,\n    options: SubmitChangesFromAIOptions = {}\n  ): Promise<SubmitChangesFromAIResult> {\n    // Import error handling components at the top of the method\n    const { AISubmissionErrorManager } = await import('./error-handling/ai-submission-error-manager');\n    const { RetryRecoveryManager } = await import('./error-handling/retry-recovery-manager');\n\n    // Initialize error handling and recovery managers\n    const errorManager = new AISubmissionErrorManager(this.batchManager);\n    const retryManager = new RetryRecoveryManager();\n\n    const result: SubmitChangesFromAIResult = {\n      success: false,\n      changeIds: [],\n      errors: [],\n      warnings: []\n    };\n\n    // Generate operation ID for tracking\n    const operationId = `ai_submit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    let transactionId: string | undefined;\n\n    try {\n      // Initialize change consolidation manager\n      const { ChangeConsolidationManager } = await import('./change-consolidation-manager');\n      const consolidationManager = new ChangeConsolidationManager();\n\n      // Create multi-plugin operation for consolidation\n      const multiPluginOperation = {\n        id: operationId,\n        pluginId: 'track-edits',\n        pluginVersion: '1.0.0',\n        sessionId: options.sessionId,\n        documentPath: this.app.workspace.getActiveFile()?.path || 'unknown',\n        changes: changes.map(change => ({\n          ...change,\n          pluginId: 'track-edits',\n          operationId: operationId,\n          semanticContext: processingContext?.constraints?.some(c => c.includes('semantic')) ? {\n            intention: 'enhancement' as const,\n            scope: 'paragraph' as const,\n            confidence: 0.8,\n            preserveFormatting: true,\n            preserveContent: true\n          } : undefined\n        })),\n        timestamp: Date.now(),\n        priority: options.priority || 2, // HIGH priority for user-initiated Track Edits operations\n        capabilities: {\n          canMergeWith: ['editorial-engine', 'writerr-chat'],\n          conflictResolution: ['auto_merge', 'priority_override'],\n          maxConcurrentOperations: 5,\n          supportsRealTimeConsolidation: true,\n          supportedChangeTypes: ['insert', 'delete', 'replace']\n        },\n        metadata: {\n          userInitiated: !options.automated,\n          batchId: processingContext?.batchId,\n          estimatedProcessingTime: changes.length * 1000, // Rough estimate\n          requiresUserReview: changes.length > 10,\n          canBeDeferred: false,\n          tags: processingContext?.constraints || []\n        }\n      };\n\n      // Submit operation for consolidation\n      const consolidationResult = await consolidationManager.submitOperation(multiPluginOperation);\n      \n      if (!consolidationResult.success) {\n        result.errors.push(...(consolidationResult.errors || []));\n        result.warnings.push(...(consolidationResult.warnings || []));\n        \n        if (consolidationResult.errors && consolidationResult.errors.length > 0) {\n          return result;\n        }\n      }\n\n      if (consolidationResult.requiresConsolidation) {\n        result.warnings.push('Multi-plugin consolidation required - changes coordinated with other plugins');\n        \n        if (consolidationResult.estimatedWaitTime && consolidationResult.estimatedWaitTime > 0) {\n          result.warnings.push(`Estimated wait time for consolidation: ${consolidationResult.estimatedWaitTime}ms`);\n        }\n      }\n\n      // Check for concurrent processing operations to coordinate\n      const activeOperations = this.getActiveProcessingOperations();\n      if (activeOperations.length > 0) {\n        console.log(`[TrackEditsPlugin] Active AI processing operations detected: ${activeOperations.length}`);\n        \n        // Check if this is a coordinated operation (from event-driven processing)\n        const coordinatedOperation = activeOperations.find(op => \n          op.operation.provider === aiProvider && \n          op.operation.model === aiModel &&\n          op.input.documentId === this.app.workspace.getActiveFile()?.path\n        );\n\n        if (coordinatedOperation && !options.forceProcessing) {\n          // This appears to be a duplicate of an active operation - coordinate instead of process\n          result.warnings.push(`Coordinating with active AI processing operation: ${coordinatedOperation.requestId}`);\n          \n          // Wait for the coordinated operation to complete\n          const coordinatedResult = await this.waitForProcessingCompletion(coordinatedOperation.requestId, 30000);\n          if (coordinatedResult.success) {\n            return coordinatedResult;\n          } else {\n            result.warnings.push('Coordinated operation failed, proceeding with independent processing');\n          }\n        } else {\n          result.warnings.push('Multiple concurrent AI operations detected - processing independently');\n        }\n      }\n\n      // Create processing state for this operation\n      const requestId = operationId;\n      const processingState: AIProcessingState = {\n        requestId,\n        operation: {\n          type: processingContext?.operationType || 'ai_submission',\n          provider: aiProvider,\n          model: aiModel,\n          startTime: Date.now()\n        },\n        input: {\n          documentId: this.app.workspace.getActiveFile()?.path || 'unknown',\n          content: changes.map(c => c.content).join('\\n'),\n          userPrompt: processingContext?.userPrompt || 'AI submission via Track Edits',\n          constraints: processingContext?.constraints\n        },\n        status: 'preparing',\n        progress: {\n          percentage: 0,\n          stage: 'initializing'\n        },\n        sourcePlugin: 'track-edits',\n        sessionId: options.sessionId\n      };\n\n      // Add to processing state management\n      this.aiProcessingStates.set(requestId, processingState);\n      this.processingQueue.active.push(processingState);\n\n      // Publish AI processing start event for platform coordination\n      await this.publishAIProcessingStartEvent({\n        requestId,\n        operation: processingState.operation,\n        input: processingState.input,\n        config: {\n          maxRetries: options.maxRetries || 3,\n          timeoutMs: 300000, // 5 minutes\n          expectedDuration: changes.length * 1000 // Rough estimate\n        },\n        pluginContext: {\n          sourcePluginId: 'track-edits',\n          sourcePluginVersion: '1.0.0',\n          processingCapabilities: ['change_tracking', 'session_management', 'batch_processing']\n        }\n      }, options.sessionId);\n\n      // Update processing state to processing\n      processingState.status = 'processing';\n      processingState.progress = { percentage: 10, stage: 'validating' };\n\n      // Input validation\n      if (!changes || changes.length === 0) {\n        processingState.status = 'error';\n        processingState.errorDetails = {\n          type: 'validation',\n          message: 'No changes provided',\n          recoverable: false\n        };\n        result.errors.push('No changes provided');\n        await this.publishAIProcessingErrorEvent(requestId, 'validation', 'No changes provided');\n        return result;\n      }\n\n      if (!aiProvider || !aiModel) {\n        processingState.status = 'error';\n        processingState.errorDetails = {\n          type: 'validation',\n          message: 'AI provider and model are required',\n          recoverable: false\n        };\n        result.errors.push('AI provider and model are required');\n        await this.publishAIProcessingErrorEvent(requestId, 'validation', 'AI provider and model are required');\n        return result;\n      }\n\n      // Update progress\n      processingState.progress = { percentage: 20, stage: 'authenticating' };\n      await this.publishAIProcessingProgressEvent(requestId, processingState.progress, null, {\n        tokensProcessed: 0,\n        responseTime: Date.now() - processingState.operation.startTime,\n        memoryUsage: 0\n      });\n\n      // Plugin system integration - validate plugin authentication if provided\n      if (this.pluginRegistry && (options as any).pluginAuthContext) {\n        const pluginOptions = options as any; // Type assertion for plugin options\n        const pluginAuthContext = pluginOptions.pluginAuthContext;\n\n        // Authenticate plugin\n        const authResult = await this.pluginRegistry.authenticatePlugin(\n          pluginAuthContext.pluginId,\n          {\n            pluginId: pluginAuthContext.pluginId,\n            authToken: pluginAuthContext.sessionToken,\n            timestamp: new Date(),\n            nonce: Math.random().toString(36).substring(2, 15)\n          }\n        );\n\n        if (!authResult) {\n          processingState.status = 'error';\n          processingState.errorDetails = {\n            type: 'authentication',\n            message: 'Plugin authentication failed',\n            recoverable: false\n          };\n          result.errors.push('Plugin authentication failed');\n          await this.publishAIProcessingErrorEvent(requestId, 'authentication', 'Plugin authentication failed');\n          return result;\n        }\n\n        // Validate plugin permissions for document modification\n        const permissionResult = await this.pluginRegistry.validatePermissions(\n          pluginAuthContext.pluginId,\n          ['modify_documents', 'create_sessions'], // Convert to PluginPermission enum\n          { operation: 'ai_submission', context: processingContext }\n        );\n\n        if (!permissionResult.hasPermission) {\n          processingState.status = 'error';\n          processingState.errorDetails = {\n            type: 'permission',\n            message: `Plugin lacks required permissions: ${permissionResult.missingPermissions.join(', ')}`,\n            recoverable: false\n          };\n          result.errors.push(`Plugin lacks required permissions: ${permissionResult.missingPermissions.join(', ')}`);\n          result.warnings.push(...permissionResult.warnings);\n          await this.publishAIProcessingErrorEvent(requestId, 'permission', `Plugin lacks required permissions: ${permissionResult.missingPermissions.join(', ')}`);\n          return result;\n        }\n\n        // Validate plugin capabilities\n        const plugin = this.pluginRegistry.getPlugin(pluginAuthContext.pluginId);\n        if (plugin) {\n          const capabilityValid = await plugin.validateCapability('ai_submission');\n          if (!capabilityValid) {\n            result.warnings.push('Plugin may not fully support this type of AI submission');\n          }\n\n          // Check batch size limits\n          const pluginInfo = plugin.getPluginInfo();\n          if (changes.length > pluginInfo.capabilities.maxBatchSize) {\n            processingState.status = 'error';\n            processingState.errorDetails = {\n              type: 'capability',\n              message: `Batch size ${changes.length} exceeds plugin limit ${pluginInfo.capabilities.maxBatchSize}`,\n              recoverable: true\n            };\n            result.errors.push(`Batch size ${changes.length} exceeds plugin limit ${pluginInfo.capabilities.maxBatchSize}`);\n            await this.publishAIProcessingErrorEvent(requestId, 'capability', `Batch size exceeds limit`);\n            return result;\n          }\n\n          // Check AI provider support\n          if (!pluginInfo.capabilities.aiProviders.includes(aiProvider)) {\n            result.warnings.push(`Plugin may not be optimized for AI provider: ${aiProvider}`);\n          }\n        }\n\n        // Add plugin attribution to processing context\n        if (processingContext) {\n          processingContext = {\n            ...processingContext,\n            metadata: {\n              ...processingContext.metadata,\n              pluginId: pluginAuthContext.pluginId,\n              pluginVersion: plugin?.getPluginInfo().version,\n              submissionTime: new Date().toISOString()\n            }\n          };\n        }\n\n        result.warnings.push(...permissionResult.warnings);\n        console.log(`[TrackEditsPlugin] AI submission authenticated for plugin: ${pluginAuthContext.pluginId}`);\n      }\n\n      // Update progress - authentication complete\n      processingState.progress = { percentage: 30, stage: 'session_management' };\n      await this.publishAIProcessingProgressEvent(requestId, processingState.progress);\n\n      // Handle session management with error handling\n      let sessionId = options.sessionId;\n      if (!sessionId && options.createSession) {\n        sessionId = generateId();\n        const activeFile = this.app.workspace.getActiveFile();\n        if (activeFile) {\n          const session: EditSession = {\n            id: sessionId,\n            startTime: Date.now(),\n            changes: [],\n            wordCount: 0,\n            characterCount: 0\n          };\n          \n          try {\n            this.editTracker.startSession(session, activeFile);\n          } catch (sessionError) {\n            const errorContext = {\n              operation: 'session_creation',\n              sessionId: sessionId,\n              aiProvider,\n              aiModel\n            };\n            \n            const handledError = await errorManager.handleError(sessionError, errorContext);\n            result.errors.push(handledError.error.message);\n            result.warnings.push('Session creation failed - changes will be processed without session tracking');\n            \n            // Continue without session if not critical\n            if (handledError.error.severity === 'critical') {\n              processingState.status = 'error';\n              processingState.errorDetails = {\n                type: 'session',\n                message: handledError.error.message,\n                recoverable: handledError.error.severity !== 'critical'\n              };\n              await this.publishAIProcessingErrorEvent(requestId, 'session', handledError.error.message);\n              return result;\n            }\n            sessionId = undefined;\n          }\n        } else {\n          processingState.status = 'error';\n          processingState.errorDetails = {\n            type: 'session',\n            message: 'Cannot create session: no active file',\n            recoverable: false\n          };\n          result.errors.push('Cannot create session: no active file');\n          await this.publishAIProcessingErrorEvent(requestId, 'session', 'Cannot create session: no active file');\n          return result;\n        }\n      }\n\n      if (!sessionId) {\n        processingState.status = 'error';\n        processingState.errorDetails = {\n          type: 'session',\n          message: 'No session ID provided and createSession option not set',\n          recoverable: false\n        };\n        result.errors.push('No session ID provided and createSession option not set');\n        await this.publishAIProcessingErrorEvent(requestId, 'session', 'No session ID provided');\n        return result;\n      }\n\n      // Update processing state with session ID\n      processingState.sessionId = sessionId;\n\n      // Validate session exists\n      const session = this.editTracker.getSession(sessionId);\n      if (!session) {\n        processingState.status = 'error';\n        processingState.errorDetails = {\n          type: 'session',\n          message: `Session ${sessionId} not found`,\n          recoverable: false\n        };\n        result.errors.push(`Session ${sessionId} not found`);\n        await this.publishAIProcessingErrorEvent(requestId, 'session', `Session not found`);\n        return result;\n      }\n\n      // Update progress - session validated\n      processingState.progress = { percentage: 40, stage: 'preparing_transaction' };\n      await this.publishAIProcessingProgressEvent(requestId, processingState.progress);\n\n      // Create backup state before operations\n      const backupState = errorManager.createBackupState(sessionId, {\n        editTracker: this.editTracker,\n        batchManager: this.batchManager\n      });\n\n      // Begin transaction for atomic operations\n      transactionId = errorManager.beginTransaction(sessionId, [\n        { type: 'create-changes', target: 'session', data: changes },\n        { type: 'update-session', target: sessionId, data: { changes } }\n      ]);\n\n      // Update progress - starting main operation\n      processingState.progress = { percentage: 50, stage: 'processing_changes' };\n      await this.publishAIProcessingProgressEvent(requestId, processingState.progress);\n\n      // Execute the main operation with retry and recovery\n      const operationResult = await retryManager.executeWithRetry(\n        operationId,\n        sessionId,\n        async () => {\n          // Update progress during operation\n          processingState.progress = { percentage: 70, stage: 'applying_changes' };\n          await this.publishAIProcessingProgressEvent(requestId, processingState.progress);\n          \n          return await this.performAISubmissionOperation(\n            changes,\n            aiProvider,\n            aiModel,\n            processingContext,\n            options,\n            sessionId!,\n            session,\n            errorManager,\n            transactionId\n          );\n        },\n        {\n          maxRetries: options.maxRetries || 3,\n          retryableErrorTypes: [\n            (await import('./error-handling/ai-submission-error-manager')).ErrorType.NETWORK,\n            (await import('./error-handling/ai-submission-error-manager')).ErrorType.EDITORIAL_ENGINE,\n            (await import('./error-handling/ai-submission-error-manager')).ErrorType.RATE_LIMITING\n          ]\n        }\n      );\n\n      if (operationResult.success && operationResult.result) {\n        // Update progress - finalizing\n        processingState.progress = { percentage: 90, stage: 'finalizing' };\n        await this.publishAIProcessingProgressEvent(requestId, processingState.progress);\n        \n        // Commit transaction on success\n        if (transactionId) {\n          errorManager.commitTransaction(transactionId);\n        }\n\n        // Update processing state to completed\n        processingState.status = 'completed';\n        processingState.progress = { percentage: 100, stage: 'completed' };\n\n        // Move from active to completed queue\n        const activeIndex = this.processingQueue.active.findIndex(state => state.requestId === requestId);\n        if (activeIndex !== -1) {\n          this.processingQueue.active.splice(activeIndex, 1);\n          this.processingQueue.completed.push(processingState);\n        }\n\n        // Update plugin performance metrics if plugin system is active\n        if (this.pluginRegistry && (options as any).pluginAuthContext) {\n          const pluginId = (options as any).pluginAuthContext.pluginId;\n          // Performance tracking would be implemented in the registry\n          console.log(`[TrackEditsPlugin] Successful AI submission recorded for plugin: ${pluginId}`);\n        }\n\n        // Populate successful result\n        Object.assign(result, operationResult.result);\n        result.success = true;\n\n        // Publish AI processing complete event for platform coordination\n        await this.publishAIProcessingCompleteEvent({\n          requestId,\n          results: {\n            changeIds: result.changeIds,\n            changeGroupId: processingContext?.groupId,\n            summary: `AI submission completed: ${result.changeIds.length} changes applied`,\n            confidence: 0.9, // Default confidence\n            appliedConstraints: processingContext?.constraints || []\n          },\n          metrics: {\n            totalTokens: processingState.metrics?.tokensProcessed || 0,\n            processingTime: Date.now() - processingState.operation.startTime,\n            qualityScore: 0.8, // Default quality score\n            constraintCompliance: 1.0 // Default compliance\n          },\n          recommendations: {\n            suggestedReview: result.changeIds.length > 10,\n            recommendedBatching: result.changeIds.length > 5 ? 'group' : 'individual',\n            followupActions: []\n          }\n        }, sessionId);\n\n        if (operationResult.fallbackUsed) {\n          result.warnings.push(`Operation completed using fallback strategy: ${operationResult.fallbackUsed}`);\n        }\n\n        if (operationResult.attempts > 1) {\n          result.warnings.push(`Operation succeeded after ${operationResult.attempts} attempts`);\n        }\n\n      } else {\n        // Handle operation failure\n        processingState.status = 'error';\n        processingState.errorDetails = {\n          type: 'operation',\n          message: operationResult.error?.message || 'Operation failed',\n          recoverable: operationResult.error?.rollbackRequired !== true\n        };\n\n        // Move from active to failed queue\n        const activeIndex = this.processingQueue.active.findIndex(state => state.requestId === requestId);\n        if (activeIndex !== -1) {\n          this.processingQueue.active.splice(activeIndex, 1);\n          this.processingQueue.failed.push(processingState);\n        }\n\n        if (transactionId && operationResult.error?.rollbackRequired) {\n          const rollbackResult = await errorManager.rollbackTransaction(\n            transactionId,\n            operationResult.error,\n            {\n              sessionManager: this,\n              editTracker: this.editTracker,\n              sessionId: sessionId\n            }\n          );\n\n          if (!rollbackResult.success) {\n            result.errors.push(...rollbackResult.errors);\n            result.warnings.push(...rollbackResult.warnings);\n          } else {\n            result.warnings.push('Changes have been rolled back due to operation failure');\n          }\n        }\n\n        // Record plugin error if plugin system is active\n        if (this.pluginRegistry && (options as any).pluginAuthContext && operationResult.error) {\n          const pluginId = (options as any).pluginAuthContext.pluginId;\n          await this.pluginRegistry.recordPluginError(pluginId, operationResult.error, {\n            operation: 'ai_submission',\n            sessionId,\n            changeCount: changes.length\n          });\n        }\n\n        if (operationResult.error) {\n          result.errors.push(operationResult.error.message);\n          \n          // Publish AI processing error event for platform coordination\n          await this.publishAIProcessingErrorEvent(requestId, 'operation', operationResult.error.message, {\n            stage: 'operation_execution',\n            partialResults: [],\n            resourceUsage: { memory: 0, cpu: 0 }\n          }, {\n            automaticRetryAvailable: false,\n            manualInterventionRequired: true,\n            suggestedActions: ['Check logs', 'Retry with different parameters'],\n            fallbackOptions: []\n          });\n          \n          // Add user-friendly error message\n          const userMessage = errorManager.generateUserErrorMessage(operationResult.error);\n          if (userMessage !== operationResult.error.message) {\n            result.warnings.push(userMessage);\n          }\n        } else {\n          result.errors.push('Operation failed after all retry attempts');\n          \n          // Publish generic error event\n          await this.publishAIProcessingErrorEvent(requestId, 'retry_exhausted', 'Operation failed after all retry attempts');\n        }\n      }\n\n      return result;\n\n    } catch (criticalError) {\n      // Handle critical/unexpected errors\n      const errorContext = {\n        operation: 'ai_submission',\n        sessionId: options.sessionId || 'unknown',\n        changeIds: changes.map(c => c.id).filter(Boolean),\n        transactionId,\n        aiProvider,\n        aiModel\n      };\n\n      // Update processing state\n      const processingState = this.aiProcessingStates.get(operationId);\n      if (processingState) {\n        processingState.status = 'error';\n        processingState.errorDetails = {\n          type: 'critical',\n          message: criticalError.message,\n          recoverable: false\n        };\n\n        // Move to failed queue\n        const activeIndex = this.processingQueue.active.findIndex(state => state.requestId === operationId);\n        if (activeIndex !== -1) {\n          this.processingQueue.active.splice(activeIndex, 1);\n          this.processingQueue.failed.push(processingState);\n        }\n      }\n\n      const handledError = await errorManager.handleError(criticalError, errorContext);\n      \n      // Record critical error for plugin if applicable\n      if (this.pluginRegistry && (options as any).pluginAuthContext) {\n        const pluginId = (options as any).pluginAuthContext.pluginId;\n        await this.pluginRegistry.recordPluginError(pluginId, handledError.error, errorContext);\n      }\n      \n      // Attempt rollback if transaction exists\n      if (transactionId && handledError.rollbackRequired) {\n        try {\n          await errorManager.rollbackTransaction(\n            transactionId,\n            handledError.error,\n            {\n              sessionManager: this,\n              editTracker: this.editTracker,\n              sessionId: options.sessionId || 'unknown'\n            }\n          );\n          result.warnings.push('System recovered from critical error - changes have been rolled back');\n        } catch (rollbackError) {\n          result.errors.push('Critical error occurred and rollback failed - manual recovery may be required');\n          console.error('[TrackEditsPlugin] Critical rollback failure:', rollbackError);\n        }\n      }\n\n      // Publish critical error event\n      await this.publishAIProcessingErrorEvent(operationId, 'critical', handledError.error.message, {\n        stage: 'critical_error',\n        partialResults: [],\n        resourceUsage: { memory: 0, cpu: 0 }\n      }, {\n        automaticRetryAvailable: false,\n        manualInterventionRequired: true,\n        suggestedActions: ['Check system logs', 'Restart plugin', 'Contact support'],\n        fallbackOptions: []\n      });\n\n      const userMessage = errorManager.generateUserErrorMessage(handledError.error);\n      result.errors.push(userMessage);\n      \n      // Log the critical error for debugging\n      console.error('[TrackEditsPlugin] Critical error in submitChangesFromAI:', {\n        error: criticalError,\n        context: errorContext,\n        categorizedError: handledError.error,\n        timestamp: new Date().toISOString()\n      });\n\n      return result;\n    } finally {\n      // Cleanup and maintenance\n      errorManager.cleanup();\n      retryManager.cleanup();\n      \n      // Clean up processing locks\n      this.processingLocks.delete(operationId);\n    }\n  }\n\n  /**\n   * Enhanced event integration using standardized V2 event schemas\n   */\n  private async publishEnhancedChangeEvent(\n    eventType: string,\n    payload: any,\n    sessionId?: string,\n    priority: import('./event-bus-integration').EventPriority = 1,\n    persistence: import('./event-bus-integration').EventPersistence = 'session'\n  ): Promise<void> {\n    try {\n      const { \n        WriterrlEventFactory, \n        EventPriority, \n        EventPersistence \n      } = await import('./event-bus-integration');\n      \n      // Create enhanced event with proper metadata\n      const baseEvent = WriterrlEventFactory.createBaseEvent(\n        eventType,\n        'track-edits',\n        priority,\n        persistence\n      );\n      \n      const enhancedEvent = {\n        ...baseEvent,\n        type: eventType,\n        sessionId,\n        documentId: this.app.workspace.getActiveFile()?.path,\n        targetPlugins: this.getTargetPluginsForEvent(eventType),\n        payload: {\n          ...payload,\n          pluginVersion: this.manifest.version,\n          timestamp: Date.now(),\n          correlationId: baseEvent.metadata.correlationId\n        }\n      };\n      \n      // Use existing event bus connection\n      if (this.eventBusConnection?.isConnected()) {\n        await this.eventBusConnection.publish(eventType, enhancedEvent as any);\n      } else {\n        // Fallback to legacy event publishing\n        await this.publishChangeEvent(eventType, payload, sessionId);\n      }\n      \n    } catch (error) {\n      console.error(`Failed to publish enhanced event ${eventType}:`, error);\n      // Fallback to legacy event publishing\n      await this.publishChangeEvent(eventType, payload, sessionId);\n    }\n  }\n  \n  /**\n   * Determine target plugins based on event type using routing configuration\n   */\n  private getTargetPluginsForEvent(eventType: string): string[] {\n    const { STANDARD_EVENT_ROUTING } = require('./event-coordination-patterns');\n    const routing = STANDARD_EVENT_ROUTING[eventType];\n    return routing?.targetPlugins || ['writerr-chat', 'editorial-engine'];\n  }\n  \n  /**\n   * Start a cross-plugin workflow using the orchestration system\n   */\n  async startCrossPluginWorkflow(\n    workflowType: 'chat-to-editorial-to-track' | 'collaborative-edit' | 'batch-processing',\n    context: any\n  ): Promise<string> {\n    try {\n      const { \n        WorkflowOrchestrator, \n        WriterrlWorkflowPatterns \n      } = await import('./event-coordination-patterns');\n      \n      if (!this.workflowOrchestrator) {\n        this.workflowOrchestrator = new WorkflowOrchestrator();\n      }\n      \n      const workflowId = `workflow_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      let steps;\n      switch (workflowType) {\n        case 'chat-to-editorial-to-track':\n          steps = WriterrlWorkflowPatterns.getChatToEditorialToTrackWorkflow(workflowId);\n          break;\n        case 'collaborative-edit':\n          steps = WriterrlWorkflowPatterns.getCollaborativeEditWorkflow(workflowId);\n          break;\n        case 'batch-processing':\n          steps = WriterrlWorkflowPatterns.getBatchProcessingWorkflow(workflowId);\n          break;\n        default:\n          throw new Error(`Unknown workflow type: ${workflowType}`);\n      }\n      \n      const started = await this.workflowOrchestrator.startWorkflow(\n        workflowId,\n        workflowType,\n        steps,\n        context\n      );\n      \n      if (!started) {\n        throw new Error('Failed to start workflow');\n      }\n      \n      return workflowId;\n      \n    } catch (error) {\n      console.error(`Failed to start workflow ${workflowType}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Core AI submission operation (extracted for retry logic)\n   */\n  private async performAISubmissionOperation(\n    changes: EditChange[],\n    aiProvider: string,\n    aiModel: string,\n    processingContext?: AIProcessingContext,\n    options: SubmitChangesFromAIOptions = {},\n    sessionId: string,\n    session: EditSession,\n    errorManager: any, // AISubmissionErrorManager\n    transactionId?: string\n  ): Promise<SubmitChangesFromAIResult> {\n    // Enhanced AI metadata validation with Editorial Engine support\n    if (options.strictValidation !== false && !options.bypassValidation) {\n      try {\n        // Determine validation environment\n        const environment = process.env.NODE_ENV === 'production' ? 'production' : \n                           process.env.NODE_ENV === 'test' ? 'testing' : 'development';\n        \n        // Get environment-specific validation config\n        const validationConfig = AIMetadataValidator.getValidationConfig(environment);\n        \n        // Override with user-provided options\n        const validationOptions = {\n          ...validationConfig,\n          strictMode: options.strictValidation ?? validationConfig.strictMode,\n          bypassValidation: options.bypassValidation ?? false,\n          editorialEngineMode: options.editorialEngineMode ?? validationConfig.editorialEngineMode,\n          enableRateLimiting: validationConfig.enableRateLimiting,\n          logSecurityViolations: validationConfig.logSecurityViolations\n        };\n\n        const validationResult = AIMetadataValidator.validateAIMetadata(\n          aiProvider,\n          aiModel,\n          processingContext,\n          new Date(),\n          validationOptions\n        );\n\n        if (!validationResult.isValid) {\n          // Create validation error\n          const validationError = new Error(`Validation failed: ${validationResult.errors.join(', ')}`);\n          (validationError as any).code = 'VALIDATION_ERROR';\n          (validationError as any).details = validationResult;\n          throw validationError;\n        }\n\n        // Use sanitized metadata from validation\n        aiProvider = validationResult.sanitizedMetadata?.aiProvider || aiProvider;\n        aiModel = validationResult.sanitizedMetadata?.aiModel || aiModel;\n        processingContext = validationResult.sanitizedMetadata?.processingContext || processingContext;\n        \n        // Track security threats even for successful validations\n        if (validationResult.securityThreats.length > 0) {\n          console.warn('[TrackEditsPlugin] Security threats detected and sanitized:', validationResult.securityThreats);\n        }\n      } catch (validationError) {\n        // Let the validation error bubble up to be handled by retry system\n        throw validationError;\n      }\n    }\n\n    // Advanced change grouping logic if enabled\n    let changeGroupingResult;\n    let changeGroupId;\n    \n    if (options.groupChanges && changes.length >= 2) {\n      try {\n        // Determine editorial operation type\n        const operationType: EditorialOperationType = options.editorialOperation || \n          this.inferEditorialOperationType(changes, processingContext, options);\n        \n        const operationDescription = options.customOperationDescription ||\n          this.generateOperationDescription(operationType, changes.length);\n\n        // Create batches using the batch manager\n        changeGroupingResult = this.batchManager.createBatches(\n          changes,\n          sessionId,\n          operationType,\n          operationDescription\n        );\n        \n        // Use the primary group ID if groups were created\n        if (changeGroupingResult.groups.length > 0) {\n          changeGroupId = changeGroupingResult.groups[0].groupId;\n        }\n      } catch (batchError) {\n        // Convert batch error and let retry system handle it\n        const batchErrorWithCode = new Error(`Batch processing failed: ${batchError instanceof Error ? batchError.message : String(batchError)}`);\n        (batchErrorWithCode as any).code = 'BATCH_ERROR';\n        throw batchErrorWithCode;\n      }\n    } else if (options.groupChanges) {\n      // Simple grouping fallback for small change sets\n      changeGroupId = generateId();\n    }\n\n    // Enhanced batch validation for individual changes\n    const validatedChanges: EditChange[] = [];\n    \n    for (let i = 0; i < changes.length; i++) {\n      const change = changes[i];\n      \n      // Validate each change's content for security\n      if (change.content) {\n        const contentThreats = this.validateChangeContent(change.content);\n        if (contentThreats.length > 0) {\n          console.warn(`Change ${i} content security issues:`, contentThreats);\n        }\n      }\n      \n      // Enhanced change validation\n      const changeId = change.id || `${sessionId}_${Date.now()}_${i}`;\n      \n      // Create enhanced processing context with additional metadata\n      const enhancedProcessingContext: EnhancedAIProcessingContext = {\n        ...processingContext,\n        // Add conversation context if provided\n        ...(options.conversationContext && {\n          conversationId: options.conversationContext.conversationId,\n          messageId: options.conversationContext.messageId,\n          userPrompt: options.conversationContext.userPrompt\n        }),\n        // Add change group ID if grouping is enabled\n        ...(changeGroupId && { changeGroupId }),\n        // Add Editorial Engine metadata\n        metadata: {\n          ...processingContext?.metadata,\n          changeIndex: i,\n          totalChanges: changes.length,\n          validationTimestamp: new Date().toISOString(),\n          securityValidated: true,\n          transactionId\n        }\n      };\n\n      const validatedChange: EditChange = {\n        ...change,\n        id: changeId,\n        timestamp: change.timestamp || Date.now(),\n        aiProvider,\n        aiModel,\n        processingContext: enhancedProcessingContext,\n        aiTimestamp: new Date(),\n        author: change.author || 'Editorial Engine'\n      };\n      \n      validatedChanges.push(validatedChange);\n    }\n\n    // Record changes using existing EditTracker AI recording method with enhanced options\n    let recordResult;\n    try {\n      recordResult = this.editTracker.recordAIChanges(\n        sessionId,\n        validatedChanges,\n        aiProvider,\n        aiModel,\n        processingContext,\n        new Date(),\n        {\n          bypassValidation: options.bypassValidation || false,\n          strictMode: options.strictValidation !== false,\n          // Pass through Editorial Engine mode\n          editorialEngineMode: options.editorialEngineMode\n        }\n      );\n\n      if (!recordResult.success) {\n        const recordError = new Error(`Failed to record changes: ${recordResult.errors.join(', ')}`);\n        (recordError as any).code = 'STORAGE_ERROR';\n        (recordError as any).details = recordResult;\n        throw recordError;\n      }\n    } catch (recordError) {\n      throw recordError;\n    }\n\n    // Build successful result\n    const operationResult: SubmitChangesFromAIResult = {\n      success: true,\n      sessionId: sessionId,\n      changeIds: validatedChanges.map(change => change.id!),\n      errors: [],\n      warnings: [...(recordResult?.warnings || [])],\n      changeGroupId: changeGroupId,\n      groupingResult: changeGroupingResult,\n      \n      // Add validation summary to result\n      validationSummary: {\n        totalChanges: validatedChanges.length,\n        provider: aiProvider,\n        model: aiModel,\n        validationMode: options.editorialEngineMode ? 'Editorial Engine' : 'Standard',\n        securityChecksEnabled: options.strictValidation !== false\n      }\n    };\n\n    // Auto-save session if enabled\n    if (this.settings.autoSave) {\n      try {\n        await this.saveCurrentSession();\n      } catch (saveError) {\n        // Non-critical error - warn but don't fail the operation\n        operationResult.warnings.push('Auto-save failed but changes were recorded successfully');\n        console.warn('[TrackEditsPlugin] Auto-save failed:', saveError);\n      }\n    }\n\n    return operationResult;\n  }\n\n  /**\n   * Validates change content for security threats\n   * Used by submitChangesFromAI for individual change validation\n   */\n  private validateChangeContent(content: string): string[] {\n    const threats: string[] = [];\n\n    // Basic XSS detection\n    if (/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi.test(content)) {\n      threats.push('Script injection detected');\n    }\n\n    // HTML injection detection\n    if (/<iframe|<object|<embed|<applet/gi.test(content)) {\n      threats.push('Potentially dangerous HTML elements');\n    }\n\n    // JavaScript protocol detection\n    if (/javascript:|data:|vbscript:/gi.test(content)) {\n      threats.push('Dangerous URL protocols');\n    }\n\n    // SQL injection patterns in content\n    if (/(\\bUNION\\b|\\bSELECT\\b|\\bINSERT\\b|\\bUPDATE\\b|\\bDELETE\\b|\\bDROP\\b)/gi.test(content)) {\n      threats.push('SQL injection patterns');\n    }\n\n    // Command injection patterns\n    if (/[;&|`$(){}[\\]\\\\]/.test(content) && content.length > 100) {\n      threats.push('Command injection characters in large content');\n    }\n\n    return threats;\n  }\n\n  /**\n   * Convenience method for single change submission\n   * Wraps submitChangesFromAI for single EditChange objects\n   */\n  async submitSingleChangeFromAI(\n    change: EditChange,\n    aiProvider: string,\n    aiModel: string,\n    processingContext?: AIProcessingContext,\n    options: SubmitChangesFromAIOptions = {}\n  ): Promise<SubmitChangesFromAIResult> {\n    return this.submitChangesFromAI([change], aiProvider, aiModel, processingContext, options);\n  }\n\n  /**\n   * Get changes by group ID for batch processing analysis\n   * Useful for analyzing related changes submitted as a group\n   */\n  getChangesByGroupId(sessionId: string, groupId: string): EditChange[] {\n    const session = this.editTracker.getSession(sessionId);\n    if (!session) return [];\n\n    return session.changes.filter(change => \n      (change.processingContext as EnhancedAIProcessingContext)?.changeGroupId === groupId\n    );\n  }\n\n  /**\n   * Infer editorial operation type from changes and context\n   */\n  private inferEditorialOperationType(\n    changes: EditChange[],\n    processingContext?: AIProcessingContext,\n    options?: SubmitChangesFromAIOptions\n  ): EditorialOperationType {\n    // Check if context provides hints about operation type\n    if (processingContext?.mode) {\n      const mode = processingContext.mode.toLowerCase();\n      if (mode.includes('proofreading') || mode.includes('grammar') || mode.includes('spelling')) {\n        return 'proofreading';\n      }\n      if (mode.includes('copy-edit') || mode.includes('comprehensive')) {\n        return 'copy-edit-pass';\n      }\n      if (mode.includes('developmental') || mode.includes('structural')) {\n        return 'developmental-feedback';\n      }\n      if (mode.includes('style') || mode.includes('tone') || mode.includes('voice')) {\n        return 'style-refinement';\n      }\n      if (mode.includes('format') || mode.includes('structure')) {\n        return 'formatting';\n      }\n      if (mode.includes('expand') || mode.includes('clarify') || mode.includes('elaborate')) {\n        return 'content-expansion';\n      }\n      if (mode.includes('reduce') || mode.includes('trim') || mode.includes('condense')) {\n        return 'content-reduction';\n      }\n      if (mode.includes('rewrite') || mode.includes('restructure')) {\n        return 'rewriting';\n      }\n    }\n\n    // Check conversation context for user prompts\n    if (options?.conversationContext?.userPrompt) {\n      const prompt = options.conversationContext.userPrompt.toLowerCase();\n      if (prompt.includes('proofread') || prompt.includes('check grammar') || prompt.includes('fix spelling')) {\n        return 'proofreading';\n      }\n      if (prompt.includes('copy edit') || prompt.includes('comprehensive edit')) {\n        return 'copy-edit-pass';\n      }\n      if (prompt.includes('style') || prompt.includes('tone') || prompt.includes('voice')) {\n        return 'style-refinement';\n      }\n      if (prompt.includes('develop') || prompt.includes('structure') || prompt.includes('organize')) {\n        return 'developmental-feedback';\n      }\n    }\n\n    // Analyze change patterns to infer operation type\n    const hasSmallChanges = changes.some(c => \n      (c.text && c.text.length < 20) || (c.removedText && c.removedText.length < 20)\n    );\n    const hasLargeChanges = changes.some(c => \n      (c.text && c.text.length > 100) || (c.removedText && c.removedText.length > 100)\n    );\n    const hasOnlyReplacements = changes.every(c => c.type === 'replace');\n    const hasMostlyInsertions = changes.filter(c => c.type === 'insert').length > changes.length * 0.6;\n    const hasMostlyDeletions = changes.filter(c => c.type === 'delete').length > changes.length * 0.6;\n\n    // Pattern-based inference\n    if (hasOnlyReplacements && hasSmallChanges && !hasLargeChanges) {\n      return 'proofreading';\n    }\n    if (hasMostlyInsertions) {\n      return 'content-expansion';\n    }\n    if (hasMostlyDeletions) {\n      return 'content-reduction';\n    }\n    if (hasLargeChanges) {\n      return 'rewriting';\n    }\n\n    // Default fallback\n    return 'copy-edit-pass';\n  }\n\n  /**\n   * Generate operation description based on type and change count\n   */\n  private generateOperationDescription(\n    operationType: EditorialOperationType, \n    changeCount: number\n  ): string {\n    const baseDescriptions = {\n      'copy-edit-pass': 'Comprehensive copy editing',\n      'proofreading': 'Grammar and spelling corrections',\n      'developmental-feedback': 'Structural improvements',\n      'style-refinement': 'Style and tone adjustments',\n      'fact-checking': 'Accuracy verification',\n      'formatting': 'Document formatting',\n      'content-expansion': 'Content additions',\n      'content-reduction': 'Content trimming',\n      'rewriting': 'Content restructuring',\n      'custom': 'Editorial changes'\n    };\n\n    const base = baseDescriptions[operationType];\n    return `${base} (${changeCount} change${changeCount !== 1 ? 's' : ''})`;\n  }\n\n  /**\n   * Get batch manager instance for external access\n   */\n  public getBatchManager(): ChangeBatchManager {\n    return this.batchManager;\n  }\n}", "import { App, PluginSettingTab, Setting } from 'obsidian';\nimport TrackEditsPlugin from './main';\n\nexport class TrackEditsSettingsTab extends PluginSettingTab {\n  plugin: TrackEditsPlugin;\n\n  constructor(app: App, plugin: TrackEditsPlugin) {\n    super(app, plugin);\n    this.plugin = plugin;\n  }\n\n  display(): void {\n    const { containerEl } = this;\n    containerEl.empty();\n\n    containerEl.createEl('h2', { text: 'Track Edits Settings' });\n\n    new Setting(containerEl)\n      .setName('Enable tracking')\n      .setDesc('Automatically track edits when documents are modified')\n      .addToggle(toggle => toggle\n        .setValue(this.plugin.settings.enableTracking)\n        .onChange(async (value) => {\n          this.plugin.settings.enableTracking = value;\n          await this.plugin.saveSettings();\n          if (value) {\n            this.plugin.startTracking();\n          } else {\n            this.plugin.stopTracking();\n          }\n        }));\n\n    new Setting(containerEl)\n      .setName('Show line numbers')\n      .setDesc('Display line numbers in the editor')\n      .addToggle(toggle => toggle\n        .setValue(this.plugin.settings.showLineNumbers)\n        .onChange(async (value) => {\n          this.plugin.settings.showLineNumbers = value;\n          await this.plugin.saveSettings();\n        }));\n\n    new Setting(containerEl)\n      .setName('Highlight changes')\n      .setDesc('Visually highlight recent changes in the editor')\n      .addToggle(toggle => toggle\n        .setValue(this.plugin.settings.highlightChanges)\n        .onChange(async (value) => {\n          this.plugin.settings.highlightChanges = value;\n          await this.plugin.saveSettings();\n        }));\n\n    new Setting(containerEl)\n      .setName('Data retention')\n      .setDesc('Number of days to keep edit history (0 = keep forever)')\n      .addSlider(slider => slider\n        .setLimits(0, 365, 1)\n        .setValue(this.plugin.settings.retentionDays)\n        .setDynamicTooltip()\n        .onChange(async (value) => {\n          this.plugin.settings.retentionDays = value;\n          await this.plugin.saveSettings();\n        }));\n\n    new Setting(containerEl)\n      .setName('Color scheme')\n      .setDesc('Choose the color scheme for change highlighting')\n      .addDropdown(dropdown => dropdown\n        .addOption('default', 'Default')\n        .addOption('colorblind', 'Colorblind friendly')\n        .addOption('dark', 'Dark theme optimized')\n        .setValue(this.plugin.settings.colorScheme)\n        .onChange(async (value: 'default' | 'colorblind' | 'dark') => {\n          this.plugin.settings.colorScheme = value;\n          await this.plugin.saveSettings();\n        }));\n\n    new Setting(containerEl)\n      .setName('Auto-save sessions')\n      .setDesc('Automatically save edit sessions as they occur')\n      .addToggle(toggle => toggle\n        .setValue(this.plugin.settings.autoSave)\n        .onChange(async (value) => {\n          this.plugin.settings.autoSave = value;\n          await this.plugin.saveSettings();\n        }));\n\n    new Setting(containerEl)\n      .setName('Export format')\n      .setDesc('Default format for exporting edit sessions')\n      .addDropdown(dropdown => dropdown\n        .addOption('json', 'JSON')\n        .addOption('csv', 'CSV')\n        .addOption('markdown', 'Markdown')\n        .setValue(this.plugin.settings.exportFormat)\n        .onChange(async (value: 'json' | 'csv' | 'markdown') => {\n          this.plugin.settings.exportFormat = value;\n          await this.plugin.saveSettings();\n        }));\n\n    // Event Bus Integration section\n    containerEl.createEl('h3', { text: 'Event Bus Integration' });\n\n    new Setting(containerEl)\n      .setName('Enable event bus')\n      .setDesc('Enable cross-plugin coordination through the Writerr event bus')\n      .addToggle(toggle => toggle\n        .setValue(this.plugin.settings.enableEventBus)\n        .onChange(async (value) => {\n          this.plugin.settings.enableEventBus = value;\n          await this.plugin.saveSettings();\n        }));\n\n    new Setting(containerEl)\n      .setName('Event bus debug mode')\n      .setDesc('Enable debug logging for event bus operations')\n      .addToggle(toggle => toggle\n        .setValue(this.plugin.settings.eventBusDebugMode)\n        .onChange(async (value) => {\n          this.plugin.settings.eventBusDebugMode = value;\n          await this.plugin.saveSettings();\n        }));\n\n    new Setting(containerEl)\n      .setName('Max reconnection attempts')\n      .setDesc('Maximum number of reconnection attempts when event bus is unavailable')\n      .addSlider(slider => slider\n        .setLimits(1, 10, 1)\n        .setValue(this.plugin.settings.eventBusMaxReconnectAttempts)\n        .setDynamicTooltip()\n        .onChange(async (value) => {\n          this.plugin.settings.eventBusMaxReconnectAttempts = value;\n          await this.plugin.saveSettings();\n        }));\n\n    new Setting(containerEl)\n      .setName('Reconnection delay')\n      .setDesc('Delay between reconnection attempts (milliseconds)')\n      .addSlider(slider => slider\n        .setLimits(500, 5000, 100)\n        .setValue(this.plugin.settings.eventBusReconnectDelay)\n        .setDynamicTooltip()\n        .onChange(async (value) => {\n          this.plugin.settings.eventBusReconnectDelay = value;\n          await this.plugin.saveSettings();\n        }));\n\n    // Actions section\n    containerEl.createEl('h3', { text: 'Actions' });\n\n    new Setting(containerEl)\n      .setName('Export current session')\n      .setDesc('Export the current editing session')\n      .addButton(button => button\n        .setButtonText('Export')\n        .setCta()\n        .onClick(() => {\n          if (this.plugin.currentSession) {\n            this.plugin.exportSession(this.plugin.currentSession.id);\n          }\n        }));\n\n    new Setting(containerEl)\n      .setName('Clear all history')\n      .setDesc('Delete all stored edit history (cannot be undone)')\n      .addButton(button => button\n        .setButtonText('Clear')\n        .setWarning()\n        .onClick(() => {\n          this.plugin.clearEditHistory();\n        }));\n  }\n}", "// Shared utilities for all Writerr Obsidian plugins\n\nexport function generateId(): string {\n  return Math.random().toString(36).substr(2, 9);\n}\n\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean;\n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  };\n}\n\nexport function formatTimestamp(timestamp: number): string {\n  return new Date(timestamp).toLocaleString();\n}\n\nexport function getWordCount(text: string): number {\n  return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n}\n\nexport function getCharacterCount(text: string): number {\n  return text.length;\n}\n\nexport function sanitizeFilename(filename: string): string {\n  return filename.replace(/[^a-z0-9]/gi, '_').toLowerCase();\n}\n\nexport function exportToJSON(data: any): string {\n  return JSON.stringify(data, null, 2);\n}\n\nexport function parseMarkdown(content: string): { frontmatter: Record<string, any>; body: string } {\n  const frontmatterRegex = /^---\\s*\\n(.*?)\\n---\\s*\\n(.*)$/s;\n  const match = content.match(frontmatterRegex);\n  \n  if (match) {\n    try {\n      const frontmatter = JSON.parse(match[1]);\n      return { frontmatter, body: match[2] };\n    } catch {\n      // If JSON parsing fails, treat as YAML or plain text\n      return { frontmatter: {}, body: content };\n    }\n  }\n  \n  return { frontmatter: {}, body: content };\n}\n\nexport function escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}", "/**\n * Sanitization utilities for AI metadata security\n * Provides comprehensive string cleaning and data validation utilities\n * to prevent XSS, injection attacks, and data corruption\n */\n\nexport interface SanitizationOptions {\n  maxLength?: number;\n  preserveNewlines?: boolean;\n  allowBasicFormatting?: boolean;\n  strictMode?: boolean;\n}\n\nexport class SanitizationUtils {\n  // Known malicious patterns for security detection\n  private static readonly SCRIPT_PATTERNS = [\n    /<script[\\s\\S]*?<\\/script>/gi,\n    /<iframe[\\s\\S]*?<\\/iframe>/gi,\n    /<object[\\s\\S]*?<\\/object>/gi,\n    /<embed[\\s\\S]*?>/gi,\n    /<form[\\s\\S]*?<\\/form>/gi,\n    /<input[\\s\\S]*?>/gi,\n    /<textarea[\\s\\S]*?<\\/textarea>/gi,\n    /<select[\\s\\S]*?<\\/select>/gi\n  ];\n\n  private static readonly PROTOCOL_PATTERNS = [\n    /javascript:/gi,\n    /data:/gi,\n    /vbscript:/gi,\n    /livescript:/gi,\n    /mocha:/gi,\n    /file:/gi\n  ];\n\n  private static readonly EVENT_ATTRIBUTES = [\n    /on\\w+\\s*=/gi\n  ];\n\n  // Control characters to remove (except allowed whitespace)\n  private static readonly CONTROL_CHARS = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x9F]/g;\n\n  /**\n   * Sanitizes a string by removing dangerous content and limiting length\n   */\n  static sanitizeString(\n    input: string, \n    options: SanitizationOptions = {}\n  ): string {\n    if (typeof input !== 'string') {\n      return '';\n    }\n\n    const {\n      maxLength = 10000,\n      preserveNewlines = true,\n      allowBasicFormatting = false,\n      strictMode = true\n    } = options;\n\n    let sanitized = input;\n\n    // Remove null bytes and control characters\n    sanitized = sanitized.replace(this.CONTROL_CHARS, '');\n\n    // Remove script tags and dangerous elements\n    for (const pattern of this.SCRIPT_PATTERNS) {\n      sanitized = sanitized.replace(pattern, '');\n    }\n\n    // Remove dangerous protocols\n    for (const pattern of this.PROTOCOL_PATTERNS) {\n      sanitized = sanitized.replace(pattern, 'removed:');\n    }\n\n    // Remove event attributes\n    for (const pattern of this.EVENT_ATTRIBUTES) {\n      sanitized = sanitized.replace(pattern, '');\n    }\n\n    // In strict mode, remove all HTML tags\n    if (strictMode) {\n      sanitized = sanitized.replace(/<[^>]*>/g, '');\n    } else if (!allowBasicFormatting) {\n      // Remove dangerous HTML but allow basic formatting\n      sanitized = sanitized.replace(/<(?!\\/?(b|i|em|strong|u|br|p)\\b)[^>]*>/gi, '');\n    }\n\n    // Normalize whitespace\n    if (!preserveNewlines) {\n      sanitized = sanitized.replace(/\\s+/g, ' ');\n    } else {\n      // Normalize spaces but preserve line breaks\n      sanitized = sanitized.replace(/[ \\t]+/g, ' ');\n      sanitized = sanitized.replace(/\\n\\s*\\n/g, '\\n\\n'); // Max 2 consecutive newlines\n    }\n\n    // Trim whitespace\n    sanitized = sanitized.trim();\n\n    // Truncate if too long\n    if (sanitized.length > maxLength) {\n      sanitized = this.truncateWithEllipsis(sanitized, maxLength);\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Sanitizes an array of strings (used for constraints)\n   */\n  static sanitizeStringArray(\n    input: string[], \n    maxItems: number = 50,\n    maxItemLength: number = 500\n  ): string[] {\n    if (!Array.isArray(input)) {\n      return [];\n    }\n\n    // Limit array size\n    const limited = input.slice(0, maxItems);\n\n    // Sanitize each item\n    return limited\n      .map(item => this.sanitizeString(item, { \n        maxLength: maxItemLength,\n        strictMode: true,\n        preserveNewlines: false\n      }))\n      .filter(item => item.length > 0); // Remove empty strings\n  }\n\n  /**\n   * Truncates a string and adds ellipsis, trying to preserve word boundaries\n   */\n  static truncateWithEllipsis(input: string, maxLength: number): string {\n    if (input.length <= maxLength) {\n      return input;\n    }\n\n    // Try to break at word boundary\n    const truncated = input.substring(0, maxLength - 3);\n    const lastSpace = truncated.lastIndexOf(' ');\n    \n    if (lastSpace > maxLength * 0.7) { // Only break at word if we don't lose too much\n      return truncated.substring(0, lastSpace) + '...';\n    }\n    \n    return truncated + '...';\n  }\n\n  /**\n   * Validates and sanitizes a provider name\n   */\n  static sanitizeAIProvider(provider: string): string {\n    if (typeof provider !== 'string') {\n      return '';\n    }\n\n    // Remove all non-alphanumeric characters except hyphens, underscores, and dots\n    let sanitized = provider.replace(/[^a-zA-Z0-9\\-_.]/g, '');\n    \n    // Limit length\n    sanitized = sanitized.substring(0, 100);\n    \n    // Trim any trailing/leading special chars\n    sanitized = sanitized.replace(/^[\\-_.]+|[\\-_.]+$/g, '');\n    \n    return sanitized;\n  }\n\n  /**\n   * Validates and sanitizes a model name\n   */\n  static sanitizeAIModel(model: string): string {\n    if (typeof model !== 'string') {\n      return '';\n    }\n\n    // Allow alphanumeric, hyphens, underscores, dots, colons, and slashes for model versions\n    let sanitized = model.replace(/[^a-zA-Z0-9\\-_.:\\/]/g, '');\n    \n    // Limit length\n    sanitized = sanitized.substring(0, 200);\n    \n    // Trim any trailing/leading special chars\n    sanitized = sanitized.replace(/^[\\-_.:\\/]+|[\\-_.:\\/]+$/g, '');\n    \n    return sanitized;\n  }\n\n  /**\n   * Sanitizes a mode string\n   */\n  static sanitizeMode(mode: string): string {\n    if (typeof mode !== 'string') {\n      return '';\n    }\n\n    // Allow only alphanumeric, hyphens, and underscores\n    let sanitized = mode.replace(/[^a-zA-Z0-9\\-_]/g, '');\n    \n    // Limit length\n    sanitized = sanitized.substring(0, 100);\n    \n    // Convert to lowercase for consistency\n    sanitized = sanitized.toLowerCase();\n    \n    return sanitized;\n  }\n\n  /**\n   * Validates that a timestamp is reasonable\n   */\n  static validateTimestamp(timestamp: Date | string | undefined): Date | null {\n    if (!timestamp) {\n      return null;\n    }\n\n    let date: Date;\n    \n    try {\n      if (timestamp instanceof Date) {\n        date = timestamp;\n      } else {\n        date = new Date(timestamp);\n      }\n    } catch (error) {\n      return null;\n    }\n\n    // Check if date is valid\n    if (isNaN(date.getTime())) {\n      return null;\n    }\n\n    const now = new Date();\n    const oneMinuteFromNow = new Date(now.getTime() + 60000); // Allow 1 minute clock skew\n    const oneYearAgo = new Date(now.getTime() - (365 * 24 * 60 * 60 * 1000));\n\n    // Reject future dates (with small tolerance) or very old dates\n    if (date > oneMinuteFromNow || date < oneYearAgo) {\n      return null;\n    }\n\n    return date;\n  }\n\n  /**\n   * Calculates the serialized size of an object for storage limits\n   */\n  static calculateSerializedSize(obj: any): number {\n    try {\n      return JSON.stringify(obj).length;\n    } catch (error) {\n      return 0;\n    }\n  }\n\n  /**\n   * Deep clones and sanitizes nested objects to prevent prototype pollution\n   */\n  static sanitizeObject(obj: any, maxDepth: number = 10): any {\n    if (maxDepth <= 0) {\n      return null;\n    }\n\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(item => this.sanitizeObject(item, maxDepth - 1));\n    }\n\n    // Create new object without prototype chain to prevent pollution\n    const sanitized: any = Object.create(null);\n    \n    for (const key in obj) {\n      // Skip prototype properties and dangerous keys\n      if (obj.hasOwnProperty(key) && !this.isDangerousKey(key)) {\n        sanitized[key] = this.sanitizeObject(obj[key], maxDepth - 1);\n      }\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Checks for dangerous object keys that could cause prototype pollution\n   */\n  private static isDangerousKey(key: string): boolean {\n    const dangerous = [\n      '__proto__',\n      'constructor',\n      'prototype',\n      '__defineGetter__',\n      '__defineSetter__',\n      '__lookupGetter__',\n      '__lookupSetter__'\n    ];\n    \n    return dangerous.includes(key);\n  }\n\n  /**\n   * Detects potential security threats in input strings\n   */\n  static detectSecurityThreats(input: string): string[] {\n    const threats: string[] = [];\n    \n    if (typeof input !== 'string') {\n      return threats;\n    }\n\n    // Check for script patterns\n    for (const pattern of this.SCRIPT_PATTERNS) {\n      if (pattern.test(input)) {\n        threats.push('script_injection');\n        break;\n      }\n    }\n\n    // Check for dangerous protocols\n    for (const pattern of this.PROTOCOL_PATTERNS) {\n      if (pattern.test(input)) {\n        threats.push('dangerous_protocol');\n        break;\n      }\n    }\n\n    // Check for event handlers\n    for (const pattern of this.EVENT_ATTRIBUTES) {\n      if (pattern.test(input)) {\n        threats.push('event_handler');\n        break;\n      }\n    }\n\n    // Check for control characters\n    if (this.CONTROL_CHARS.test(input)) {\n      threats.push('control_characters');\n    }\n\n    // Check for extremely long strings that could cause DoS\n    if (input.length > 100000) {\n      threats.push('excessive_length');\n    }\n\n    return threats;\n  }\n}", "/**\n * Comprehensive AI metadata validation and sanitization system\n * Provides enterprise-grade validation for AI attribution data in EditChange objects\n */\n\nimport { AIProcessingContext } from '@shared/types';\nimport { SanitizationUtils } from './sanitization-utils';\n\nexport interface ValidationOptions {\n  strictMode?: boolean;\n  bypassValidation?: boolean; // For trusted internal calls\n  maxProcessingContextSize?: number;\n  logSecurityViolations?: boolean;\n  enableRateLimiting?: boolean; // Enable/disable rate limiting\n  editorialEngineMode?: boolean; // Enable Editorial Engine-specific validation\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  sanitizedValue?: any;\n  errors: string[];\n  warnings: string[];\n  securityThreats: string[];\n}\n\nexport interface AIMetadataValidationResult {\n  isValid: boolean;\n  sanitizedMetadata?: {\n    aiProvider?: string;\n    aiModel?: string;\n    processingContext?: AIProcessingContext;\n    aiTimestamp?: Date;\n  };\n  errors: string[];\n  warnings: string[];\n  securityThreats: string[];\n}\n\n/**\n * Comprehensive validator for AI metadata with security-focused sanitization\n */\nexport class AIMetadataValidator {\n  \n  // Whitelist of known AI providers with version support\n  private static readonly KNOWN_PROVIDERS = [\n    'openai',\n    'anthropic', \n    'google',\n    'cohere',\n    'huggingface',\n    'hugging-face',\n    'local',\n    'custom',\n    'azure',\n    'aws',\n    'gcp',\n    'microsoft',\n    'meta',\n    'facebook',\n    'claude',\n    'chatgpt',\n    'bard',\n    'palm',\n    'llama',\n    'mistral',\n    'together',\n    'perplexity',\n    'writerr', // Platform-specific provider\n    'editorial-engine' // Editorial Engine internal\n  ];\n\n  // Enhanced AI model validation patterns\n  private static readonly MODEL_PATTERNS = {\n    openai: /^(gpt-[34]\\.?5?-?(turbo|instruct)?(-\\d{4})?|text-davinci-\\d{3}|code-davinci-\\d{3})$/i,\n    anthropic: /^(claude-(instant-)?[123](\\.\\d+)?(-\\d+k)?|claude-[23]-(haiku|sonnet|opus)(-\\d{8})?)$/i,\n    google: /^(palm|bard|gemini)(-pro|-ultra)?(-\\d+)?$/i,\n    azure: /^(gpt-35-turbo|gpt-4)(-\\d{4})?$/i,\n    huggingface: /^[\\w\\-\\/]+\\/[\\w\\-\\.]+$/,\n    local: /^[\\w\\-\\.]+$/,\n    custom: /^[\\w\\-\\.]+$/\n  };\n\n  // Known AI processing modes with Editorial Engine extensions\n  private static readonly KNOWN_MODES = [\n    'edit',\n    'proofread', \n    'rewrite',\n    'expand',\n    'summarize',\n    'translate',\n    'format',\n    'style',\n    'tone',\n    'grammar',\n    'creative',\n    'technical',\n    'academic',\n    'casual',\n    'formal',\n    'custom',\n    // Editorial Engine specific modes\n    'constraint-based',\n    'rule-based',\n    'template-driven',\n    'conversation-context',\n    'batch-processing',\n    'multi-step',\n    'iterative',\n    'collaborative'\n  ];\n\n  // Editorial Engine constraint types\n  private static readonly CONSTRAINT_TYPES = [\n    'style-guide',\n    'tone-preference',\n    'length-limit',\n    'format-requirement',\n    'terminology',\n    'audience-target',\n    'brand-voice',\n    'content-policy',\n    'technical-standard',\n    'accessibility',\n    'seo-optimization',\n    'citation-style',\n    'language-level',\n    'cultural-sensitivity'\n  ];\n\n  // Rate limiting configuration\n  private static rateLimitStore = new Map<string, { count: number; lastReset: number }>();\n  private static readonly RATE_LIMIT_WINDOW = 60000; // 1 minute\n  private static readonly RATE_LIMIT_MAX_REQUESTS = 100; // per provider per minute\n\n  /**\n   * Enhanced validation method with Editorial Engine support\n   */\n  static validateAIMetadata(\n    aiProvider?: string,\n    aiModel?: string,\n    processingContext?: AIProcessingContext,\n    aiTimestamp?: Date | string,\n    options: ValidationOptions = {}\n  ): AIMetadataValidationResult {\n    const {\n      strictMode = true,\n      bypassValidation = false,\n      maxProcessingContextSize = 50000,\n      logSecurityViolations = true,\n      enableRateLimiting = true,\n      editorialEngineMode = false\n    } = options;\n\n    // Skip validation if bypassed (for trusted internal calls)\n    if (bypassValidation) {\n      return {\n        isValid: true,\n        sanitizedMetadata: {\n          aiProvider,\n          aiModel,\n          processingContext,\n          aiTimestamp: aiTimestamp instanceof Date ? aiTimestamp : (aiTimestamp ? new Date(aiTimestamp) : undefined)\n        },\n        errors: [],\n        warnings: [],\n        securityThreats: []\n      };\n    }\n\n    const result: AIMetadataValidationResult = {\n      isValid: true,\n      sanitizedMetadata: {},\n      errors: [],\n      warnings: [],\n      securityThreats: []\n    };\n\n    // Rate limiting check\n    if (enableRateLimiting && aiProvider) {\n      const rateLimitResult = this.checkRateLimit(aiProvider);\n      if (!rateLimitResult.allowed) {\n        result.isValid = false;\n        result.errors.push(`Rate limit exceeded for provider ${aiProvider}. Try again in ${Math.ceil(rateLimitResult.resetIn / 1000)} seconds.`);\n        return result;\n      }\n    }\n\n    // Validate AI Provider\n    if (aiProvider !== undefined) {\n      const providerResult = this.validateAIProvider(aiProvider, strictMode, editorialEngineMode);\n      if (!providerResult.isValid) {\n        result.isValid = false;\n        result.errors.push(...providerResult.errors);\n      }\n      result.warnings.push(...providerResult.warnings);\n      result.securityThreats.push(...providerResult.securityThreats);\n      result.sanitizedMetadata!.aiProvider = providerResult.sanitizedValue;\n    }\n\n    // Validate AI Model with provider-specific validation\n    if (aiModel !== undefined) {\n      const modelResult = this.validateAIModel(aiModel, aiProvider, strictMode, editorialEngineMode);\n      if (!modelResult.isValid) {\n        result.isValid = false;\n        result.errors.push(...modelResult.errors);\n      }\n      result.warnings.push(...modelResult.warnings);\n      result.securityThreats.push(...modelResult.securityThreats);\n      result.sanitizedMetadata!.aiModel = modelResult.sanitizedValue;\n    }\n\n    // Enhanced Processing Context validation\n    if (processingContext !== undefined) {\n      const contextResult = this.validateProcessingContext(\n        processingContext, \n        maxProcessingContextSize, \n        strictMode, \n        editorialEngineMode\n      );\n      if (!contextResult.isValid) {\n        result.isValid = false;\n        result.errors.push(...contextResult.errors);\n      }\n      result.warnings.push(...contextResult.warnings);\n      result.securityThreats.push(...contextResult.securityThreats);\n      result.sanitizedMetadata!.processingContext = contextResult.sanitizedValue;\n    }\n\n    // Validate AI Timestamp\n    if (aiTimestamp !== undefined) {\n      const timestampResult = this.validateAITimestamp(aiTimestamp);\n      if (!timestampResult.isValid) {\n        result.isValid = false;\n        result.errors.push(...timestampResult.errors);\n      }\n      result.warnings.push(...timestampResult.warnings);\n      result.sanitizedMetadata!.aiTimestamp = timestampResult.sanitizedValue;\n    }\n\n    // Editorial Engine cross-validation\n    if (editorialEngineMode) {\n      const engineResult = this.validateEditorialEngineIntegration(\n        result.sanitizedMetadata!.aiProvider,\n        result.sanitizedMetadata!.aiModel,\n        result.sanitizedMetadata!.processingContext\n      );\n      if (!engineResult.isValid) {\n        result.isValid = false;\n        result.errors.push(...engineResult.errors);\n      }\n      result.warnings.push(...engineResult.warnings);\n    }\n\n    // Log security violations if requested\n    if (logSecurityViolations && result.securityThreats.length > 0) {\n      console.warn('AI metadata security threats detected:', {\n        threats: result.securityThreats,\n        provider: aiProvider,\n        model: aiModel,\n        timestamp: new Date().toISOString()\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Enhanced AI provider validation with Editorial Engine support\n   */\n  static validateAIProvider(provider: string, strictMode: boolean = true, editorialEngineMode: boolean = false): ValidationResult {\n    const result: ValidationResult = {\n      isValid: true,\n      errors: [],\n      warnings: [],\n      securityThreats: []\n    };\n\n    // Type check\n    if (typeof provider !== 'string') {\n      result.isValid = false;\n      result.errors.push('AI provider must be a string');\n      result.sanitizedValue = '';\n      return result;\n    }\n\n    // Enhanced security threat detection\n    const threats = SanitizationUtils.detectSecurityThreats(provider);\n    const advancedThreats = this.detectAdvancedSecurityThreats(provider);\n    const allThreats = [...threats, ...advancedThreats];\n    \n    if (allThreats.length > 0) {\n      result.securityThreats.push(...allThreats);\n      if (strictMode) {\n        result.isValid = false;\n        result.errors.push('Security threats detected in AI provider name');\n      } else {\n        result.warnings.push('Security threats sanitized in AI provider name');\n      }\n    }\n\n    // Sanitize provider name\n    const sanitized = SanitizationUtils.sanitizeAIProvider(provider);\n    result.sanitizedValue = sanitized;\n\n    // Check if empty after sanitization\n    if (sanitized.length === 0) {\n      result.isValid = false;\n      result.errors.push('AI provider name is empty after sanitization');\n      return result;\n    }\n\n    // Length validation with more restrictive limits\n    if (sanitized.length > 50) {\n      result.isValid = false;\n      result.errors.push('AI provider name too long (max 50 characters)');\n      return result;\n    }\n\n    // Validate against known providers (case-insensitive)\n    const lowerProvider = sanitized.toLowerCase();\n    if (!this.KNOWN_PROVIDERS.includes(lowerProvider)) {\n      if (strictMode) {\n        result.isValid = false;\n        result.errors.push(`Unknown AI provider: ${sanitized}. Must be one of: ${this.KNOWN_PROVIDERS.join(', ')}`);\n      } else {\n        result.warnings.push(`Unknown AI provider: ${sanitized}. Consider adding to whitelist.`);\n      }\n    }\n\n    // Editorial Engine specific validation\n    if (editorialEngineMode) {\n      const engineValidation = this.validateEditorialEngineProvider(sanitized);\n      if (!engineValidation.isValid) {\n        result.isValid = false;\n        result.errors.push(...engineValidation.errors);\n      }\n      result.warnings.push(...engineValidation.warnings);\n    }\n\n    return result;\n  }\n\n  /**\n   * Enhanced AI model validation with provider-specific rules\n   */\n  static validateAIModel(model: string, provider?: string, strictMode: boolean = true, editorialEngineMode: boolean = false): ValidationResult {\n    const result: ValidationResult = {\n      isValid: true,\n      errors: [],\n      warnings: [],\n      securityThreats: []\n    };\n\n    // Type check\n    if (typeof model !== 'string') {\n      result.isValid = false;\n      result.errors.push('AI model must be a string');\n      result.sanitizedValue = '';\n      return result;\n    }\n\n    // Enhanced security threat detection\n    const threats = SanitizationUtils.detectSecurityThreats(model);\n    const advancedThreats = this.detectAdvancedSecurityThreats(model);\n    const allThreats = [...threats, ...advancedThreats];\n    \n    if (allThreats.length > 0) {\n      result.securityThreats.push(...allThreats);\n      if (strictMode) {\n        result.isValid = false;\n        result.errors.push('Security threats detected in AI model name');\n      } else {\n        result.warnings.push('Security threats sanitized in AI model name');\n      }\n    }\n\n    // Sanitize model name\n    const sanitized = SanitizationUtils.sanitizeAIModel(model);\n    result.sanitizedValue = sanitized;\n\n    // Check if empty after sanitization\n    if (sanitized.length === 0) {\n      result.isValid = false;\n      result.errors.push('AI model name is empty after sanitization');\n      return result;\n    }\n\n    // Length validation\n    if (sanitized.length > 100) {\n      result.isValid = false;\n      result.errors.push('AI model name too long (max 100 characters)');\n      return result;\n    }\n\n    // Provider-specific model validation\n    if (provider && strictMode) {\n      const providerValidation = this.validateModelForProvider(sanitized, provider);\n      if (!providerValidation.isValid) {\n        result.warnings.push(...providerValidation.errors); // Warnings instead of errors for flexibility\n      }\n    }\n\n    // Editorial Engine model validation\n    if (editorialEngineMode) {\n      const engineValidation = this.validateEditorialEngineModel(sanitized, provider);\n      if (!engineValidation.isValid) {\n        result.warnings.push(...engineValidation.errors);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Enhanced processing context validation with Editorial Engine constraints\n   */\n  static validateProcessingContext(\n    context: AIProcessingContext, \n    maxSize: number = 50000,\n    strictMode: boolean = true,\n    editorialEngineMode: boolean = false\n  ): ValidationResult {\n    const result: ValidationResult = {\n      isValid: true,\n      errors: [],\n      warnings: [],\n      securityThreats: []\n    };\n\n    // Type check\n    if (typeof context !== 'object' || context === null) {\n      result.isValid = false;\n      result.errors.push('Processing context must be an object');\n      result.sanitizedValue = {};\n      return result;\n    }\n\n    // Check serialized size before processing\n    const currentSize = SanitizationUtils.calculateSerializedSize(context);\n    if (currentSize > maxSize) {\n      result.isValid = false;\n      result.errors.push(`Processing context too large: ${currentSize} bytes (max ${maxSize})`);\n      result.sanitizedValue = {};\n      return result;\n    }\n\n    // Enhanced object sanitization with deeper protection\n    const sanitizedContext = SanitizationUtils.sanitizeObject(context, 10); // Increased depth\n    \n    // Validate and sanitize individual fields\n    const validatedContext: AIProcessingContext = {};\n\n    // Enhanced constraints validation\n    if (sanitizedContext.constraints !== undefined) {\n      const constraintsResult = this.validateConstraints(sanitizedContext.constraints, editorialEngineMode, strictMode);\n      if (!constraintsResult.isValid) {\n        result.isValid = false;\n        result.errors.push(...constraintsResult.errors);\n      }\n      result.warnings.push(...constraintsResult.warnings);\n      result.securityThreats.push(...constraintsResult.securityThreats);\n      validatedContext.constraints = constraintsResult.sanitizedValue as string[];\n    }\n\n    // Enhanced prompt validation\n    if (sanitizedContext.prompt !== undefined) {\n      const promptResult = this.validatePrompt(sanitizedContext.prompt, strictMode);\n      if (!promptResult.isValid) {\n        result.isValid = false;\n        result.errors.push(...promptResult.errors);\n      }\n      result.warnings.push(...promptResult.warnings);\n      result.securityThreats.push(...promptResult.securityThreats);\n      validatedContext.prompt = promptResult.sanitizedValue as string;\n    }\n\n    // Enhanced mode validation\n    if (sanitizedContext.mode !== undefined) {\n      const modeResult = this.validateProcessingMode(sanitizedContext.mode, editorialEngineMode, strictMode);\n      if (!modeResult.isValid) {\n        result.isValid = false;\n        result.errors.push(...modeResult.errors);\n      }\n      result.warnings.push(...modeResult.warnings);\n      validatedContext.mode = modeResult.sanitizedValue as string;\n    }\n\n    // Enhanced instructions validation\n    if (sanitizedContext.instructions !== undefined) {\n      const instructionsResult = this.validateInstructions(sanitizedContext.instructions, strictMode);\n      if (!instructionsResult.isValid) {\n        result.isValid = false;\n        result.errors.push(...instructionsResult.errors);\n      }\n      result.warnings.push(...instructionsResult.warnings);\n      result.securityThreats.push(...instructionsResult.securityThreats);\n      validatedContext.instructions = instructionsResult.sanitizedValue as string;\n    }\n\n    // Validate conversation context for Editorial Engine\n    if (sanitizedContext.conversationId !== undefined) {\n      const conversationResult = this.validateConversationContext(sanitizedContext.conversationId, strictMode);\n      if (!conversationResult.isValid) {\n        result.isValid = false;\n        result.errors.push(...conversationResult.errors);\n      }\n      result.warnings.push(...conversationResult.warnings);\n      validatedContext.conversationId = conversationResult.sanitizedValue as string;\n    }\n\n    // Validate metadata and settings\n    if (sanitizedContext.metadata !== undefined) {\n      const metadataResult = this.validateMetadata(sanitizedContext.metadata, strictMode);\n      if (!metadataResult.isValid) {\n        result.warnings.push(...metadataResult.errors); // Non-critical\n      }\n      validatedContext.metadata = metadataResult.sanitizedValue as Record<string, any>;\n    }\n\n    if (sanitizedContext.settings !== undefined) {\n      const settingsResult = this.validateSettings(sanitizedContext.settings, strictMode);\n      if (!settingsResult.isValid) {\n        result.warnings.push(...settingsResult.errors); // Non-critical\n      }\n      validatedContext.settings = settingsResult.sanitizedValue as Record<string, any>;\n    }\n\n    // Final size check after sanitization\n    const finalSize = SanitizationUtils.calculateSerializedSize(validatedContext);\n    if (finalSize > maxSize) {\n      result.isValid = false;\n      result.errors.push(`Processing context still too large after sanitization: ${finalSize} bytes (max ${maxSize})`);\n      result.sanitizedValue = {};\n      return result;\n    }\n\n    result.sanitizedValue = validatedContext;\n    return result;\n  }\n\n  /**\n   * Validates constraints with Editorial Engine support\n   */\n  private static validateConstraints(constraints: any, editorialEngineMode: boolean, strictMode: boolean): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n\n    if (!Array.isArray(constraints)) {\n      result.isValid = false;\n      result.errors.push('Constraints must be an array');\n      result.sanitizedValue = [];\n      return result;\n    }\n\n    const sanitizedConstraints: string[] = [];\n    \n    for (let i = 0; i < Math.min(constraints.length, 50); i++) {\n      const constraint = constraints[i];\n      \n      if (typeof constraint !== 'string') {\n        result.warnings.push(`Constraint ${i} is not a string, skipping`);\n        continue;\n      }\n\n      // Security threat detection\n      const threats = this.detectAdvancedSecurityThreats(constraint);\n      if (threats.length > 0) {\n        result.securityThreats.push(...threats);\n        if (strictMode) {\n          result.warnings.push(`Security threats in constraint ${i}, sanitizing`);\n        }\n      }\n\n      // Sanitize constraint\n      const sanitized = SanitizationUtils.sanitizeString(constraint, {\n        maxLength: 1000,\n        preserveNewlines: false,\n        strictMode: strictMode\n      });\n\n      if (sanitized.length === 0) {\n        result.warnings.push(`Constraint ${i} is empty after sanitization, skipping`);\n        continue;\n      }\n\n      // Editorial Engine constraint type validation\n      if (editorialEngineMode) {\n        const constraintValidation = this.validateConstraintFormat(sanitized);\n        if (!constraintValidation.isValid) {\n          result.warnings.push(...constraintValidation.errors);\n        }\n      }\n\n      sanitizedConstraints.push(sanitized);\n    }\n\n    if (constraints.length > 50) {\n      result.warnings.push(`Too many constraints (${constraints.length}), truncated to 50`);\n    }\n\n    result.sanitizedValue = sanitizedConstraints;\n    return result;\n  }\n\n  /**\n   * Validates Editorial Engine constraint format\n   */\n  private static validateConstraintFormat(constraint: string): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n\n    // Check for structured constraint format: type:value or key=value\n    const structuredPatterns = [\n      /^[\\w-]+:[\\s\\S]+$/,  // type:value format\n      /^[\\w-]+=[\\s\\S]+$/,  // key=value format\n      /^[\\w-]+\\s+[\\s\\S]+$/ // key value format\n    ];\n\n    const hasStructure = structuredPatterns.some(pattern => pattern.test(constraint));\n    \n    if (!hasStructure && constraint.length > 20) {\n      result.warnings.push('Constraint may benefit from structured format (e.g., \"tone:professional\" or \"length=500\")');\n    }\n\n    // Validate constraint type if structured\n    const typeMatch = constraint.match(/^([\\w-]+)[:=]/);\n    if (typeMatch) {\n      const type = typeMatch[1].toLowerCase();\n      if (!this.CONSTRAINT_TYPES.includes(type)) {\n        result.warnings.push(`Unknown constraint type: ${type}. Consider using: ${this.CONSTRAINT_TYPES.join(', ')}`);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Editorial Engine integration validation\n   */\n  private static validateEditorialEngineIntegration(\n    provider?: string, \n    model?: string, \n    context?: AIProcessingContext\n  ): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n\n    // Validate provider compatibility with Editorial Engine\n    if (provider && !['editorial-engine', 'writerr', 'openai', 'anthropic', 'custom'].includes(provider.toLowerCase())) {\n      result.warnings.push(`Provider ${provider} may have limited Editorial Engine integration support`);\n    }\n\n    // Validate processing context for Editorial Engine requirements\n    if (context) {\n      if (!context.mode && !context.constraints) {\n        result.warnings.push('Editorial Engine works best with either processing mode or constraints specified');\n      }\n\n      if (context.constraints && context.constraints.length === 0) {\n        result.warnings.push('Empty constraints array provided to Editorial Engine');\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Rate limiting implementation\n   */\n  private static checkRateLimit(provider: string): { allowed: boolean; resetIn: number } {\n    const now = Date.now();\n    const key = provider.toLowerCase();\n    \n    let entry = this.rateLimitStore.get(key);\n    if (!entry || (now - entry.lastReset) >= this.RATE_LIMIT_WINDOW) {\n      entry = { count: 0, lastReset: now };\n      this.rateLimitStore.set(key, entry);\n    }\n\n    entry.count++;\n    \n    if (entry.count > this.RATE_LIMIT_MAX_REQUESTS) {\n      const resetIn = this.RATE_LIMIT_WINDOW - (now - entry.lastReset);\n      return { allowed: false, resetIn };\n    }\n\n    return { allowed: true, resetIn: 0 };\n  }\n\n  /**\n   * Advanced security threat detection\n   */\n  private static detectAdvancedSecurityThreats(input: string): string[] {\n    const threats: string[] = [];\n\n    // SQL injection patterns\n    if (/(\\bUNION\\b|\\bSELECT\\b|\\bINSERT\\b|\\bUPDATE\\b|\\bDELETE\\b|\\bDROP\\b)/i.test(input)) {\n      threats.push('Potential SQL injection');\n    }\n\n    // Command injection patterns\n    if (/[;&|`$(){}[\\]\\\\]/.test(input)) {\n      threats.push('Command injection characters');\n    }\n\n    // Path traversal\n    if (/\\.\\.(\\/|\\\\)/.test(input)) {\n      threats.push('Path traversal attempt');\n    }\n\n    // Template injection\n    if (/\\{\\{.*\\}\\}|\\${.*}|<%.*%>/.test(input)) {\n      threats.push('Template injection pattern');\n    }\n\n    // Prototype pollution\n    if (/__proto__|constructor\\.prototype|\\.constructor/.test(input)) {\n      threats.push('Prototype pollution attempt');\n    }\n\n    return threats;\n  }\n\n  // Additional helper methods for enhanced validation\n  private static validateEditorialEngineProvider(provider: string): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n    \n    if (provider === 'editorial-engine' || provider === 'writerr') {\n      // These are always valid for Editorial Engine mode\n      return result;\n    }\n\n    const compatibleProviders = ['openai', 'anthropic', 'custom', 'local'];\n    if (!compatibleProviders.includes(provider.toLowerCase())) {\n      result.warnings.push(`Provider ${provider} may have limited Editorial Engine compatibility`);\n    }\n\n    return result;\n  }\n\n  private static validateEditorialEngineModel(model: string, provider?: string): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n    \n    if (provider === 'editorial-engine' || provider === 'writerr') {\n      // Editorial Engine internal models - validate format\n      if (!/^[a-z0-9\\-_]+(\\.[a-z0-9\\-_]+)*$/i.test(model)) {\n        result.errors.push('Editorial Engine model names must use alphanumeric characters, hyphens, underscores, and dots only');\n      }\n    }\n\n    return result;\n  }\n\n  private static validateModelForProvider(model: string, provider: string): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n    \n    const lowerProvider = provider.toLowerCase();\n    const pattern = this.MODEL_PATTERNS[lowerProvider as keyof typeof this.MODEL_PATTERNS];\n    \n    if (pattern && !pattern.test(model)) {\n      result.errors.push(`Model ${model} does not match expected format for provider ${provider}`);\n    }\n\n    return result;\n  }\n\n  private static validatePrompt(prompt: any, strictMode: boolean): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n\n    if (typeof prompt !== 'string') {\n      result.isValid = false;\n      result.errors.push('Prompt must be a string');\n      result.sanitizedValue = '';\n      return result;\n    }\n\n    const threats = this.detectAdvancedSecurityThreats(prompt);\n    if (threats.length > 0) {\n      result.securityThreats.push(...threats);\n    }\n\n    result.sanitizedValue = SanitizationUtils.sanitizeString(prompt, {\n      maxLength: 20000,\n      preserveNewlines: true,\n      strictMode: strictMode\n    });\n\n    return result;\n  }\n\n  private static validateInstructions(instructions: any, strictMode: boolean): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n\n    if (typeof instructions !== 'string') {\n      result.isValid = false;\n      result.errors.push('Instructions must be a string');\n      result.sanitizedValue = '';\n      return result;\n    }\n\n    const threats = this.detectAdvancedSecurityThreats(instructions);\n    if (threats.length > 0) {\n      result.securityThreats.push(...threats);\n    }\n\n    result.sanitizedValue = SanitizationUtils.sanitizeString(instructions, {\n      maxLength: 10000,\n      preserveNewlines: true,\n      strictMode: strictMode\n    });\n\n    return result;\n  }\n\n  private static validateProcessingMode(mode: any, editorialEngineMode: boolean, strictMode: boolean): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n\n    if (typeof mode !== 'string') {\n      result.isValid = false;\n      result.errors.push('Processing mode must be a string');\n      result.sanitizedValue = '';\n      return result;\n    }\n\n    const sanitizedMode = SanitizationUtils.sanitizeMode(mode);\n    result.sanitizedValue = sanitizedMode;\n\n    const lowerMode = sanitizedMode.toLowerCase();\n    if (!this.KNOWN_MODES.includes(lowerMode)) {\n      if (strictMode) {\n        result.warnings.push(`Unknown processing mode: ${sanitizedMode}. Available modes: ${this.KNOWN_MODES.join(', ')}`);\n      }\n    }\n\n    // Editorial Engine mode validation\n    if (editorialEngineMode) {\n      const engineModes = ['constraint-based', 'rule-based', 'template-driven', 'conversation-context'];\n      if (engineModes.includes(lowerMode)) {\n        // These modes require specific context validation\n        result.warnings.push(`Mode ${sanitizedMode} requires Editorial Engine context validation`);\n      }\n    }\n\n    return result;\n  }\n\n  private static validateConversationContext(conversationId: any, strictMode: boolean): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n\n    if (typeof conversationId !== 'string') {\n      result.isValid = false;\n      result.errors.push('Conversation ID must be a string');\n      result.sanitizedValue = '';\n      return result;\n    }\n\n    // Validate conversation ID format\n    if (!/^[a-zA-Z0-9\\-_]{8,64}$/.test(conversationId)) {\n      result.isValid = false;\n      result.errors.push('Conversation ID must be 8-64 alphanumeric characters, hyphens, or underscores');\n      result.sanitizedValue = '';\n      return result;\n    }\n\n    result.sanitizedValue = conversationId;\n    return result;\n  }\n\n  private static validateMetadata(metadata: any, strictMode: boolean): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n\n    if (typeof metadata !== 'object' || metadata === null) {\n      result.warnings.push('Metadata must be an object');\n      result.sanitizedValue = {};\n      return result;\n    }\n\n    const sanitized = SanitizationUtils.sanitizeObject(metadata, 3);\n    result.sanitizedValue = sanitized;\n    return result;\n  }\n\n  private static validateSettings(settings: any, strictMode: boolean): ValidationResult {\n    const result: ValidationResult = { isValid: true, errors: [], warnings: [], securityThreats: [] };\n\n    if (typeof settings !== 'object' || settings === null) {\n      result.warnings.push('Settings must be an object');\n      result.sanitizedValue = {};\n      return result;\n    }\n\n    const sanitized = SanitizationUtils.sanitizeObject(settings, 3);\n    result.sanitizedValue = sanitized;\n    return result;\n  }\n\n  /**\n   * Validates AI timestamp\n   */\n  static validateAITimestamp(timestamp: Date | string): ValidationResult {\n    const result: ValidationResult = {\n      isValid: true,\n      errors: [],\n      warnings: [],\n      securityThreats: []\n    };\n\n    const validatedDate = SanitizationUtils.validateTimestamp(timestamp);\n    \n    if (validatedDate === null) {\n      result.isValid = false;\n      result.errors.push('Invalid AI timestamp: must be a valid date within reasonable range');\n      result.sanitizedValue = null;\n      return result;\n    }\n\n    result.sanitizedValue = validatedDate;\n    return result;\n  }\n\n  /**\n   * Quick validation method that returns boolean and sanitized data\n   */\n  static quickValidate(\n    aiProvider?: string,\n    aiModel?: string,\n    processingContext?: AIProcessingContext,\n    aiTimestamp?: Date | string,\n    options: ValidationOptions = {}\n  ): { isValid: boolean; sanitized: any } {\n    const result = this.validateAIMetadata(aiProvider, aiModel, processingContext, aiTimestamp, options);\n    \n    return {\n      isValid: result.isValid,\n      sanitized: result.sanitizedMetadata\n    };\n  }\n\n  /**\n   * Provides validation configuration for different environments\n   */\n  static getValidationConfig(environment: 'development' | 'production' | 'testing'): ValidationOptions {\n    switch (environment) {\n      case 'development':\n        return {\n          strictMode: false,\n          maxProcessingContextSize: 100000,\n          logSecurityViolations: true,\n          enableRateLimiting: false,\n          editorialEngineMode: false\n        };\n      \n      case 'production':\n        return {\n          strictMode: true,\n          maxProcessingContextSize: 50000,\n          logSecurityViolations: true,\n          enableRateLimiting: true,\n          editorialEngineMode: true\n        };\n      \n      case 'testing':\n        return {\n          strictMode: true,\n          maxProcessingContextSize: 10000,\n          logSecurityViolations: false,\n          enableRateLimiting: false,\n          editorialEngineMode: true\n        };\n      \n      default:\n        return {\n          strictMode: true,\n          maxProcessingContextSize: 50000,\n          logSecurityViolations: true,\n          enableRateLimiting: true,\n          editorialEngineMode: false\n        };\n    }\n  }\n\n  /**\n   * Editorial Engine specific validation method\n   */\n  static validateForEditorialEngine(\n    aiProvider: string,\n    aiModel: string,\n    processingContext: AIProcessingContext,\n    options: ValidationOptions = {}\n  ): AIMetadataValidationResult {\n    return this.validateAIMetadata(\n      aiProvider,\n      aiModel,\n      processingContext,\n      new Date(),\n      {\n        ...options,\n        editorialEngineMode: true,\n        strictMode: true\n      }\n    );\n  }\n\n  /**\n   * Reset rate limiting for a provider (for testing or admin use)\n   */\n  static resetRateLimit(provider?: string): void {\n    if (provider) {\n      this.rateLimitStore.delete(provider.toLowerCase());\n    } else {\n      this.rateLimitStore.clear();\n    }\n  }\n}", "import { EditChange } from '@shared/types';\nimport { \n  QueryCriteria, \n  QueryOptions, \n  QueryResult, \n  QueryStats,\n  AggregationOptions,\n  TimelineOptions,\n  TimelinePoint,\n  ExportFormat,\n  QueryBuilder\n} from './query-types';\nimport { EditChangeQuerySystem } from './edit-change-query-system';\n\n/**\n * Fluent query builder implementation for EditChange queries\n * Task 1.6: Create utility methods for querying changes by AI provider or processing context\n */\nexport class QueryBuilderImpl implements QueryBuilder {\n  private criteria: QueryCriteria = {};\n  private options: QueryOptions = {};\n  private querySystem: EditChangeQuerySystem;\n\n  constructor(querySystem: EditChangeQuerySystem) {\n    this.querySystem = querySystem;\n  }\n\n  // Basic filters\n  byProvider(provider: string): QueryBuilder {\n    return this.clone({ aiProvider: provider });\n  }\n\n  byModel(model: string): QueryBuilder {\n    return this.clone({ aiModel: model });\n  }\n\n  byAuthor(author: string): QueryBuilder {\n    return this.clone({ author });\n  }\n\n  byType(type: 'insert' | 'delete' | 'replace'): QueryBuilder {\n    return this.clone({ changeType: type });\n  }\n\n  // Time filters\n  inTimeRange(start: Date, end: Date): QueryBuilder {\n    return this.clone({ timeRange: { start, end } });\n  }\n\n  since(date: Date): QueryBuilder {\n    return this.clone({ timeRange: { start: date, end: new Date() } });\n  }\n\n  before(date: Date): QueryBuilder {\n    const oldestDate = new Date(0); // Unix epoch start\n    return this.clone({ timeRange: { start: oldestDate, end: date } });\n  }\n\n  inLast(amount: number, unit: 'hours' | 'days' | 'weeks' | 'months'): QueryBuilder {\n    const now = new Date();\n    const start = new Date(now);\n\n    switch (unit) {\n      case 'hours':\n        start.setHours(start.getHours() - amount);\n        break;\n      case 'days':\n        start.setDate(start.getDate() - amount);\n        break;\n      case 'weeks':\n        start.setDate(start.getDate() - (amount * 7));\n        break;\n      case 'months':\n        start.setMonth(start.getMonth() - amount);\n        break;\n    }\n\n    return this.clone({ timeRange: { start, end: now } });\n  }\n\n  // AI metadata filters\n  withAIMetadata(): QueryBuilder {\n    return this.clone({ hasAIMetadata: true });\n  }\n\n  withoutAIMetadata(): QueryBuilder {\n    return this.clone({ hasAIMetadata: false });\n  }\n\n  withProcessingContext(): QueryBuilder {\n    return this.clone({ hasProcessingContext: true });\n  }\n\n  withoutProcessingContext(): QueryBuilder {\n    return this.clone({ hasProcessingContext: false });\n  }\n\n  // Context filters\n  inMode(mode: string): QueryBuilder {\n    return this.clone({ contextMode: mode });\n  }\n\n  withConstraints(constraints: string[]): QueryBuilder {\n    return this.clone({ contextConstraints: constraints });\n  }\n\n  hasConstraint(constraint: string): QueryBuilder {\n    const existing = this.criteria.contextConstraints || [];\n    const updated = [...existing, constraint];\n    return this.clone({ contextConstraints: updated });\n  }\n\n  withInstructions(instructions: string): QueryBuilder {\n    return this.clone({ contextInstructions: instructions });\n  }\n\n  // Text search\n  textContains(query: string, options: { caseSensitive?: boolean; fuzzyMatch?: boolean } = {}): QueryBuilder {\n    return this.clone({\n      textSearch: {\n        query,\n        caseSensitive: options.caseSensitive,\n        fuzzyMatch: options.fuzzyMatch,\n        searchIn: ['text', 'removedText']\n      }\n    });\n  }\n\n  textMatches(pattern: RegExp): QueryBuilder {\n    return this.clone({\n      textSearch: {\n        query: pattern.source,\n        caseSensitive: !pattern.ignoreCase,\n        fuzzyMatch: false,\n        searchIn: ['text', 'removedText']\n      }\n    });\n  }\n\n  contextContains(query: string): QueryBuilder {\n    return this.clone({\n      textSearch: {\n        query,\n        searchIn: ['processingContext']\n      }\n    });\n  }\n\n  // Position filters\n  inRange(from: number, to: number): QueryBuilder {\n    return this.clone({ positionRange: { from, to } });\n  }\n\n  atPosition(position: number): QueryBuilder {\n    return this.clone({ positionRange: { from: position, to: position + 1 } });\n  }\n\n  // Quality filters\n  withValidationWarnings(): QueryBuilder {\n    return this.clone({ hasValidationWarnings: true });\n  }\n\n  withSecurityThreats(): QueryBuilder {\n    return this.clone({ hasSecurityThreats: true });\n  }\n\n  // Sorting and pagination\n  sortBy(field: string, order: 'asc' | 'desc' = 'asc'): QueryBuilder {\n    const newBuilder = this.cloneBuilder();\n    newBuilder.options.sortBy = field as any;\n    newBuilder.options.sortOrder = order;\n    return newBuilder;\n  }\n\n  limit(count: number): QueryBuilder {\n    const newBuilder = this.cloneBuilder();\n    newBuilder.options.limit = count;\n    return newBuilder;\n  }\n\n  offset(start: number): QueryBuilder {\n    const newBuilder = this.cloneBuilder();\n    newBuilder.options.offset = start;\n    return newBuilder;\n  }\n\n  page(pageNum: number, pageSize: number): QueryBuilder {\n    const newBuilder = this.cloneBuilder();\n    newBuilder.options.limit = pageSize;\n    newBuilder.options.offset = (pageNum - 1) * pageSize;\n    return newBuilder;\n  }\n\n  // Execution methods\n  async exec(): Promise<QueryResult> {\n    return this.querySystem.executeQuery(this.criteria, this.options);\n  }\n\n  async count(): Promise<number> {\n    const result = await this.querySystem.executeQuery(this.criteria, {\n      ...this.options,\n      limit: 0 // Don't return actual items, just count\n    });\n    return result.totalCount;\n  }\n\n  async first(): Promise<EditChange | null> {\n    const result = await this.querySystem.executeQuery(this.criteria, {\n      ...this.options,\n      limit: 1\n    });\n    return result.items[0] || null;\n  }\n\n  async toArray(): Promise<EditChange[]> {\n    const result = await this.querySystem.executeQuery(this.criteria, this.options);\n    return result.items;\n  }\n\n  // Statistical methods\n  async getStats(): Promise<QueryStats> {\n    const result = await this.querySystem.executeQuery(this.criteria, {\n      ...this.options,\n      includeStats: true\n    });\n    return result.stats!;\n  }\n\n  async aggregate(options: AggregationOptions): Promise<Record<string, number>> {\n    return this.querySystem.aggregate(this.criteria, options);\n  }\n\n  async timeline(options: TimelineOptions): Promise<TimelinePoint[]> {\n    // For timeline, we need to get filtered changes first\n    const result = await this.querySystem.executeQuery(this.criteria, this.options);\n    \n    // Then generate timeline from those changes\n    // This is a simplified implementation - could be optimized\n    const changes = result.items.filter(c => c.aiTimestamp || c.timestamp);\n    return this.generateTimelineFromChanges(changes, options);\n  }\n\n  // Export methods\n  async export(format: ExportFormat): Promise<string> {\n    switch (format.format) {\n      case 'json':\n        return this.toJSON();\n      case 'csv':\n        return this.toCSV();\n      case 'markdown':\n        return this.toMarkdown();\n      default:\n        throw new Error(`Unsupported export format: ${format.format}`);\n    }\n  }\n\n  async toJSON(): Promise<string> {\n    return this.querySystem.exportToJSON(this.criteria, this.options);\n  }\n\n  async toCSV(): Promise<string> {\n    return this.querySystem.exportToCSV(this.criteria);\n  }\n\n  async toMarkdown(): Promise<string> {\n    return this.querySystem.exportToMarkdown(this.criteria);\n  }\n\n  // Utility methods\n  clone(additionalCriteria: Partial<QueryCriteria> = {}): QueryBuilder {\n    const newBuilder = this.cloneBuilder();\n    newBuilder.criteria = { ...this.criteria, ...additionalCriteria };\n    return newBuilder;\n  }\n\n  reset(): QueryBuilder {\n    const newBuilder = new QueryBuilderImpl(this.querySystem);\n    return newBuilder;\n  }\n\n  getCriteria(): QueryCriteria {\n    return { ...this.criteria };\n  }\n\n  getOptions(): QueryOptions {\n    return { ...this.options };\n  }\n\n  // Advanced query methods for complex scenarios\n  \n  /**\n   * Combines multiple criteria with OR logic (instead of default AND)\n   */\n  or(...builders: QueryBuilder[]): QueryBuilder {\n    // This is a complex feature that would require significant changes to the query execution\n    // For now, we'll throw an error to indicate it's not implemented\n    throw new Error('OR queries not yet implemented - use separate queries and merge results');\n  }\n\n  /**\n   * Creates a complex query with nested conditions\n   */\n  complex(builderFn: (builder: QueryBuilder) => QueryBuilder): QueryBuilder {\n    return builderFn(this.clone());\n  }\n\n  /**\n   * Adds custom filter function\n   */\n  where(predicate: (change: EditChange) => boolean): QueryBuilder {\n    // This would require extending the QueryCriteria interface to support custom predicates\n    // For now, we'll store it as a custom property and handle it in execution\n    const newBuilder = this.cloneBuilder();\n    (newBuilder as any).customPredicate = predicate;\n    return newBuilder;\n  }\n\n  /**\n   * Groups results by a specific field\n   */\n  groupBy(field: keyof EditChange | string): GroupedQueryBuilder {\n    return new GroupedQueryBuilder(this.querySystem, this.criteria, this.options, field);\n  }\n\n  /**\n   * Creates a sub-query for more complex filtering\n   */\n  subQuery(builderFn: (builder: QueryBuilder) => QueryBuilder): QueryBuilder {\n    const subBuilder = builderFn(new QueryBuilderImpl(this.querySystem));\n    // In a full implementation, this would create a nested query structure\n    // For now, we'll merge the criteria\n    return this.clone(subBuilder.getCriteria());\n  }\n\n  // Performance optimization methods\n\n  /**\n   * Enables caching for this query\n   */\n  cached(ttl?: number): QueryBuilder {\n    const newBuilder = this.cloneBuilder();\n    newBuilder.options.useCache = true;\n    if (ttl) {\n      // Store TTL for custom cache implementation\n      (newBuilder.options as any).cacheTTL = ttl;\n    }\n    return newBuilder;\n  }\n\n  /**\n   * Enables lazy evaluation for better performance with large datasets\n   */\n  lazy(): QueryBuilder {\n    const newBuilder = this.cloneBuilder();\n    newBuilder.options.lazyEvaluation = true;\n    return newBuilder;\n  }\n\n  // Private helper methods\n  private cloneBuilder(): QueryBuilderImpl {\n    const newBuilder = new QueryBuilderImpl(this.querySystem);\n    newBuilder.criteria = { ...this.criteria };\n    newBuilder.options = { ...this.options };\n    return newBuilder;\n  }\n\n  private generateTimelineFromChanges(changes: EditChange[], options: TimelineOptions): TimelinePoint[] {\n    // Group changes by time intervals\n    const grouped = new Map<string, EditChange[]>();\n    \n    for (const change of changes) {\n      const timestamp = change.aiTimestamp ? change.aiTimestamp : new Date(change.timestamp);\n      const bucketKey = this.getTimeBucket(timestamp, options.interval);\n      \n      if (!grouped.has(bucketKey)) {\n        grouped.set(bucketKey, []);\n      }\n      grouped.get(bucketKey)!.push(change);\n    }\n\n    // Convert to timeline points\n    const timeline: TimelinePoint[] = [];\n    \n    for (const [bucketKey, bucketChanges] of grouped.entries()) {\n      const timestamp = new Date(bucketKey);\n      \n      const point: TimelinePoint = {\n        timestamp,\n        count: bucketChanges.length\n      };\n\n      if (options.includeMetadata) {\n        point.metadata = {\n          providers: [...new Set(bucketChanges.map(c => c.aiProvider).filter(Boolean))],\n          models: [...new Set(bucketChanges.map(c => c.aiModel).filter(Boolean))],\n          modes: [...new Set(bucketChanges.map(c => c.processingContext?.mode).filter(Boolean))],\n          avgWordsChanged: bucketChanges.reduce((sum, c) => \n            sum + (c.text?.split(/\\s+/).length || 0), 0) / bucketChanges.length\n        };\n      }\n\n      timeline.push(point);\n    }\n\n    // Sort by timestamp\n    timeline.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n\n    // Fill gaps if requested\n    if (options.fillGaps && timeline.length > 1) {\n      return this.fillTimelineGaps(timeline, options.interval);\n    }\n\n    return timeline;\n  }\n\n  private getTimeBucket(date: Date, interval: 'hour' | 'day' | 'week' | 'month'): string {\n    const d = new Date(date);\n    \n    switch (interval) {\n      case 'hour':\n        d.setMinutes(0, 0, 0);\n        break;\n      case 'day':\n        d.setHours(0, 0, 0, 0);\n        break;\n      case 'week':\n        const dayOfWeek = d.getDay();\n        d.setDate(d.getDate() - dayOfWeek);\n        d.setHours(0, 0, 0, 0);\n        break;\n      case 'month':\n        d.setDate(1);\n        d.setHours(0, 0, 0, 0);\n        break;\n    }\n    \n    return d.toISOString();\n  }\n\n  private fillTimelineGaps(timeline: TimelinePoint[], interval: 'hour' | 'day' | 'week' | 'month'): TimelinePoint[] {\n    if (timeline.length < 2) return timeline;\n\n    const filled: TimelinePoint[] = [];\n    const first = timeline[0];\n    const last = timeline[timeline.length - 1];\n\n    let current = new Date(first.timestamp);\n    const end = new Date(last.timestamp);\n\n    const timelineMap = new Map(timeline.map(p => [p.timestamp.toISOString(), p]));\n\n    while (current <= end) {\n      const key = current.toISOString();\n      const existing = timelineMap.get(key);\n      \n      if (existing) {\n        filled.push(existing);\n      } else {\n        filled.push({\n          timestamp: new Date(current),\n          count: 0\n        });\n      }\n\n      // Advance to next interval\n      switch (interval) {\n        case 'hour':\n          current.setHours(current.getHours() + 1);\n          break;\n        case 'day':\n          current.setDate(current.getDate() + 1);\n          break;\n        case 'week':\n          current.setDate(current.getDate() + 7);\n          break;\n        case 'month':\n          current.setMonth(current.getMonth() + 1);\n          break;\n      }\n    }\n\n    return filled;\n  }\n}\n\n/**\n * Extended query builder for grouped results\n */\nclass GroupedQueryBuilder {\n  constructor(\n    private querySystem: EditChangeQuerySystem,\n    private criteria: QueryCriteria,\n    private options: QueryOptions,\n    private groupField: string\n  ) {}\n\n  async exec(): Promise<Map<string, EditChange[]>> {\n    const result = await this.querySystem.executeQuery(this.criteria, this.options);\n    const grouped = new Map<string, EditChange[]>();\n\n    for (const change of result.items) {\n      let groupKey: string;\n\n      // Get the grouping key based on the field\n      switch (this.groupField) {\n        case 'aiProvider':\n          groupKey = change.aiProvider || 'unknown';\n          break;\n        case 'aiModel':\n          groupKey = change.aiModel || 'unknown';\n          break;\n        case 'type':\n          groupKey = change.type;\n          break;\n        case 'author':\n          groupKey = change.author || 'unknown';\n          break;\n        default:\n          groupKey = 'default';\n      }\n\n      if (!grouped.has(groupKey)) {\n        grouped.set(groupKey, []);\n      }\n      grouped.get(groupKey)!.push(change);\n    }\n\n    return grouped;\n  }\n\n  async count(): Promise<Map<string, number>> {\n    const grouped = await this.exec();\n    const counts = new Map<string, number>();\n\n    for (const [key, changes] of grouped.entries()) {\n      counts.set(key, changes.length);\n    }\n\n    return counts;\n  }\n\n  async toObject(): Promise<Record<string, EditChange[]>> {\n    const grouped = await this.exec();\n    const result: Record<string, EditChange[]> = {};\n\n    for (const [key, changes] of grouped.entries()) {\n      result[key] = changes;\n    }\n\n    return result;\n  }\n}", "import { EditChange, AIProcessingContext } from '@shared/types';\nimport { \n  QueryResult, \n  ExportFormat,\n  AggregationOptions,\n  TimelineOptions,\n  TimelinePoint\n} from './query-types';\n\n/**\n * Utility functions for query operations and data processing\n * Task 1.6: Create utility methods for querying changes by AI provider or processing context\n */\nexport class QueryUtils {\n  \n  /**\n   * Text matching utilities with fuzzy matching support\n   */\n  static textMatches(text: string, query: string, options: {\n    caseSensitive?: boolean;\n    fuzzyMatch?: boolean;\n  } = {}): boolean {\n    const { caseSensitive = false, fuzzyMatch = false } = options;\n    \n    let searchText = text;\n    let searchQuery = query;\n    \n    if (!caseSensitive) {\n      searchText = text.toLowerCase();\n      searchQuery = query.toLowerCase();\n    }\n\n    if (fuzzyMatch) {\n      return this.fuzzyMatch(searchText, searchQuery);\n    } else {\n      return searchText.includes(searchQuery);\n    }\n  }\n\n  /**\n   * Simple fuzzy matching implementation using edit distance\n   */\n  static fuzzyMatch(text: string, pattern: string, threshold: number = 0.8): boolean {\n    // For very short patterns, use exact matching\n    if (pattern.length < 3) {\n      return text.includes(pattern);\n    }\n\n    // Split text into words and check if any word is similar to pattern\n    const words = text.split(/\\s+/);\n    \n    for (const word of words) {\n      if (this.calculateSimilarity(word, pattern) >= threshold) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Calculate similarity between two strings (0-1, where 1 is identical)\n   */\n  static calculateSimilarity(str1: string, str2: string): number {\n    if (str1.length === 0 && str2.length === 0) return 1;\n    if (str1.length === 0 || str2.length === 0) return 0;\n\n    const maxLength = Math.max(str1.length, str2.length);\n    const distance = this.levenshteinDistance(str1, str2);\n    \n    return (maxLength - distance) / maxLength;\n  }\n\n  /**\n   * Calculate Levenshtein distance between two strings\n   */\n  static levenshteinDistance(str1: string, str2: string): number {\n    const matrix = Array(str2.length + 1).fill(null).map(() => \n      Array(str1.length + 1).fill(null)\n    );\n\n    for (let i = 0; i <= str1.length; i++) {\n      matrix[0][i] = i;\n    }\n\n    for (let j = 0; j <= str2.length; j++) {\n      matrix[j][0] = j;\n    }\n\n    for (let j = 1; j <= str2.length; j++) {\n      for (let i = 1; i <= str1.length; i++) {\n        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\n        matrix[j][i] = Math.min(\n          matrix[j][i - 1] + 1,     // deletion\n          matrix[j - 1][i] + 1,     // insertion\n          matrix[j - 1][i - 1] + indicator // substitution\n        );\n      }\n    }\n\n    return matrix[str2.length][str1.length];\n  }\n\n  /**\n   * Date range utilities\n   */\n  static isDateInRange(date: Date, start: Date, end: Date, timezone?: string): boolean {\n    // Handle timezone conversion if specified\n    if (timezone) {\n      // This is a simplified implementation - in production, use a proper timezone library\n      console.warn('Timezone handling not fully implemented, using local timezone');\n    }\n\n    const timestamp = date.getTime();\n    return timestamp >= start.getTime() && timestamp <= end.getTime();\n  }\n\n  /**\n   * Processing context search utilities\n   */\n  static searchInProcessingContext(\n    context: AIProcessingContext, \n    query: string,\n    options: { caseSensitive?: boolean; fuzzyMatch?: boolean } = {}\n  ): boolean {\n    const searchableText = [\n      context.prompt || '',\n      context.mode || '',\n      context.instructions || '',\n      context.documentContext || '',\n      ...(context.constraints || [])\n    ].join(' ');\n\n    return this.textMatches(searchableText, query, options);\n  }\n\n  /**\n   * Aggregate data by various dimensions\n   */\n  static aggregateData(changes: EditChange[], options: AggregationOptions): Record<string, number> {\n    const { groupBy, aggregateFunction = 'count', aggregateField, includePercentages = false } = options;\n    const result: Record<string, number> = {};\n    const groups = new Map<string, EditChange[]>();\n\n    // Group changes by the specified field\n    for (const change of changes) {\n      let groupKey = this.getGroupKey(change, groupBy);\n      \n      if (!groups.has(groupKey)) {\n        groups.set(groupKey, []);\n      }\n      groups.get(groupKey)!.push(change);\n    }\n\n    // Calculate aggregation for each group\n    for (const [groupKey, groupChanges] of groups.entries()) {\n      let value: number;\n\n      switch (aggregateFunction) {\n        case 'count':\n          value = groupChanges.length;\n          break;\n        case 'sum':\n          value = this.sumField(groupChanges, aggregateField || 'timestamp');\n          break;\n        case 'avg':\n          value = this.avgField(groupChanges, aggregateField || 'timestamp');\n          break;\n        case 'min':\n          value = this.minField(groupChanges, aggregateField || 'timestamp');\n          break;\n        case 'max':\n          value = this.maxField(groupChanges, aggregateField || 'timestamp');\n          break;\n        default:\n          value = groupChanges.length;\n      }\n\n      result[groupKey] = value;\n    }\n\n    // Add percentages if requested\n    if (includePercentages && aggregateFunction === 'count') {\n      const total = Object.values(result).reduce((sum, val) => sum + val, 0);\n      const percentages: Record<string, number> = {};\n      \n      for (const [key, value] of Object.entries(result)) {\n        percentages[`${key}_percentage`] = total > 0 ? (value / total) * 100 : 0;\n      }\n      \n      Object.assign(result, percentages);\n    }\n\n    // Sort results if requested\n    if (options.sortBy) {\n      return this.sortObject(result, options.sortBy, options.sortOrder || 'desc');\n    }\n\n    // Apply limit if specified\n    if (options.limit && options.limit > 0) {\n      return this.limitObject(result, options.limit);\n    }\n\n    return result;\n  }\n\n  /**\n   * Generate timeline data from changes\n   */\n  static generateTimeline(changes: EditChange[], options: TimelineOptions): TimelinePoint[] {\n    const { interval, fillGaps = false, includeMetadata = false } = options;\n    const buckets = new Map<string, EditChange[]>();\n\n    // Group changes by time buckets\n    for (const change of changes) {\n      const timestamp = change.aiTimestamp ? change.aiTimestamp : new Date(change.timestamp);\n      const bucketKey = this.getTimeBucket(timestamp, interval);\n      \n      if (!buckets.has(bucketKey)) {\n        buckets.set(bucketKey, []);\n      }\n      buckets.get(bucketKey)!.push(change);\n    }\n\n    // Convert to timeline points\n    const timeline: TimelinePoint[] = [];\n    \n    for (const [bucketKey, bucketChanges] of buckets.entries()) {\n      const point: TimelinePoint = {\n        timestamp: new Date(bucketKey),\n        count: bucketChanges.length\n      };\n\n      if (includeMetadata) {\n        point.metadata = this.generateTimelineMetadata(bucketChanges);\n      }\n\n      timeline.push(point);\n    }\n\n    // Sort by timestamp\n    timeline.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n\n    // Fill gaps if requested\n    if (fillGaps && timeline.length > 1) {\n      return this.fillTimelineGaps(timeline, interval);\n    }\n\n    return timeline;\n  }\n\n  /**\n   * Format data as CSV\n   */\n  static formatAsCSV(changes: EditChange[], format: ExportFormat): string {\n    const { includeHeaders = true, customFields, dateFormat = 'ISO' } = format;\n    \n    let csv = '';\n    \n    // Headers\n    if (includeHeaders) {\n      const headers = customFields || [\n        'id', 'timestamp', 'type', 'from', 'to', 'text', 'removedText', \n        'author', 'aiProvider', 'aiModel', 'aiTimestamp', 'processingContext'\n      ];\n      csv += headers.join(',') + '\\n';\n    }\n\n    // Data rows\n    for (const change of changes) {\n      const row: string[] = [];\n      \n      if (customFields) {\n        for (const field of customFields) {\n          row.push(this.formatCSVValue(this.getFieldValue(change, field), dateFormat));\n        }\n      } else {\n        row.push(\n          this.formatCSVValue(change.id),\n          this.formatCSVValue(this.formatDate(new Date(change.timestamp), dateFormat)),\n          this.formatCSVValue(change.type),\n          this.formatCSVValue(change.from),\n          this.formatCSVValue(change.to),\n          this.formatCSVValue(change.text || ''),\n          this.formatCSVValue(change.removedText || ''),\n          this.formatCSVValue(change.author || ''),\n          this.formatCSVValue(change.aiProvider || ''),\n          this.formatCSVValue(change.aiModel || ''),\n          this.formatCSVValue(change.aiTimestamp ? this.formatDate(change.aiTimestamp, dateFormat) : ''),\n          this.formatCSVValue(change.processingContext ? JSON.stringify(change.processingContext) : '')\n        );\n      }\n      \n      csv += row.join(',') + '\\n';\n    }\n\n    return csv;\n  }\n\n  /**\n   * Format data as Markdown\n   */\n  static formatAsMarkdown(result: QueryResult, format: ExportFormat): string {\n    const { includeStats = true, includeMetadata = true } = format;\n    \n    let markdown = `# Query Results\\n\\n`;\n    \n    // Query metadata\n    if (includeMetadata) {\n      markdown += `## Query Information\\n\\n`;\n      markdown += `- **Total Results**: ${result.totalCount}\\n`;\n      markdown += `- **Execution Time**: ${result.executionTime}ms\\n`;\n      \n      if (result.fromCache) {\n        markdown += `- **Source**: Cache\\n`;\n      }\n      \n      if (result.page) {\n        markdown += `- **Page**: ${result.page.current} of ${result.page.total}\\n`;\n        markdown += `- **Page Size**: ${result.page.size}\\n`;\n      }\n      \n      markdown += `\\n`;\n    }\n\n    // Statistics\n    if (includeStats && result.stats) {\n      markdown += this.formatStatsAsMarkdown(result.stats);\n    }\n\n    // Results table\n    if (result.items.length > 0) {\n      markdown += `## Results\\n\\n`;\n      markdown += `| Timestamp | Type | Provider | Model | Text Preview | Position |\\n`;\n      markdown += `|-----------|------|----------|-------|--------------|----------|\\n`;\n      \n      for (const change of result.items.slice(0, 50)) { // Limit to 50 for readability\n        const timestamp = change.aiTimestamp ? \n          change.aiTimestamp.toLocaleString() : \n          new Date(change.timestamp).toLocaleString();\n        \n        const textPreview = (change.text || change.removedText || '').substring(0, 50);\n        const position = `${change.from}-${change.to}`;\n        \n        markdown += `| ${timestamp} | ${change.type} | ${change.aiProvider || 'Manual'} | ${change.aiModel || 'N/A'} | ${textPreview}${textPreview.length > 50 ? '...' : ''} | ${position} |\\n`;\n      }\n      \n      if (result.items.length > 50) {\n        markdown += `\\n*... and ${result.items.length - 50} more results*\\n`;\n      }\n    }\n\n    return markdown;\n  }\n\n  /**\n   * Format statistics as Markdown\n   */\n  static formatStatsAsMarkdown(stats: QueryStats): string {\n    let markdown = `## Statistics\\n\\n`;\n    \n    // Provider breakdown\n    if (Object.keys(stats.byProvider).length > 0) {\n      markdown += `### AI Providers\\n\\n`;\n      for (const [provider, count] of Object.entries(stats.byProvider)) {\n        markdown += `- **${provider}**: ${count} changes\\n`;\n      }\n      markdown += `\\n`;\n    }\n\n    // Model breakdown\n    if (Object.keys(stats.byModel).length > 0) {\n      markdown += `### AI Models\\n\\n`;\n      for (const [model, count] of Object.entries(stats.byModel)) {\n        markdown += `- **${model}**: ${count} changes\\n`;\n      }\n      markdown += `\\n`;\n    }\n\n    // Change type breakdown\n    markdown += `### Change Types\\n\\n`;\n    for (const [type, count] of Object.entries(stats.byChangeType)) {\n      markdown += `- **${type}**: ${count} changes\\n`;\n    }\n    markdown += `\\n`;\n\n    // Context statistics\n    markdown += `### Processing Context\\n\\n`;\n    markdown += `- **With Context**: ${stats.withContext} changes\\n`;\n    markdown += `- **Without Context**: ${stats.withoutContext} changes\\n`;\n    \n    if (Object.keys(stats.contextModes).length > 0) {\n      markdown += `\\n**Modes Used**:\\n`;\n      for (const [mode, count] of Object.entries(stats.contextModes)) {\n        markdown += `- **${mode}**: ${count} changes\\n`;\n      }\n    }\n    markdown += `\\n`;\n\n    // Performance metrics\n    markdown += `### Content Metrics\\n\\n`;\n    markdown += `- **Total Words Changed**: ${stats.totalWordsChanged}\\n`;\n    markdown += `- **Total Characters Changed**: ${stats.totalCharsChanged}\\n`;\n    markdown += `- **Average Words per Change**: ${stats.avgWordsChanged.toFixed(1)}\\n`;\n    markdown += `- **Average Characters per Change**: ${stats.avgCharsChanged.toFixed(1)}\\n`;\n\n    // Time range\n    if (stats.timeRange) {\n      markdown += `\\n### Time Range\\n\\n`;\n      markdown += `- **Earliest**: ${stats.timeRange.earliest.toLocaleString()}\\n`;\n      markdown += `- **Latest**: ${stats.timeRange.latest.toLocaleString()}\\n`;\n      markdown += `- **Span**: ${stats.timeRange.span}\\n`;\n    }\n\n    // Quality metrics\n    if (stats.validationWarnings > 0 || stats.securityThreats > 0) {\n      markdown += `\\n### Quality Metrics\\n\\n`;\n      markdown += `- **Validation Warnings**: ${stats.validationWarnings}\\n`;\n      markdown += `- **Security Threats**: ${stats.securityThreats}\\n`;\n    }\n\n    return markdown + `\\n`;\n  }\n\n  // Private helper methods\n\n  private static getGroupKey(change: EditChange, groupBy: string): string {\n    switch (groupBy) {\n      case 'provider':\n        return change.aiProvider || 'Manual';\n      case 'model':\n        return change.aiModel || 'N/A';\n      case 'author':\n        return change.author || 'Unknown';\n      case 'mode':\n        return change.processingContext?.mode || 'No Mode';\n      case 'hour':\n        return new Date(change.timestamp).toISOString().substring(0, 13) + ':00:00.000Z';\n      case 'day':\n        return new Date(change.timestamp).toISOString().substring(0, 10) + 'T00:00:00.000Z';\n      case 'week':\n        const date = new Date(change.timestamp);\n        const startOfWeek = new Date(date);\n        startOfWeek.setDate(date.getDate() - date.getDay());\n        return startOfWeek.toISOString().substring(0, 10) + 'T00:00:00.000Z';\n      case 'month':\n        return new Date(change.timestamp).toISOString().substring(0, 7) + '-01T00:00:00.000Z';\n      default:\n        return 'Unknown';\n    }\n  }\n\n  private static sumField(changes: EditChange[], field: string): number {\n    return changes.reduce((sum, change) => sum + (this.getNumericFieldValue(change, field) || 0), 0);\n  }\n\n  private static avgField(changes: EditChange[], field: string): number {\n    if (changes.length === 0) return 0;\n    return this.sumField(changes, field) / changes.length;\n  }\n\n  private static minField(changes: EditChange[], field: string): number {\n    const values = changes.map(c => this.getNumericFieldValue(c, field)).filter(v => v !== undefined) as number[];\n    return values.length > 0 ? Math.min(...values) : 0;\n  }\n\n  private static maxField(changes: EditChange[], field: string): number {\n    const values = changes.map(c => this.getNumericFieldValue(c, field)).filter(v => v !== undefined) as number[];\n    return values.length > 0 ? Math.max(...values) : 0;\n  }\n\n  private static getNumericFieldValue(change: EditChange, field: string): number | undefined {\n    switch (field) {\n      case 'timestamp':\n        return change.timestamp;\n      case 'from':\n        return change.from;\n      case 'to':\n        return change.to;\n      case 'textLength':\n        return change.text?.length || 0;\n      case 'removedTextLength':\n        return change.removedText?.length || 0;\n      default:\n        return 0;\n    }\n  }\n\n  private static getFieldValue(change: EditChange, field: string): any {\n    const keys = field.split('.');\n    let value: any = change;\n    \n    for (const key of keys) {\n      value = value?.[key];\n      if (value === undefined) break;\n    }\n    \n    return value;\n  }\n\n  private static sortObject(obj: Record<string, number>, sortBy: 'key' | 'value', order: 'asc' | 'desc'): Record<string, number> {\n    const entries = Object.entries(obj);\n    \n    entries.sort((a, b) => {\n      const valueA = sortBy === 'key' ? a[0] : a[1];\n      const valueB = sortBy === 'key' ? b[0] : b[1];\n      \n      if (typeof valueA === 'string' && typeof valueB === 'string') {\n        return order === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);\n      } else {\n        return order === 'asc' ? (valueA as number) - (valueB as number) : (valueB as number) - (valueA as number);\n      }\n    });\n\n    return Object.fromEntries(entries);\n  }\n\n  private static limitObject(obj: Record<string, number>, limit: number): Record<string, number> {\n    const entries = Object.entries(obj).slice(0, limit);\n    return Object.fromEntries(entries);\n  }\n\n  private static getTimeBucket(date: Date, interval: 'hour' | 'day' | 'week' | 'month'): string {\n    const d = new Date(date);\n    \n    switch (interval) {\n      case 'hour':\n        d.setMinutes(0, 0, 0);\n        break;\n      case 'day':\n        d.setHours(0, 0, 0, 0);\n        break;\n      case 'week':\n        const dayOfWeek = d.getDay();\n        d.setDate(d.getDate() - dayOfWeek);\n        d.setHours(0, 0, 0, 0);\n        break;\n      case 'month':\n        d.setDate(1);\n        d.setHours(0, 0, 0, 0);\n        break;\n    }\n    \n    return d.toISOString();\n  }\n\n  private static generateTimelineMetadata(changes: EditChange[]): Record<string, any> {\n    return {\n      providers: [...new Set(changes.map(c => c.aiProvider).filter(Boolean))],\n      models: [...new Set(changes.map(c => c.aiModel).filter(Boolean))],\n      modes: [...new Set(changes.map(c => c.processingContext?.mode).filter(Boolean))],\n      types: [...new Set(changes.map(c => c.type))],\n      avgWordsChanged: changes.reduce((sum, c) => \n        sum + (c.text?.split(/\\s+/).length || 0), 0) / changes.length,\n      totalTextLength: changes.reduce((sum, c) => sum + (c.text?.length || 0), 0),\n      authors: [...new Set(changes.map(c => c.author).filter(Boolean))]\n    };\n  }\n\n  private static fillTimelineGaps(timeline: TimelinePoint[], interval: 'hour' | 'day' | 'week' | 'month'): TimelinePoint[] {\n    if (timeline.length < 2) return timeline;\n\n    const filled: TimelinePoint[] = [];\n    const first = timeline[0];\n    const last = timeline[timeline.length - 1];\n\n    let current = new Date(first.timestamp);\n    const end = new Date(last.timestamp);\n\n    const timelineMap = new Map(timeline.map(p => [p.timestamp.toISOString(), p]));\n\n    while (current <= end) {\n      const key = current.toISOString();\n      const existing = timelineMap.get(key);\n      \n      if (existing) {\n        filled.push(existing);\n      } else {\n        filled.push({\n          timestamp: new Date(current),\n          count: 0\n        });\n      }\n\n      // Advance to next interval\n      switch (interval) {\n        case 'hour':\n          current.setHours(current.getHours() + 1);\n          break;\n        case 'day':\n          current.setDate(current.getDate() + 1);\n          break;\n        case 'week':\n          current.setDate(current.getDate() + 7);\n          break;\n        case 'month':\n          current.setMonth(current.getMonth() + 1);\n          break;\n      }\n    }\n\n    return filled;\n  }\n\n  private static formatCSVValue(value: any, dateFormat?: string): string {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    let strValue = String(value);\n    \n    // Handle dates\n    if (value instanceof Date) {\n      strValue = this.formatDate(value, dateFormat || 'ISO');\n    }\n    \n    // Escape CSV special characters\n    if (strValue.includes(',') || strValue.includes('\"') || strValue.includes('\\n')) {\n      strValue = `\"${strValue.replace(/\"/g, '\"\"')}\"`;\n    }\n    \n    return strValue;\n  }\n\n  private static formatDate(date: Date, format: string): string {\n    switch (format) {\n      case 'ISO':\n        return date.toISOString();\n      case 'locale':\n        return date.toLocaleString();\n      case 'date-only':\n        return date.toISOString().split('T')[0];\n      default:\n        return date.toISOString();\n    }\n  }\n}", "import { EditChange, EditSession, AIProcessingContext } from '@shared/types';\nimport { \n  QueryCriteria, \n  QueryOptions, \n  QueryResult, \n  QueryStats,\n  ComparisonResult,\n  ExportFormat,\n  AggregationOptions,\n  TimelineOptions,\n  TimelinePoint,\n  QueryBuilder,\n  QueryCache,\n  QueryIndex\n} from './query-types';\nimport { QueryBuilderImpl } from './query-builder';\nimport { QueryUtils } from './query-utils';\n\n/**\n * Comprehensive query system for EditChange objects with AI attribution metadata\n * Task 1.6: Create utility methods for querying changes by AI provider or processing context\n */\nexport class EditChangeQuerySystem {\n  private cache: QueryCache;\n  private index: QueryIndex;\n  private sessions: Map<string, EditSession>;\n  \n  constructor(sessions?: Map<string, EditSession>, cache?: QueryCache) {\n    this.sessions = sessions || new Map();\n    this.cache = cache || new MemoryQueryCache();\n    this.index = this.buildIndex();\n  }\n\n  /**\n   * Updates the internal sessions data and rebuilds indices\n   */\n  updateSessions(sessions: Map<string, EditSession>): void {\n    this.sessions = sessions;\n    this.index = this.buildIndex();\n    this.cache.clear(); // Clear cache when data changes\n  }\n\n  /**\n   * Creates a new query builder instance\n   */\n  query(): QueryBuilder {\n    return new QueryBuilderImpl(this);\n  }\n\n  /**\n   * Executes a query with given criteria and options\n   */\n  async executeQuery(criteria: QueryCriteria, options: QueryOptions = {}): Promise<QueryResult> {\n    const startTime = Date.now();\n    \n    // Check cache first\n    const cacheKey = this.generateCacheKey(criteria, options);\n    if (options.useCache !== false) {\n      const cached = await this.cache.get<QueryResult>(cacheKey);\n      if (cached) {\n        return { ...cached, fromCache: true };\n      }\n    }\n\n    // Get all changes from sessions\n    const allChanges = this.getAllChanges();\n    \n    // Apply filters\n    let filteredChanges = await this.applyFilters(allChanges, criteria);\n    \n    // Apply sorting\n    if (options.sortBy) {\n      filteredChanges = this.applySorting(filteredChanges, options.sortBy, options.sortOrder || 'asc');\n    }\n\n    // Calculate total before pagination\n    const totalCount = filteredChanges.length;\n\n    // Apply pagination\n    if (options.offset || options.limit) {\n      const start = options.offset || 0;\n      const end = options.limit ? start + options.limit : undefined;\n      filteredChanges = filteredChanges.slice(start, end);\n    }\n\n    // Generate statistics if requested\n    let stats: QueryStats | undefined;\n    if (options.includeStats) {\n      stats = this.generateStats(filteredChanges);\n    }\n\n    const result: QueryResult = {\n      items: filteredChanges,\n      totalCount,\n      hasMore: (options.limit || 0) > 0 && totalCount > filteredChanges.length + (options.offset || 0),\n      query: criteria,\n      options,\n      executionTime: Date.now() - startTime,\n      stats\n    };\n\n    // Add pagination info if applicable\n    if (options.limit && options.offset !== undefined) {\n      result.page = {\n        current: Math.floor(options.offset / options.limit) + 1,\n        size: options.limit,\n        total: Math.ceil(totalCount / options.limit)\n      };\n    }\n\n    // Cache result if enabled\n    if (options.useCache !== false) {\n      await this.cache.set(cacheKey, result, 300000); // 5 minutes TTL\n    }\n\n    return result;\n  }\n\n  /**\n   * Quick filter methods for common use cases\n   */\n  async getChangesByProvider(provider: string, options: QueryOptions = {}): Promise<EditChange[]> {\n    const result = await this.executeQuery({ aiProvider: provider }, options);\n    return result.items;\n  }\n\n  async getChangesByModel(model: string, options: QueryOptions = {}): Promise<EditChange[]> {\n    const result = await this.executeQuery({ aiModel: model }, options);\n    return result.items;\n  }\n\n  async getChangesInTimeRange(start: Date, end: Date, options: QueryOptions = {}): Promise<EditChange[]> {\n    const result = await this.executeQuery({ timeRange: { start, end } }, options);\n    return result.items;\n  }\n\n  async getChangesByMode(mode: string, options: QueryOptions = {}): Promise<EditChange[]> {\n    const result = await this.executeQuery({ contextMode: mode }, options);\n    return result.items;\n  }\n\n  async getAIGeneratedChanges(options: QueryOptions = {}): Promise<EditChange[]> {\n    const result = await this.executeQuery({ hasAIMetadata: true }, options);\n    return result.items;\n  }\n\n  async getManualChanges(options: QueryOptions = {}): Promise<EditChange[]> {\n    const result = await this.executeQuery({ hasAIMetadata: false }, options);\n    return result.items;\n  }\n\n  /**\n   * Advanced search methods\n   */\n  async textSearch(query: string, options: {\n    caseSensitive?: boolean;\n    fuzzyMatch?: boolean;\n    searchIn?: ('text' | 'removedText' | 'processingContext')[];\n  } = {}, queryOptions: QueryOptions = {}): Promise<EditChange[]> {\n    const criteria: QueryCriteria = {\n      textSearch: {\n        query,\n        caseSensitive: options.caseSensitive,\n        fuzzyMatch: options.fuzzyMatch,\n        searchIn: options.searchIn || ['text', 'removedText', 'processingContext']\n      }\n    };\n    \n    const result = await this.executeQuery(criteria, queryOptions);\n    return result.items;\n  }\n\n  async contextSearch(query: string, options: QueryOptions = {}): Promise<EditChange[]> {\n    const criteria: QueryCriteria = {\n      textSearch: {\n        query,\n        searchIn: ['processingContext']\n      }\n    };\n    \n    const result = await this.executeQuery(criteria, options);\n    return result.items;\n  }\n\n  /**\n   * Statistical analysis methods\n   */\n  async getProviderUsageStats(): Promise<Record<string, number>> {\n    const allChanges = this.getAllChanges().filter(c => c.aiProvider);\n    const stats: Record<string, number> = {};\n    \n    for (const change of allChanges) {\n      if (change.aiProvider) {\n        stats[change.aiProvider] = (stats[change.aiProvider] || 0) + 1;\n      }\n    }\n    \n    return stats;\n  }\n\n  async getModelUsageStats(): Promise<Record<string, number>> {\n    const allChanges = this.getAllChanges().filter(c => c.aiModel);\n    const stats: Record<string, number> = {};\n    \n    for (const change of allChanges) {\n      if (change.aiModel) {\n        stats[change.aiModel] = (stats[change.aiModel] || 0) + 1;\n      }\n    }\n    \n    return stats;\n  }\n\n  async getModeUsageStats(): Promise<Record<string, number>> {\n    const allChanges = this.getAllChanges().filter(c => c.processingContext?.mode);\n    const stats: Record<string, number> = {};\n    \n    for (const change of allChanges) {\n      const mode = change.processingContext?.mode;\n      if (mode) {\n        stats[mode] = (stats[mode] || 0) + 1;\n      }\n    }\n    \n    return stats;\n  }\n\n  async getTimelineData(options: TimelineOptions): Promise<TimelinePoint[]> {\n    const allChanges = this.getAllChanges()\n      .filter(c => c.aiTimestamp || c.timestamp)\n      .sort((a, b) => {\n        const timeA = a.aiTimestamp ? a.aiTimestamp.getTime() : a.timestamp;\n        const timeB = b.aiTimestamp ? b.aiTimestamp.getTime() : b.timestamp;\n        return timeA - timeB;\n      });\n\n    return QueryUtils.generateTimeline(allChanges, options);\n  }\n\n  /**\n   * Comparison methods for AI performance analysis\n   */\n  async compareProviders(providers: string[], criteria?: Partial<QueryCriteria>): Promise<ComparisonResult> {\n    const results: QueryResult[] = [];\n    \n    for (const provider of providers) {\n      const providerCriteria: QueryCriteria = {\n        ...criteria,\n        aiProvider: provider\n      };\n      \n      const result = await this.executeQuery(providerCriteria, { includeStats: true });\n      results.push(result);\n    }\n\n    return this.generateComparison(\n      results.map(r => r.query),\n      providers,\n      'provider',\n      results\n    );\n  }\n\n  async compareModels(models: string[], criteria?: Partial<QueryCriteria>): Promise<ComparisonResult> {\n    const results: QueryResult[] = [];\n    \n    for (const model of models) {\n      const modelCriteria: QueryCriteria = {\n        ...criteria,\n        aiModel: model\n      };\n      \n      const result = await this.executeQuery(modelCriteria, { includeStats: true });\n      results.push(result);\n    }\n\n    return this.generateComparison(\n      results.map(r => r.query),\n      models,\n      'model',\n      results\n    );\n  }\n\n  async compareModes(modes: string[], criteria?: Partial<QueryCriteria>): Promise<ComparisonResult> {\n    const results: QueryResult[] = [];\n    \n    for (const mode of modes) {\n      const modeCriteria: QueryCriteria = {\n        ...criteria,\n        contextMode: mode\n      };\n      \n      const result = await this.executeQuery(modeCriteria, { includeStats: true });\n      results.push(result);\n    }\n\n    return this.generateComparison(\n      results.map(r => r.query),\n      modes,\n      'mode',\n      results\n    );\n  }\n\n  /**\n   * Export methods for various formats\n   */\n  async exportToJSON(criteria: QueryCriteria, options: QueryOptions = {}): Promise<string> {\n    const result = await this.executeQuery(criteria, options);\n    return JSON.stringify(result, null, 2);\n  }\n\n  async exportToCSV(criteria: QueryCriteria, format: ExportFormat = { format: 'csv' }): Promise<string> {\n    const result = await this.executeQuery(criteria);\n    return QueryUtils.formatAsCSV(result.items, format);\n  }\n\n  async exportToMarkdown(criteria: QueryCriteria, format: ExportFormat = { format: 'markdown' }): Promise<string> {\n    const result = await this.executeQuery(criteria, { includeStats: true });\n    return QueryUtils.formatAsMarkdown(result, format);\n  }\n\n  /**\n   * Aggregate data by various dimensions\n   */\n  async aggregate(criteria: QueryCriteria, options: AggregationOptions): Promise<Record<string, number>> {\n    const result = await this.executeQuery(criteria);\n    return QueryUtils.aggregateData(result.items, options);\n  }\n\n  // Private helper methods\n  private getAllChanges(): EditChange[] {\n    const allChanges: EditChange[] = [];\n    \n    for (const session of this.sessions.values()) {\n      allChanges.push(...session.changes);\n    }\n    \n    return allChanges;\n  }\n\n  private async applyFilters(changes: EditChange[], criteria: QueryCriteria): Promise<EditChange[]> {\n    let filtered = changes;\n\n    // Apply each filter\n    if (criteria.aiProvider) {\n      filtered = filtered.filter(c => c.aiProvider === criteria.aiProvider);\n    }\n\n    if (criteria.aiModel) {\n      filtered = filtered.filter(c => c.aiModel === criteria.aiModel);\n    }\n\n    if (criteria.author) {\n      filtered = filtered.filter(c => c.author === criteria.author);\n    }\n\n    if (criteria.changeType) {\n      filtered = filtered.filter(c => c.type === criteria.changeType);\n    }\n\n    if (criteria.hasAIMetadata !== undefined) {\n      filtered = filtered.filter(c => {\n        const hasAI = !!(c.aiProvider || c.aiModel || c.processingContext || c.aiTimestamp);\n        return hasAI === criteria.hasAIMetadata;\n      });\n    }\n\n    if (criteria.hasProcessingContext !== undefined) {\n      filtered = filtered.filter(c => !!c.processingContext === criteria.hasProcessingContext);\n    }\n\n    if (criteria.contextMode) {\n      filtered = filtered.filter(c => c.processingContext?.mode === criteria.contextMode);\n    }\n\n    if (criteria.contextConstraints) {\n      filtered = filtered.filter(c => {\n        const constraints = c.processingContext?.constraints || [];\n        return criteria.contextConstraints!.every(constraint => \n          constraints.includes(constraint)\n        );\n      });\n    }\n\n    if (criteria.timeRange) {\n      const { start, end } = criteria.timeRange;\n      filtered = filtered.filter(c => {\n        const timestamp = c.aiTimestamp ? c.aiTimestamp.getTime() : c.timestamp;\n        return timestamp >= start.getTime() && timestamp <= end.getTime();\n      });\n    }\n\n    if (criteria.positionRange) {\n      const { from, to } = criteria.positionRange;\n      filtered = filtered.filter(c => {\n        if (from !== undefined && c.from < from) return false;\n        if (to !== undefined && c.to > to) return false;\n        return true;\n      });\n    }\n\n    if (criteria.textSearch) {\n      filtered = await this.applyTextSearch(filtered, criteria.textSearch);\n    }\n\n    return filtered;\n  }\n\n  private async applyTextSearch(changes: EditChange[], search: NonNullable<QueryCriteria['textSearch']>): Promise<EditChange[]> {\n    const { query, caseSensitive, fuzzyMatch, searchIn } = search;\n    const searchFields = searchIn || ['text', 'removedText', 'processingContext'];\n    \n    return changes.filter(change => {\n      for (const field of searchFields) {\n        let searchText = '';\n        \n        switch (field) {\n          case 'text':\n            searchText = change.text || '';\n            break;\n          case 'removedText':\n            searchText = change.removedText || '';\n            break;\n          case 'processingContext':\n            if (change.processingContext) {\n              searchText = JSON.stringify(change.processingContext);\n            }\n            break;\n        }\n\n        if (QueryUtils.textMatches(searchText, query, { caseSensitive, fuzzyMatch })) {\n          return true;\n        }\n      }\n      \n      return false;\n    });\n  }\n\n  private applySorting(changes: EditChange[], sortBy: string, order: 'asc' | 'desc'): EditChange[] {\n    return changes.sort((a, b) => {\n      let valueA: any, valueB: any;\n\n      switch (sortBy) {\n        case 'timestamp':\n          valueA = a.timestamp;\n          valueB = b.timestamp;\n          break;\n        case 'aiTimestamp':\n          valueA = a.aiTimestamp?.getTime() || 0;\n          valueB = b.aiTimestamp?.getTime() || 0;\n          break;\n        case 'from':\n          valueA = a.from;\n          valueB = b.from;\n          break;\n        case 'to':\n          valueA = a.to;\n          valueB = b.to;\n          break;\n        case 'aiProvider':\n          valueA = a.aiProvider || '';\n          valueB = b.aiProvider || '';\n          break;\n        case 'aiModel':\n          valueA = a.aiModel || '';\n          valueB = b.aiModel || '';\n          break;\n        default:\n          return 0;\n      }\n\n      if (valueA < valueB) return order === 'asc' ? -1 : 1;\n      if (valueA > valueB) return order === 'asc' ? 1 : -1;\n      return 0;\n    });\n  }\n\n  private generateStats(changes: EditChange[]): QueryStats {\n    const stats: QueryStats = {\n      byProvider: {},\n      byModel: {},\n      byChangeType: {},\n      withContext: 0,\n      withoutContext: 0,\n      contextModes: {},\n      validationWarnings: 0,\n      securityThreats: 0,\n      avgWordsChanged: 0,\n      avgCharsChanged: 0,\n      totalWordsChanged: 0,\n      totalCharsChanged: 0\n    };\n\n    let totalWords = 0;\n    let totalChars = 0;\n    let earliestTime: Date | undefined;\n    let latestTime: Date | undefined;\n\n    for (const change of changes) {\n      // Provider stats\n      if (change.aiProvider) {\n        stats.byProvider[change.aiProvider] = (stats.byProvider[change.aiProvider] || 0) + 1;\n      }\n\n      // Model stats\n      if (change.aiModel) {\n        stats.byModel[change.aiModel] = (stats.byModel[change.aiModel] || 0) + 1;\n      }\n\n      // Change type stats\n      stats.byChangeType[change.type] = (stats.byChangeType[change.type] || 0) + 1;\n\n      // Context stats\n      if (change.processingContext) {\n        stats.withContext++;\n        if (change.processingContext.mode) {\n          stats.contextModes[change.processingContext.mode] = \n            (stats.contextModes[change.processingContext.mode] || 0) + 1;\n        }\n      } else {\n        stats.withoutContext++;\n      }\n\n      // Time range\n      const timestamp = change.aiTimestamp ? change.aiTimestamp : new Date(change.timestamp);\n      if (!earliestTime || timestamp < earliestTime) {\n        earliestTime = timestamp;\n      }\n      if (!latestTime || timestamp > latestTime) {\n        latestTime = timestamp;\n      }\n\n      // Text statistics\n      const text = change.text || '';\n      const words = text.trim().split(/\\s+/).filter(w => w.length > 0).length;\n      const chars = text.length;\n      \n      totalWords += words;\n      totalChars += chars;\n    }\n\n    // Calculate averages\n    if (changes.length > 0) {\n      stats.avgWordsChanged = totalWords / changes.length;\n      stats.avgCharsChanged = totalChars / changes.length;\n    }\n    \n    stats.totalWordsChanged = totalWords;\n    stats.totalCharsChanged = totalChars;\n\n    // Time range\n    if (earliestTime && latestTime) {\n      const span = latestTime.getTime() - earliestTime.getTime();\n      const hours = Math.floor(span / (1000 * 60 * 60));\n      const days = Math.floor(hours / 24);\n      \n      stats.timeRange = {\n        earliest: earliestTime,\n        latest: latestTime,\n        span: days > 0 ? `${days} days, ${hours % 24} hours` : `${hours} hours`\n      };\n    }\n\n    return stats;\n  }\n\n  private generateComparison(\n    criteria: QueryCriteria[], \n    labels: string[], \n    comparedOn: string,\n    results: QueryResult[]\n  ): ComparisonResult {\n    const comparison: ComparisonResult['comparison'] = {\n      totalChanges: [],\n      avgChangesPerSession: [],\n      avgWordsPerChange: [],\n      avgCharsPerChange: [],\n      avgTimeBetweenChanges: [],\n      avgProcessingTime: [],\n      validationWarningRates: [],\n      securityThreatRates: []\n    };\n\n    for (const result of results) {\n      comparison.totalChanges.push(result.totalCount);\n      \n      if (result.stats) {\n        comparison.avgWordsPerChange.push(result.stats.avgWordsChanged);\n        comparison.avgCharsPerChange.push(result.stats.avgCharsChanged);\n        comparison.validationWarningRates.push(result.stats.validationWarnings / result.totalCount);\n        comparison.securityThreatRates.push(result.stats.securityThreats / result.totalCount);\n      } else {\n        comparison.avgWordsPerChange.push(0);\n        comparison.avgCharsPerChange.push(0);\n        comparison.validationWarningRates.push(0);\n        comparison.securityThreatRates.push(0);\n      }\n\n      // Calculate other metrics (simplified for now)\n      comparison.avgChangesPerSession.push(result.totalCount / Math.max(this.sessions.size, 1));\n      comparison.avgTimeBetweenChanges.push(0); // TODO: implement\n      comparison.avgProcessingTime.push(0); // TODO: implement\n    }\n\n    return {\n      criteria,\n      labels,\n      comparedOn,\n      results,\n      comparison\n    };\n  }\n\n  private buildIndex(): QueryIndex {\n    const index: QueryIndex = {\n      providers: new Map(),\n      models: new Map(),\n      timeRanges: new Map(),\n      modes: new Map(),\n      authors: new Map()\n    };\n\n    for (const session of this.sessions.values()) {\n      for (const change of session.changes) {\n        // Index by provider\n        if (change.aiProvider) {\n          if (!index.providers.has(change.aiProvider)) {\n            index.providers.set(change.aiProvider, new Set());\n          }\n          index.providers.get(change.aiProvider)!.add(change.id);\n        }\n\n        // Index by model\n        if (change.aiModel) {\n          if (!index.models.has(change.aiModel)) {\n            index.models.set(change.aiModel, new Set());\n          }\n          index.models.get(change.aiModel)!.add(change.id);\n        }\n\n        // Index by mode\n        if (change.processingContext?.mode) {\n          if (!index.modes.has(change.processingContext.mode)) {\n            index.modes.set(change.processingContext.mode, new Set());\n          }\n          index.modes.get(change.processingContext.mode)!.add(change.id);\n        }\n\n        // Index by author\n        if (change.author) {\n          if (!index.authors.has(change.author)) {\n            index.authors.set(change.author, new Set());\n          }\n          index.authors.get(change.author)!.add(change.id);\n        }\n\n        // Index by time bucket (for faster time-based queries)\n        const timestamp = change.aiTimestamp ? change.aiTimestamp : new Date(change.timestamp);\n        const timeBucket = Math.floor(timestamp.getTime() / (1000 * 60 * 60 * 24)); // Daily buckets\n        const timeKey = timeBucket.toString();\n        \n        if (!index.timeRanges.has(timeKey)) {\n          index.timeRanges.set(timeKey, new Set());\n        }\n        index.timeRanges.get(timeKey)!.add(change.id);\n      }\n    }\n\n    return index;\n  }\n\n  private generateCacheKey(criteria: QueryCriteria, options: QueryOptions): string {\n    return `query:${JSON.stringify(criteria)}:${JSON.stringify(options)}`;\n  }\n}\n\n/**\n * Simple in-memory cache implementation\n */\nclass MemoryQueryCache implements QueryCache {\n  private store = new Map<string, { value: any; expiry: number }>();\n\n  async get<T>(key: string): Promise<T | null> {\n    const item = this.store.get(key);\n    if (!item) return null;\n    \n    if (Date.now() > item.expiry) {\n      this.store.delete(key);\n      return null;\n    }\n    \n    return item.value;\n  }\n\n  async set<T>(key: string, value: T, ttl: number = 300000): Promise<void> {\n    this.store.set(key, {\n      value,\n      expiry: Date.now() + ttl\n    });\n  }\n\n  async clear(): Promise<void> {\n    this.store.clear();\n  }\n\n  async size(): Promise<number> {\n    return this.store.size;\n  }\n}", "import { TFile } from 'obsidian';\nimport { EditSession, EditChange, AIProcessingContext } from '@shared/types';\nimport { generateId, getWordCount, getCharacterCount } from '@shared/utils';\nimport TrackEditsPlugin from './main';\n\nimport { AIMetadataValidator } from './validation/ai-metadata-validator';\nimport { SanitizationUtils } from './validation/sanitization-utils';\n\n// Task 1.6: Query system integration\nimport { EditChangeQuerySystem } from './queries/edit-change-query-system';\nimport { QueryBuilder } from './queries/query-types';\n\nexport class EditTracker {\n  private plugin: TrackEditsPlugin;\n  private sessions: Map<string, EditSession> = new Map();\n  private activeSessions: Map<string, TFile> = new Map();\n  \n  // Task 1.6: Query system instance\n  private querySystem: EditChangeQuerySystem;\n\n  constructor(plugin: TrackEditsPlugin) {\n    this.plugin = plugin;\n    this.querySystem = new EditChangeQuerySystem(this.sessions);\n    this.loadSessions();\n  }\n\n  async loadSessions() {\n    try {\n      const data = await this.plugin.loadData();\n      if (data && data.sessions) {\n        // Task 1.7: Enhanced persistence with schema versioning and data validation\n        const enhancedData = await this.processStoredDataWithVersioning(data);\n        \n        // Load sessions with enhanced persistence handling\n        for (const session of enhancedData.sessions) {\n          // Ensure all changes have proper Date objects for aiTimestamp\n          session.changes = session.changes.map(change => this.deserializeChange(change));\n          this.sessions.set(session.id, session);\n        }\n        \n        // Update query system with loaded data\n        this.querySystem.updateSessions(this.sessions);\n        \n        console.log(`Successfully loaded ${enhancedData.sessions.length} sessions with enhanced persistence`);\n      }\n    } catch (error) {\n      console.error('Failed to load edit sessions:', error);\n      // Enhanced error recovery with backup attempt\n      await this.recoverFromCorruptedData(error);\n    }\n  }\n\n  async saveSessions() {\n    try {\n      const sessionsArray = Array.from(this.sessions.values());\n      // Task 1.7: Enhanced persistence with proper serialization and schema versioning\n      const enhancedData = await this.prepareDataForStorage(sessionsArray);\n      await this.plugin.saveData(enhancedData);\n    } catch (error) {\n      console.error('Failed to save edit sessions:', error);\n      // Attempt recovery save with minimal data\n      await this.emergencySave(error);\n    }\n  }\n\n  startSession(session: EditSession, file: TFile) {\n    this.sessions.set(session.id, session);\n    this.activeSessions.set(session.id, file);\n    this.updateQuerySystemData();\n  }\n\n  endSession(sessionId: string) {\n    const session = this.sessions.get(sessionId);\n    if (session) {\n      session.endTime = Date.now();\n      this.activeSessions.delete(sessionId);\n      this.saveSessions();\n      this.updateQuerySystemData();\n    }\n  }\n\n  /**\n   * Records changes with optional AI metadata support and comprehensive validation\n   * Maintains backward compatibility with existing change recording\n   */\n  recordChanges(sessionId: string, changes: EditChange[], aiMetadata?: {\n    aiProvider?: string;\n    aiModel?: string;\n    processingContext?: AIProcessingContext;\n    aiTimestamp?: Date;\n  }, options?: { bypassValidation?: boolean }) {\n    const session = this.sessions.get(sessionId);\n    if (!session) return;\n\n    // If AI metadata is provided, enhance changes with validated metadata\n    const enhancedChanges = aiMetadata ? \n      changes.map(change => this.enhanceChangeWithAIMetadata(change, aiMetadata, options)) : \n      changes;\n\n    // Filter out changes that failed validation (null values)\n    const validChanges = enhancedChanges.filter(change => change !== null) as EditChange[];\n\n    session.changes.push(...validChanges);\n    \n    // Update word and character counts\n    const file = this.activeSessions.get(sessionId);\n    if (file) {\n      this.updateSessionCounts(session, file);\n    }\n    \n    // Update query system when new changes are recorded\n    this.updateQuerySystemData();\n  }\n\n  /**\n   * Records AI-generated changes with required AI metadata and comprehensive validation\n   * Specialized method for Editorial Engine integration\n   */\n  recordAIChanges(\n    sessionId: string, \n    changes: EditChange[], \n    aiProvider: string,\n    aiModel: string,\n    processingContext?: AIProcessingContext,\n    aiTimestamp?: Date,\n    options?: { \n      bypassValidation?: boolean; \n      strictMode?: boolean;\n      editorialEngineMode?: boolean;\n    }\n  ): { success: boolean; errors: string[]; warnings: string[] } {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      return {\n        success: false,\n        errors: ['Session not found'],\n        warnings: []\n      };\n    }\n\n    // Enhanced validation of AI metadata with Editorial Engine support\n    const validationResult = AIMetadataValidator.validateAIMetadata(\n      aiProvider,\n      aiModel,\n      processingContext,\n      aiTimestamp,\n      {\n        strictMode: options?.strictMode ?? true,\n        bypassValidation: options?.bypassValidation ?? false,\n        editorialEngineMode: options?.editorialEngineMode ?? false,\n        enableRateLimiting: true,\n        logSecurityViolations: true\n      }\n    );\n\n    if (!validationResult.isValid && !(options?.bypassValidation)) {\n      console.error('AI metadata validation failed:', validationResult.errors);\n      return {\n        success: false,\n        errors: validationResult.errors,\n        warnings: validationResult.warnings\n      };\n    }\n\n    // Use validated/sanitized metadata\n    const sanitizedMetadata = validationResult.sanitizedMetadata!;\n    const aiMetadata = {\n      aiProvider: sanitizedMetadata.aiProvider,\n      aiModel: sanitizedMetadata.aiModel,\n      processingContext: sanitizedMetadata.processingContext,\n      aiTimestamp: sanitizedMetadata.aiTimestamp || new Date()\n    };\n\n    // Record changes with validated metadata\n    this.recordChanges(sessionId, changes, aiMetadata, { bypassValidation: true });\n\n    // Add Editorial Engine specific logging\n    if (options?.editorialEngineMode) {\n      console.info('[EditTracker] Editorial Engine changes recorded:', {\n        sessionId,\n        changesCount: changes.length,\n        provider: aiMetadata.aiProvider,\n        model: aiMetadata.aiModel,\n        hasConstraints: !!(aiMetadata.processingContext as any)?.constraints?.length,\n        timestamp: new Date().toISOString()\n      });\n    }\n\n    return {\n      success: true,\n      errors: [],\n      warnings: validationResult.warnings\n    };\n  }\n\n  /**\n   * Records a single AI-generated change with validation\n   * Convenience method for single change recording\n   */\n  recordSingleAIChange(\n    sessionId: string,\n    change: EditChange,\n    aiProvider: string,\n    aiModel: string,\n    processingContext?: AIProcessingContext,\n    aiTimestamp?: Date,\n    options?: { bypassValidation?: boolean; strictMode?: boolean }\n  ): { success: boolean; errors: string[]; warnings: string[] } {\n    return this.recordAIChanges(sessionId, [change], aiProvider, aiModel, processingContext, aiTimestamp, options);\n  }\n\n  /**\n   * Enhanced method to add change with AI metadata and comprehensive validation\n   * Returns null if validation fails in strict mode\n   */\n  private enhanceChangeWithAIMetadata(\n    change: EditChange, \n    aiMetadata: {\n      aiProvider?: string;\n      aiModel?: string;\n      processingContext?: AIProcessingContext;\n      aiTimestamp?: Date;\n    },\n    options?: { bypassValidation?: boolean }\n  ): EditChange | null {\n    // Skip validation if bypassed (for trusted internal calls)\n    if (options?.bypassValidation) {\n      return {\n        ...change,\n        aiProvider: aiMetadata.aiProvider,\n        aiModel: aiMetadata.aiModel,\n        processingContext: aiMetadata.processingContext,\n        aiTimestamp: aiMetadata.aiTimestamp\n      };\n    }\n\n    // Validate AI metadata\n    const validationResult = AIMetadataValidator.validateAIMetadata(\n      aiMetadata.aiProvider,\n      aiMetadata.aiModel,\n      aiMetadata.processingContext,\n      aiMetadata.aiTimestamp,\n      {\n        strictMode: true,\n        logSecurityViolations: true\n      }\n    );\n\n    if (!validationResult.isValid) {\n      console.warn('AI metadata validation failed for change:', validationResult.errors);\n      // In strict mode, we could return null to reject the change\n      // For backward compatibility, we'll continue with sanitized data\n    }\n\n    const sanitizedMetadata = validationResult.sanitizedMetadata || {};\n\n    return {\n      ...change,\n      aiProvider: sanitizedMetadata.aiProvider,\n      aiModel: sanitizedMetadata.aiModel,\n      processingContext: sanitizedMetadata.processingContext,\n      aiTimestamp: sanitizedMetadata.aiTimestamp\n    };\n  }\n\n  /**\n   * Legacy validation method - now uses comprehensive validator\n   * @deprecated Use AIMetadataValidator.validateAIMetadata directly\n   */\n  private validateAIMetadata(aiProvider?: string, aiModel?: string): boolean {\n    const { isValid } = AIMetadataValidator.quickValidate(aiProvider, aiModel);\n    return isValid;\n  }\n\n  /**\n   * Validates and sanitizes AI metadata before storage\n   * Public method for external validation needs\n   */\n  public validateAndSanitizeAIMetadata(\n    aiProvider?: string,\n    aiModel?: string,\n    processingContext?: AIProcessingContext,\n    aiTimestamp?: Date | string,\n    options?: {\n      strictMode?: boolean;\n      bypassValidation?: boolean;\n    }\n  ) {\n    return AIMetadataValidator.validateAIMetadata(\n      aiProvider,\n      aiModel,\n      processingContext,\n      aiTimestamp,\n      options\n    );\n  }\n\n  /**\n   * Filters session changes by AI provider with validation\n   */\n  getAIChanges(sessionId: string, aiProvider?: string): EditChange[] {\n    const session = this.sessions.get(sessionId);\n    if (!session) return [];\n\n    return session.changes.filter(change => {\n      if (!change.aiProvider) return false;\n      if (aiProvider && change.aiProvider !== aiProvider) return false;\n      return true;\n    });\n  }\n\n  /**\n   * Gets enhanced AI metadata statistics for a session with security info\n   */\n  getAIMetadataStats(sessionId: string): {\n    totalAIChanges: number;\n    aiProviders: string[];\n    aiModels: string[];\n    hasProcessingContext: number;\n    validationWarnings: number;\n    securityThreats: string[];\n  } {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      return {\n        totalAIChanges: 0,\n        aiProviders: [],\n        aiModels: [],\n        hasProcessingContext: 0,\n        validationWarnings: 0,\n        securityThreats: []\n      };\n    }\n\n    const aiChanges = session.changes.filter(change => change.aiProvider);\n    const aiProviders = [...new Set(aiChanges.map(change => change.aiProvider).filter(Boolean))] as string[];\n    const aiModels = [...new Set(aiChanges.map(change => change.aiModel).filter(Boolean))] as string[];\n    const hasProcessingContext = aiChanges.filter(change => change.processingContext).length;\n\n    // Analyze for potential security issues in stored metadata\n    let validationWarnings = 0;\n    const allSecurityThreats = new Set<string>();\n\n    aiChanges.forEach(change => {\n      if (change.aiProvider) {\n        const providerResult = AIMetadataValidator.validateAIProvider(change.aiProvider);\n        validationWarnings += providerResult.warnings.length;\n        providerResult.securityThreats.forEach(threat => allSecurityThreats.add(threat));\n      }\n      \n      if (change.aiModel) {\n        const modelResult = AIMetadataValidator.validateAIModel(change.aiModel);\n        validationWarnings += modelResult.warnings.length;\n        modelResult.securityThreats.forEach(threat => allSecurityThreats.add(threat));\n      }\n\n      if (change.processingContext) {\n        const contextResult = AIMetadataValidator.validateProcessingContext(change.processingContext);\n        validationWarnings += contextResult.warnings.length;\n        contextResult.securityThreats.forEach(threat => allSecurityThreats.add(threat));\n      }\n    });\n\n    return {\n      totalAIChanges: aiChanges.length,\n      aiProviders,\n      aiModels,\n      hasProcessingContext,\n      validationWarnings,\n      securityThreats: Array.from(allSecurityThreats)\n    };\n  }\n\n  private async updateSessionCounts(session: EditSession, file: TFile) {\n    try {\n      const content = await this.plugin.app.vault.read(file);\n      session.wordCount = getWordCount(content);\n      session.characterCount = getCharacterCount(content);\n    } catch (error) {\n      console.error('Failed to update session counts:', error);\n    }\n  }\n\n  getSession(sessionId: string): EditSession | undefined {\n    return this.sessions.get(sessionId);\n  }\n\n  getSessionHistory(): EditSession[] {\n    return Array.from(this.sessions.values()).sort((a, b) => b.startTime - a.startTime);\n  }\n\n  async saveSession(session: EditSession) {\n    this.sessions.set(session.id, session);\n    await this.saveSessions();\n    this.updateQuerySystemData();\n  }\n\n  clearHistory() {\n    this.sessions.clear();\n    this.activeSessions.clear();\n    this.saveSessions();\n    this.updateQuerySystemData();\n  }\n\n  async formatSessionForExport(session: EditSession, format: 'json' | 'csv' | 'markdown'): Promise<string> {\n    switch (format) {\n      case 'json':\n        return JSON.stringify(session, null, 2);\n      \n      case 'csv':\n        let csv = 'Timestamp,Type,From,To,Text,RemovedText,Author,AIProvider,AIModel,ProcessingContext,AITimestamp\\\\n';\n        for (const change of session.changes) {\n          const row = [\n            new Date(change.timestamp).toISOString(),\n            change.type,\n            change.from,\n            change.to,\n            `\"${(change.text || '').replace(/\"/g, '\"\"')}\"`,\n            `\"${(change.removedText || '').replace(/\"/g, '\"\"')}\"`,\n            change.author || '',\n            EditChangeCompatibilityUtils.getAIProvider(change, ''),\n            EditChangeCompatibilityUtils.getAIModel(change, ''),\n            change.processingContext ? `\"${JSON.stringify(change.processingContext).replace(/\"/g, '\"\"')}\"` : '',\n            EditChangeCompatibilityUtils.getAITimestamp(change) ? EditChangeCompatibilityUtils.getAITimestamp(change)!.toISOString() : ''\n          ].join(',');\n          csv += row + '\\n';\n        }\n        return csv;\n      \n      case 'markdown':\n        const startDate = new Date(session.startTime).toLocaleString();\n        const endDate = session.endTime ? new Date(session.endTime).toLocaleString() : 'In progress';\n        const duration = session.endTime ? \n          Math.round((session.endTime - session.startTime) / 1000 / 60) + ' minutes' : \n          'In progress';\n\n        let markdown = `# Edit Session Report\\n\\n`;\n        markdown += `- **Start:** ${startDate}\\n`;\n        markdown += `- **End:** ${endDate}\\n`;\n        markdown += `- **Duration:** ${duration}\\n`;\n        markdown += `- **Changes:** ${session.changes.length}\\n`;\n        markdown += `- **Words:** ${session.wordCount}\\n`;\n        markdown += `- **Characters:** ${session.characterCount}\\n\\n`;\n\n        // Enhanced AI metadata statistics using compatibility layer\n        const arrayStats = EditChangeCompatibilityUtils.getArrayStats(session.changes);\n        const metadataStats = this.getAIMetadataStats(session.id);\n        \n        if (arrayStats.aiGenerated > 0) {\n          markdown += `## AI-Assisted Edits\\n\\n`;\n          markdown += `- **Total Changes:** ${arrayStats.total}\\n`;\n          markdown += `- **AI-Generated:** ${arrayStats.aiGenerated}\\n`;\n          markdown += `- **Manual Edits:** ${arrayStats.manual}\\n`;\n          markdown += `- **AI Providers:** ${arrayStats.providers.join(', ') || 'None'}\\n`;\n          markdown += `- **AI Models:** ${arrayStats.models.join(', ') || 'None'}\\n`;\n          markdown += `- **With Processing Context:** ${arrayStats.withContext}\\n`;\n          \n          // Add security information if any threats detected\n          if (metadataStats.securityThreats.length > 0) {\n            markdown += `- **Security Threats Detected:** ${metadataStats.securityThreats.join(', ')}\\n`;\n          }\n          if (metadataStats.validationWarnings > 0) {\n            markdown += `- **Validation Warnings:** ${metadataStats.validationWarnings}\\n`;\n          }\n          markdown += `\\n`;\n        }\n\n        if (session.changes.length > 0) {\n          markdown += `## Changes\\n\\n`;\n          for (const change of session.changes) {\n            const time = new Date(change.timestamp).toLocaleTimeString();\n            const sourceDesc = EditChangeCompatibilityUtils.getAISourceDescription(change);\n            \n            markdown += `- **${time}** - ${change.type} at position ${change.from}-${change.to}`;\n            markdown += ` (${sourceDesc})`;\n            markdown += `\\n`;\n            \n            if (change.text) {\n              markdown += `  - Added: \"${change.text}\"\\n`;\n            }\n            if (change.removedText) {\n              markdown += `  - Removed: \"${change.removedText}\"\\n`;\n            }\n            \n            // Show processing context if available\n            const context = EditChangeCompatibilityUtils.getProcessingContext(change);\n            if (context) {\n              if (context.mode) {\n                markdown += `  - Processing Mode: ${context.mode}\\n`;\n              }\n              if (context.constraints && context.constraints.length > 0) {\n                markdown += `  - Constraints: ${context.constraints.join(', ')}\\n`;\n              }\n            }\n          }\n        }\n\n        return markdown;\n      \n      default:\n        return JSON.stringify(session, null, 2);\n    }\n  }\n\n  // Clean up old sessions based on retention policy\n  cleanupOldSessions() {\n    if (this.plugin.settings.retentionDays === 0) return; // Keep forever\n\n    const cutoffTime = Date.now() - (this.plugin.settings.retentionDays * 24 * 60 * 60 * 1000);\n    const toDelete: string[] = [];\n\n    for (const [sessionId, session] of this.sessions.entries()) {\n      if (session.startTime < cutoffTime) {\n        toDelete.push(sessionId);\n      }\n    }\n\n    for (const sessionId of toDelete) {\n      this.sessions.delete(sessionId);\n    }\n\n    if (toDelete.length > 0) {\n      this.saveSessions();\n      // Update query system after cleanup\n      this.querySystem.updateSessions(this.sessions);\n    }\n  }\n\n  // ========================================================================\n  // Task 1.6: Query System Integration - Advanced Query Methods\n  // ========================================================================\n\n  /**\n   * Creates a new query builder instance for flexible change queries\n   * Provides fluent API for building complex queries with method chaining\n   */\n  // ========================================================================\n  // Task 1.7: Enhanced Persistence Layer with Schema Versioning and Robust Data Handling\n  // ========================================================================\n\n  /**\n   * Schema version for tracking data format evolution\n   */\n  private static readonly SCHEMA_VERSION = '1.7.0';\n  private static readonly SCHEMA_KEY = '__schemaVersion';\n\n  /**\n   * Processes stored data with schema versioning and validation\n   */\n  private async processStoredDataWithVersioning(data: any): Promise<any> {\n    // Check for schema version\n    const storedVersion = data[EditTracker.SCHEMA_KEY];\n    const currentVersion = EditTracker.SCHEMA_VERSION;\n\n    if (!storedVersion) {\n      console.log('Migrating data to versioned schema...');\n      return this.migrateToVersionedSchema(data);\n    }\n\n    if (storedVersion !== currentVersion) {\n      console.log(`Migrating data from version ${storedVersion} to ${currentVersion}...`);\n      return this.migrateDataToCurrentVersion(data, storedVersion);\n    }\n\n    // Validate data integrity\n    return this.validateStoredData(data);\n  }\n\n  /**\n   * Migrates unversioned data to current schema version\n   */\n  private async migrateToVersionedSchema(data: any): Promise<any> {\n    // Use existing compatibility utils for legacy migration\n    const migratedData = EditChangeCompatibilityUtils.needsMigration(data) \n      ? EditChangeCompatibilityUtils.migrateStoredData(data)\n      : data;\n\n    // Add schema version and metadata\n    return {\n      ...migratedData,\n      [EditTracker.SCHEMA_KEY]: EditTracker.SCHEMA_VERSION,\n      __migrationTimestamp: Date.now(),\n      __dataIntegrityHash: await this.generateDataHash(migratedData)\n    };\n  }\n\n  /**\n   * Migrates data between different schema versions\n   */\n  private async migrateDataToCurrentVersion(data: any, fromVersion: string): Promise<any> {\n    let migratedData = { ...data };\n\n    // Version-specific migrations could be added here\n    switch (fromVersion) {\n      case '1.6.0':\n        // Migration from 1.6.0 to 1.7.0\n        migratedData = this.migrate1_6_to_1_7(migratedData);\n        break;\n      default:\n        console.warn(`Unknown schema version ${fromVersion}, attempting generic migration...`);\n        migratedData = await this.migrateToVersionedSchema(data);\n        break;\n    }\n\n    // Update version and regenerate hash\n    migratedData[EditTracker.SCHEMA_KEY] = EditTracker.SCHEMA_VERSION;\n    migratedData.__migrationTimestamp = Date.now();\n    migratedData.__dataIntegrityHash = await this.generateDataHash(migratedData);\n\n    return migratedData;\n  }\n\n  /**\n   * Specific migration from 1.6.0 to 1.7.0 schema\n   */\n  private migrate1_6_to_1_7(data: any): any {\n    // In 1.7.0, we enhanced Date serialization and added compression\n    if (data.sessions) {\n      data.sessions = data.sessions.map((session: EditSession) => ({\n        ...session,\n        changes: session.changes.map((change: EditChange) => this.normalizeChangeForStorage(change))\n      }));\n    }\n    return data;\n  }\n\n  /**\n   * Validates stored data integrity\n   */\n  private async validateStoredData(data: any): Promise<any> {\n    const storedHash = data.__dataIntegrityHash;\n    if (storedHash) {\n      // Create temporary data without hash for validation\n      const { __dataIntegrityHash, ...dataForValidation } = data;\n      const calculatedHash = await this.generateDataHash(dataForValidation);\n      \n      if (storedHash !== calculatedHash) {\n        console.warn('Data integrity hash mismatch - data may be corrupted');\n        // Continue with data but log the issue\n      }\n    }\n\n    return data;\n  }\n\n  /**\n   * Generates a hash for data integrity checking\n   */\n  private async generateDataHash(data: any): Promise<string> {\n    try {\n      const dataString = JSON.stringify(data, this.createSortedReplacer());\n      // Simple hash function for data integrity (not cryptographic)\n      let hash = 0;\n      for (let i = 0; i < dataString.length; i++) {\n        const char = dataString.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash; // Convert to 32-bit integer\n      }\n      return hash.toString(36);\n    } catch (error) {\n      console.warn('Failed to generate data hash:', error);\n      return 'invalid';\n    }\n  }\n\n  /**\n   * Creates a replacer function that sorts object keys for consistent hashing\n   */\n  private createSortedReplacer(): (key: string, value: any) => any {\n    return (key: string, value: any) => {\n      if (value && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {\n        const sortedObj: any = {};\n        Object.keys(value).sort().forEach(k => {\n          sortedObj[k] = value[k];\n        });\n        return sortedObj;\n      }\n      return value;\n    };\n  }\n\n  /**\n   * Prepares session data for storage with enhanced serialization\n   */\n  private async prepareDataForStorage(sessions: EditSession[]): Promise<any> {\n    const processedSessions = sessions.map(session => ({\n      ...session,\n      changes: session.changes.map(change => this.serializeChange(change))\n    }));\n\n    const data = {\n      [EditTracker.SCHEMA_KEY]: EditTracker.SCHEMA_VERSION,\n      sessions: processedSessions,\n      __lastSaved: Date.now(),\n      __compressionLevel: 'none' // Could be enhanced later\n    };\n\n    // Add data integrity hash\n    data.__dataIntegrityHash = await this.generateDataHash({ sessions: processedSessions });\n\n    return data;\n  }\n\n  /**\n   * Properly serializes an EditChange object with Date handling\n   */\n  private serializeChange(change: EditChange): any {\n    const serialized = { ...change };\n    \n    // Handle Date serialization for aiTimestamp\n    if (change.aiTimestamp) {\n      serialized.aiTimestamp = change.aiTimestamp instanceof Date \n        ? change.aiTimestamp.toISOString()\n        : change.aiTimestamp;\n    }\n\n    // Normalize processing context for consistent storage\n    if (change.processingContext) {\n      serialized.processingContext = this.normalizeProcessingContext(change.processingContext);\n    }\n\n    return serialized;\n  }\n\n  /**\n   * Properly deserializes an EditChange object with Date reconstruction\n   */\n  private deserializeChange(change: any): EditChange {\n    const deserialized = { ...change };\n\n    // Handle Date deserialization for aiTimestamp\n    if (change.aiTimestamp && typeof change.aiTimestamp === 'string') {\n      try {\n        deserialized.aiTimestamp = new Date(change.aiTimestamp);\n        // Validate the date\n        if (isNaN(deserialized.aiTimestamp.getTime())) {\n          console.warn(`Invalid aiTimestamp found: ${change.aiTimestamp}`);\n          deserialized.aiTimestamp = undefined;\n        }\n      } catch (error) {\n        console.warn(`Failed to parse aiTimestamp: ${change.aiTimestamp}`, error);\n        deserialized.aiTimestamp = undefined;\n      }\n    }\n\n    return deserialized as EditChange;\n  }\n\n  /**\n   * Normalizes change data for consistent storage\n   */\n  private normalizeChangeForStorage(change: EditChange): EditChange {\n    // Ensure consistent field ordering and clean up any undefined values\n    const normalized: any = {\n      id: change.id,\n      timestamp: change.timestamp,\n      type: change.type,\n      from: change.from,\n      to: change.to\n    };\n\n    // Only include defined optional fields\n    if (change.text !== undefined) normalized.text = change.text;\n    if (change.removedText !== undefined) normalized.removedText = change.removedText;\n    if (change.author !== undefined) normalized.author = change.author;\n    if (change.aiProvider !== undefined) normalized.aiProvider = change.aiProvider;\n    if (change.aiModel !== undefined) normalized.aiModel = change.aiModel;\n    if (change.processingContext !== undefined) {\n      normalized.processingContext = this.normalizeProcessingContext(change.processingContext);\n    }\n    if (change.aiTimestamp !== undefined) normalized.aiTimestamp = change.aiTimestamp;\n\n    return normalized;\n  }\n\n  /**\n   * Normalizes processing context for storage\n   */\n  private normalizeProcessingContext(context: AIProcessingContext): AIProcessingContext {\n    const normalized: any = {};\n    \n    if (context.mode !== undefined) normalized.mode = context.mode;\n    if (context.constraints !== undefined) normalized.constraints = [...context.constraints].sort();\n    if (context.settings !== undefined) {\n      // Sort settings keys for consistency\n      const sortedSettings: any = {};\n      Object.keys(context.settings).sort().forEach(key => {\n        sortedSettings[key] = context.settings![key];\n      });\n      normalized.settings = sortedSettings;\n    }\n    if (context.metadata !== undefined) normalized.metadata = context.metadata;\n\n    return normalized;\n  }\n\n  /**\n   * Recovers from corrupted data with fallback strategies\n   */\n  private async recoverFromCorruptedData(error: Error): Promise<void> {\n    console.warn('Attempting data recovery from corruption...', error);\n\n    try {\n      // Strategy 1: Try to load partial data\n      const rawData = await this.plugin.loadData();\n      if (rawData && typeof rawData === 'object') {\n        // Try to salvage any valid sessions\n        const salvageSessions = this.salvageValidSessions(rawData);\n        if (salvageSessions.length > 0) {\n          console.log(`Recovered ${salvageSessions.length} sessions from corrupted data`);\n          salvageSessions.forEach(session => this.sessions.set(session.id, session));\n          this.updateQuerySystemData();\n          return;\n        }\n      }\n    } catch (recoveryError) {\n      console.error('Data recovery failed:', recoveryError);\n    }\n\n    // Strategy 2: Start fresh with empty data\n    console.log('Starting with empty session storage due to unrecoverable corruption');\n    await this.plugin.saveData({\n      [EditTracker.SCHEMA_KEY]: EditTracker.SCHEMA_VERSION,\n      sessions: [],\n      __lastSaved: Date.now(),\n      __recoveryTimestamp: Date.now()\n    });\n  }\n\n  /**\n   * Attempts to salvage valid sessions from corrupted data\n   */\n  private salvageValidSessions(data: any): EditSession[] {\n    const validSessions: EditSession[] = [];\n\n    if (!data.sessions || !Array.isArray(data.sessions)) {\n      return validSessions;\n    }\n\n    for (const session of data.sessions) {\n      try {\n        // Validate basic session structure\n        if (this.isValidSession(session)) {\n          // Clean up session changes\n          const cleanedSession = {\n            ...session,\n            changes: this.salvageValidChanges(session.changes || [])\n          };\n          validSessions.push(cleanedSession);\n        }\n      } catch (error) {\n        console.warn('Failed to salvage session:', session?.id, error);\n      }\n    }\n\n    return validSessions;\n  }\n\n  /**\n   * Validates basic session structure\n   */\n  private isValidSession(session: any): session is EditSession {\n    return (\n      session &&\n      typeof session.id === 'string' &&\n      typeof session.startTime === 'number' &&\n      Array.isArray(session.changes)\n    );\n  }\n\n  /**\n   * Salvages valid changes from potentially corrupted change array\n   */\n  private salvageValidChanges(changes: any[]): EditChange[] {\n    const validChanges: EditChange[] = [];\n\n    for (const change of changes) {\n      try {\n        if (EditChangeCompatibilityUtils.isValidEditChange(change)) {\n          const cleanedChange = this.deserializeChange(change);\n          validChanges.push(cleanedChange);\n        }\n      } catch (error) {\n        console.warn('Failed to salvage change:', change?.id, error);\n      }\n    }\n\n    return validChanges;\n  }\n\n  /**\n   * Emergency save with minimal data to prevent total loss\n   */\n  private async emergencySave(originalError: Error): Promise<void> {\n    try {\n      console.warn('Attempting emergency save after failure:', originalError);\n      \n      // Save basic session info without potentially problematic metadata\n      const basicSessions = Array.from(this.sessions.values()).map(session => ({\n        id: session.id,\n        startTime: session.startTime,\n        endTime: session.endTime,\n        wordCount: session.wordCount || 0,\n        characterCount: session.characterCount || 0,\n        changes: session.changes.map(change => ({\n          id: change.id || Date.now().toString(),\n          timestamp: change.timestamp,\n          type: change.type,\n          from: change.from,\n          to: change.to,\n          text: change.text || '',\n          removedText: change.removedText || '',\n          author: change.author || 'unknown'\n          // Deliberately omit AI metadata to avoid serialization issues\n        }))\n      }));\n\n      await this.plugin.saveData({\n        [EditTracker.SCHEMA_KEY]: EditTracker.SCHEMA_VERSION,\n        sessions: basicSessions,\n        __emergencySave: true,\n        __lastSaved: Date.now()\n      });\n\n      console.log('Emergency save completed successfully');\n    } catch (emergencyError) {\n      console.error('Emergency save also failed:', emergencyError);\n      // At this point, we've done all we can\n    }\n  }\n\n  query(): QueryBuilder {\n    return this.querySystem.query();\n  }\n\n  /**\n   * Quick query methods for common use cases\n   */\n  \n  /**\n   * Get all changes from a specific AI provider\n   */\n  async getChangesByProvider(provider: string): Promise<EditChange[]> {\n    return this.querySystem.getChangesByProvider(provider);\n  }\n\n  /**\n   * Get all changes from a specific AI model\n   */\n  async getChangesByModel(model: string): Promise<EditChange[]> {\n    return this.querySystem.getChangesByModel(model);\n  }\n\n  /**\n   * Get changes within a specific time range\n   */\n  async getChangesInTimeRange(start: Date, end: Date): Promise<EditChange[]> {\n    return this.querySystem.getChangesInTimeRange(start, end);\n  }\n\n  /**\n   * Get changes by processing mode\n   */\n  async getChangesByMode(mode: string): Promise<EditChange[]> {\n    return this.querySystem.getChangesByMode(mode);\n  }\n\n  /**\n   * Get all AI-generated changes\n   */\n  async getAIGeneratedChanges(): Promise<EditChange[]> {\n    return this.querySystem.getAIGeneratedChanges();\n  }\n\n  /**\n   * Get all manual (non-AI) changes\n   */\n  async getManualChanges(): Promise<EditChange[]> {\n    return this.querySystem.getManualChanges();\n  }\n\n  /**\n   * Advanced search methods\n   */\n\n  /**\n   * Full-text search across change content and processing context\n   */\n  async textSearch(query: string, options?: {\n    caseSensitive?: boolean;\n    fuzzyMatch?: boolean;\n    searchIn?: ('text' | 'removedText' | 'processingContext')[];\n  }): Promise<EditChange[]> {\n    return this.querySystem.textSearch(query, options);\n  }\n\n  /**\n   * Search within processing context only\n   */\n  async contextSearch(query: string): Promise<EditChange[]> {\n    return this.querySystem.contextSearch(query);\n  }\n\n  /**\n   * Statistical analysis methods\n   */\n\n  /**\n   * Get usage statistics by AI provider\n   */\n  async getProviderUsageStats(): Promise<Record<string, number>> {\n    return this.querySystem.getProviderUsageStats();\n  }\n\n  /**\n   * Get usage statistics by AI model\n   */\n  async getModelUsageStats(): Promise<Record<string, number>> {\n    return this.querySystem.getModelUsageStats();\n  }\n\n  /**\n   * Get usage statistics by processing mode\n   */\n  async getModeUsageStats(): Promise<Record<string, number>> {\n    return this.querySystem.getModeUsageStats();\n  }\n\n  /**\n   * AI Performance Comparison Methods\n   */\n\n  /**\n   * Compare performance across different AI providers\n   */\n  async compareProviders(providers: string[]) {\n    return this.querySystem.compareProviders(providers);\n  }\n\n  /**\n   * Compare performance across different AI models\n   */\n  async compareModels(models: string[]) {\n    return this.querySystem.compareModels(models);\n  }\n\n  /**\n   * Compare performance across different processing modes\n   */\n  async compareModes(modes: string[]) {\n    return this.querySystem.compareModes(modes);\n  }\n\n  /**\n   * Export methods for various formats\n   */\n\n  /**\n   * Export query results as JSON\n   */\n  async exportChangesAsJSON(criteria: any): Promise<string> {\n    return this.querySystem.exportToJSON(criteria);\n  }\n\n  /**\n   * Export query results as CSV\n   */\n  async exportChangesAsCSV(criteria: any, format?: any): Promise<string> {\n    return this.querySystem.exportToCSV(criteria, format);\n  }\n\n  /**\n   * Export query results as Markdown\n   */\n  async exportChangesAsMarkdown(criteria: any, format?: any): Promise<string> {\n    return this.querySystem.exportToMarkdown(criteria, format);\n  }\n\n  /**\n   * Advanced analytics methods\n   */\n\n  /**\n   * Get timeline data showing changes over time\n   */\n  async getTimelineData(options: {\n    interval: 'hour' | 'day' | 'week' | 'month';\n    fillGaps?: boolean;\n    includeMetadata?: boolean;\n  }) {\n    return this.querySystem.getTimelineData(options);\n  }\n\n  /**\n   * Aggregate changes by various dimensions\n   */\n  async aggregateChanges(criteria: any, options: {\n    groupBy: 'provider' | 'model' | 'hour' | 'day' | 'week' | 'month' | 'mode' | 'author';\n    aggregateFunction?: 'count' | 'sum' | 'avg' | 'min' | 'max';\n    aggregateField?: string;\n  }): Promise<Record<string, number>> {\n    return this.querySystem.aggregate(criteria, options);\n  }\n\n  /**\n   * Update query system when sessions change\n   * Called internally after session modifications\n   */\n  private updateQuerySystemData(): void {\n    this.querySystem.updateSessions(this.sessions);\n  }\n}\n\n/**\n * Backward Compatibility Utilities\n * Embedded compatibility layer for handling legacy EditChange objects\n */\n\n// Legacy EditChange interface (pre-AI metadata)\ninterface LegacyEditChange {\n  id: string;\n  timestamp: number;\n  type: 'insert' | 'delete' | 'replace';\n  from: number;\n  to: number;\n  text?: string;\n  removedText?: string;\n  author?: string;\n}\n\n/**\n * Utility class for EditChange compatibility operations\n */\nclass EditChangeCompatibilityUtils {\n  /**\n   * Checks if an EditChange object has any AI metadata fields\n   */\n  static hasAIMetadata(change: EditChange): boolean {\n    return !!(\n      change.aiProvider || \n      change.aiModel || \n      change.processingContext || \n      change.aiTimestamp\n    );\n  }\n\n  /**\n   * Checks if an EditChange object is a legacy object (no AI metadata)\n   */\n  static isLegacyChange(change: EditChange): boolean {\n    return !(\n      'aiProvider' in change || \n      'aiModel' in change || \n      'processingContext' in change || \n      'aiTimestamp' in change\n    );\n  }\n\n  /**\n   * Validates that an object has the minimum required EditChange fields\n   */\n  static isValidEditChange(obj: any): obj is EditChange {\n    return (\n      obj &&\n      typeof obj.id === 'string' &&\n      typeof obj.timestamp === 'number' &&\n      ['insert', 'delete', 'replace'].includes(obj.type) &&\n      typeof obj.from === 'number' &&\n      typeof obj.to === 'number'\n    );\n  }\n\n  /**\n   * Converts a legacy EditChange to enhanced format with empty AI metadata\n   */\n  static upgradeToEnhanced(legacyChange: LegacyEditChange): EditChange {\n    return {\n      ...legacyChange,\n      aiProvider: undefined,\n      aiModel: undefined,\n      processingContext: undefined,\n      aiTimestamp: undefined\n    };\n  }\n\n  /**\n   * Batch upgrade an array of mixed legacy and enhanced changes\n   */\n  static upgradeChangesArray(changes: EditChange[]): EditChange[] {\n    return changes.map(change => {\n      if (this.isLegacyChange(change)) {\n        return this.upgradeToEnhanced(change as LegacyEditChange);\n      }\n      return change;\n    });\n  }\n\n  /**\n   * Checks if stored data needs migration\n   */\n  static needsMigration(data: any): boolean {\n    if (!data || !data.sessions || !Array.isArray(data.sessions)) {\n      return false;\n    }\n\n    // Check if any session contains legacy changes\n    return data.sessions.some((session: EditSession) => \n      session.changes && session.changes.some((change: EditChange) => \n        this.isLegacyChange(change)\n      )\n    );\n  }\n\n  /**\n   * Migrates stored plugin data to new format\n   */\n  static migrateStoredData(data: any): any {\n    if (!data || !data.sessions) {\n      return data;\n    }\n\n    return {\n      ...data,\n      sessions: data.sessions.map((session: EditSession) => ({\n        ...session,\n        changes: this.upgradeChangesArray(session.changes)\n      }))\n    };\n  }\n\n  /**\n   * Safely gets AI provider with fallback\n   */\n  static getAIProvider(change: EditChange, fallback: string = 'unknown'): string {\n    return change.aiProvider || fallback;\n  }\n\n  /**\n   * Safely gets AI model with fallback\n   */\n  static getAIModel(change: EditChange, fallback: string = 'unknown'): string {\n    return change.aiModel || fallback;\n  }\n\n  /**\n   * Safely gets processing context with fallback\n   */\n  static getProcessingContext(change: EditChange, fallback?: AIProcessingContext): AIProcessingContext | undefined {\n    return change.processingContext || fallback;\n  }\n\n  /**\n   * Safely gets AI timestamp with fallback\n   */\n  static getAITimestamp(change: EditChange, fallback?: Date): Date | undefined {\n    if (change.aiTimestamp) {\n      return change.aiTimestamp instanceof Date ? change.aiTimestamp : new Date(change.aiTimestamp);\n    }\n    return fallback;\n  }\n\n  /**\n   * Gets a human-readable AI source description\n   */\n  static getAISourceDescription(change: EditChange): string {\n    if (!this.hasAIMetadata(change)) {\n      return 'Manual edit';\n    }\n\n    const provider = this.getAIProvider(change, 'Unknown Provider');\n    const model = this.getAIModel(change, 'Unknown Model');\n    \n    return `AI-assisted (${provider}/${model})`;\n  }\n\n  /**\n   * Checks if change was AI-generated\n   */\n  static isAIGenerated(change: EditChange): boolean {\n    return this.hasAIMetadata(change) && !!(change.aiProvider && change.aiModel);\n  }\n\n  /**\n   * Gets statistics for an array of EditChange objects\n   */\n  static getArrayStats(changes: EditChange[]): {\n    total: number;\n    aiGenerated: number;\n    manual: number;\n    providers: string[];\n    models: string[];\n    withContext: number;\n  } {\n    const aiChanges = changes.filter(change => this.isAIGenerated(change));\n    const manualChanges = changes.filter(change => !this.isAIGenerated(change));\n    \n    const providers = [...new Set(\n      aiChanges.map(change => this.getAIProvider(change))\n      .filter(provider => provider !== 'unknown')\n    )];\n    \n    const models = [...new Set(\n      aiChanges.map(change => this.getAIModel(change))\n      .filter(model => model !== 'unknown')\n    )];\n    \n    const withContext = changes.filter(change => \n      this.getProcessingContext(change) !== undefined\n    ).length;\n\n    return {\n      total: changes.length,\n      aiGenerated: aiChanges.length,\n      manual: manualChanges.length,\n      providers,\n      models,\n      withContext\n    };\n  }\n}\n", "import { EditChange } from '@shared/types';\nimport TrackEditsPlugin from './main';\nimport { MarkdownView } from 'obsidian';\n\nexport class EditRenderer {\n  private plugin: TrackEditsPlugin;\n  private trackingIndicator: HTMLElement | null = null;\n  private decorationContainer: HTMLElement | null = null;\n  private activeDecorations: HTMLElement[] = [];\n\n  constructor(plugin: TrackEditsPlugin) {\n    this.plugin = plugin;\n  }\n\n  showTrackingIndicator() {\n    // Status is now shown in the side panel - no need for separate indicator\n    console.log('Track Edits v2.0: Tracking started (status shown in side panel)');\n  }\n\n  hideTrackingIndicator() {\n    try {\n      // Remove any lingering tracking indicator if it exists\n      if (this.trackingIndicator && this.trackingIndicator.parentNode) {\n        this.trackingIndicator.remove();\n        this.trackingIndicator = null;\n      }\n      \n      // Also clear any active decorations\n      this.clearDecorations();\n      console.log('Track Edits v2.0: Tracking stopped (status shown in side panel)');\n    } catch (error) {\n      console.error('Track Edits: Error hiding tracking indicator:', error);\n      this.trackingIndicator = null;\n    }\n  }\n\n  // Safe decoration system using DOM overlay approach\n  showChangeDecorations(changes: EditChange[]) {\n    this.clearDecorations();\n    \n    const activeLeaf = this.plugin.app.workspace.getActiveViewOfType(MarkdownView);\n    if (!activeLeaf || !activeLeaf.editor) {\n      console.log('Track Edits v2.0: No active editor found for decorations');\n      return;\n    }\n\n    console.log('Track Edits v2.0: Showing decorations for', changes.length, 'changes');\n    \n    // Use safe DOM overlay approach instead of CodeMirror extensions\n    this.createDOMOverlayDecorations(activeLeaf, changes);\n    \n    // Also create temporary notification bubbles\n    changes.forEach((change, index) => {\n      this.createTemporaryHighlight(change, index);\n    });\n  }\n\n  private createDOMOverlayDecorations(markdownView: MarkdownView, changes: EditChange[]) {\n    try {\n      // Get the editor container\n      const editorContainer = markdownView.contentEl.querySelector('.cm-editor');\n      if (!editorContainer) {\n        console.log('Track Edits v2.0: Editor container not found');\n        return;\n      }\n\n      // Create decoration container if it doesn't exist\n      if (!this.decorationContainer) {\n        this.decorationContainer = document.createElement('div');\n        this.decorationContainer.className = 'track-edits-decoration-overlay';\n        this.decorationContainer.style.cssText = `\n          position: absolute;\n          top: 0;\n          left: 0;\n          width: 100%;\n          height: 100%;\n          pointer-events: none;\n          z-index: 5;\n        `;\n        editorContainer.appendChild(this.decorationContainer);\n      }\n\n      // Create decorations for recent changes\n      const now = Date.now();\n      const recentChanges = changes.filter(change => now - change.timestamp < 5000);\n\n      recentChanges.forEach(change => {\n        this.createSafeDecoration(change);\n      });\n\n      console.log('Track Edits v2.0: Created', recentChanges.length, 'DOM overlay decorations');\n    } catch (error) {\n      console.error('Track Edits v2.0: Error creating DOM overlay decorations:', error);\n    }\n  }\n\n  private createSafeDecoration(change: EditChange) {\n    if (!this.decorationContainer) return;\n\n    // Get editor position for the change\n    const position = this.getEditorPosition(change);\n    if (!position || position.left < 0 || position.top < 0) {\n      console.log('Track Edits v2.0: Invalid position for decoration:', position);\n      return;\n    }\n\n    const decoration = document.createElement('div');\n    decoration.className = this.getDecorationClass(change);\n    decoration.style.cssText = `\n      position: absolute;\n      left: ${position.left}px;\n      top: ${position.top}px;\n      width: ${Math.max(position.width, 20)}px;\n      height: ${position.height}px;\n      pointer-events: none;\n      z-index: 10;\n      border-radius: 3px;\n      animation: track-edits-highlight-fade 3s ease-out forwards;\n    `;\n\n    decoration.title = `${change.type} at ${new Date(change.timestamp).toLocaleTimeString()}`;\n    \n    this.decorationContainer.appendChild(decoration);\n    this.activeDecorations.push(decoration);\n\n    // Auto-remove after animation\n    setTimeout(() => {\n      if (decoration.parentNode) {\n        decoration.remove();\n        this.activeDecorations = this.activeDecorations.filter(d => d !== decoration);\n      }\n    }, 3000);\n  }\n\n  private getEditorPosition(change: EditChange): { left: number; top: number; width: number; height: number } | null {\n    try {\n      const activeLeaf = this.plugin.app.workspace.getActiveViewOfType(MarkdownView);\n      if (!activeLeaf || !activeLeaf.editor) return null;\n\n      const editor = activeLeaf.editor;\n      \n      // Convert document position to editor coordinates\n      const pos = editor.offsetToPos(change.from);\n      // Use Obsidian's proper API instead of direct CodeMirror access\n      const coords = editor.coordsAtPos(pos, false);\n      \n      if (!coords) {\n        console.log('Track Edits v2.0: No coordinates returned for position', pos);\n        return null;\n      }\n\n      // Get the editor container to calculate relative positioning\n      const editorContainer = activeLeaf.contentEl.querySelector('.cm-editor');\n      if (!editorContainer) return null;\n\n      const editorRect = editorContainer.getBoundingClientRect();\n\n      // Convert absolute coordinates to relative coordinates within the editor with bounds checking\n      const result = {\n        left: Math.max(0, coords.left - editorRect.left),\n        top: Math.max(0, coords.top - editorRect.top),\n        width: Math.max((change.text?.length || 1) * 8, 20), // Approximate character width\n        height: Math.max(coords.bottom - coords.top, 16) // Minimum height\n      };\n      \n      console.log('Track Edits v2.0: Calculated position:', result, 'for change at', change.from);\n      return result;\n    } catch (error) {\n      console.error('Track Edits v2.0: Error getting editor position:', error);\n      return null;\n    }\n  }\n\n  private getDecorationClass(change: EditChange): string {\n    let className = 'track-edits-decoration';\n    \n    switch (change.type) {\n      case 'insert':\n        className += ' track-edits-decoration-insert';\n        break;\n      case 'delete':\n        className += ' track-edits-decoration-delete';\n        break;\n      case 'replace':\n        className += ' track-edits-decoration-replace';\n        break;\n    }\n\n    // Apply color scheme\n    className += ` track-edits-decoration-${this.plugin.settings.colorScheme}`;\n\n    return className;\n  }\n  \n  private createTemporaryHighlight(change: EditChange, index: number) {\n    const highlight = document.createElement('div');\n    highlight.className = 'track-edits-temp-highlight';\n    highlight.style.cssText = `\n      position: fixed;\n      top: ${60 + (index * 25)}px;\n      right: 60px;\n      background: var(--background-modifier-success);\n      color: var(--text-on-accent);\n      padding: 2px 6px;\n      border-radius: 3px;\n      font-size: 10px;\n      z-index: 999;\n      opacity: 0.9;\n      animation: fadeInOut 3s ease-in-out;\n    `;\n    highlight.textContent = `${change.type}: \"${change.text || ''}\"`;\n    \n    document.body.appendChild(highlight);\n    this.activeDecorations.push(highlight);\n    \n    // Auto-remove after 3 seconds\n    setTimeout(() => {\n      if (highlight.parentNode) {\n        highlight.remove();\n        this.activeDecorations = this.activeDecorations.filter(el => el !== highlight);\n      }\n    }, 3000);\n  }\n  \n  clearDecorations() {\n    // Remove all active decorations\n    this.activeDecorations.forEach(decoration => {\n      if (decoration.parentNode) {\n        decoration.remove();\n      }\n    });\n    this.activeDecorations = [];\n\n    // Remove decoration container if it exists\n    if (this.decorationContainer && this.decorationContainer.parentNode) {\n      this.decorationContainer.remove();\n      this.decorationContainer = null;\n    }\n  }\n\n  // Method for backward compatibility - no longer returns CodeMirror extension\n  getCodeMirrorExtension() {\n    // Return null to avoid conflicts - we use DOM overlay instead\n    return null;\n  }\n}", "import { ItemView, WorkspaceLeaf } from 'obsidian';\nimport TrackEditsPlugin from './main';\nimport { EditCluster } from './edit-cluster-manager';\n\nexport const SIDE_PANEL_VIEW_TYPE = 'track-edits-side-panel';\n\nexport class EditSidePanelView extends ItemView {\n  plugin: TrackEditsPlugin;\n  private clusters: EditCluster[] = [];\n  private runOnceBtn: HTMLElement | null = null;\n\n  constructor(leaf: WorkspaceLeaf, plugin: TrackEditsPlugin) {\n    super(leaf);\n    this.plugin = plugin;\n  }\n\n  getViewType(): string {\n    return SIDE_PANEL_VIEW_TYPE;\n  }\n\n  getDisplayText(): string {\n    return 'Track Edits';\n  }\n\n  getIcon(): string {\n    return 'edit';\n  }\n\n  async onOpen() {\n    const container = this.containerEl.children[1];\n    container.empty();\n    container.addClass('track-edits-side-panel');\n\n    this.renderView();\n  }\n\n  async onClose() {\n    // Cleanup when panel is closed\n  }\n\n  updateClusters(clusters: EditCluster[]) {\n    this.clusters = clusters;\n    this.renderView();\n  }\n\n  private renderView() {\n    const container = this.containerEl.children[1];\n    container.empty();\n\n    // Header - v2.0 style with status indicator\n    const header = container.createEl('h2');\n    header.createEl('span', { text: 'Track Edits' });\n    \n    // Add status dot\n    const statusDot = header.createEl('span', {\n      cls: 'track-edits-status-dot'\n    });\n    \n    if (this.plugin.currentSession) {\n      statusDot.addClass('track-edits-status-active');\n      statusDot.setAttribute('title', 'Tracking active');\n    } else {\n      statusDot.addClass('track-edits-status-inactive');\n      statusDot.setAttribute('title', 'Tracking stopped');\n    }\n\n    // Edit count summary - v2.0 style\n    const countText = this.clusters.length === 0 \n      ? 'No edits to review'\n      : `${this.clusters.length} cluster${this.clusters.length !== 1 ? 's' : ''} to review`;\n    container.createEl('p', { \n      text: countText,\n      cls: 'track-edits-count'\n    });\n\n    // AI Controls section (matching v2.0 design)\n    this.createAIControlsSection(container);\n\n    // Accept All / Reject All controls (v1.0 addition that v2.0 doesn't have)\n    if (this.clusters.length > 0) {\n      const bulkControls = container.createEl('div', { cls: 'track-edits-bulk-controls' });\n      \n      // Left side: text labels\n      bulkControls.createEl('span', {\n        text: 'Accept / Reject All',\n        cls: 'track-edits-bulk-text'\n      });\n      \n      // Right side: action buttons (aligned with individual buttons)\n      const buttonsContainer = bulkControls.createEl('div', { cls: 'track-edits-bulk-buttons' });\n      \n      const acceptAllBtn = buttonsContainer.createEl('button', {\n        text: '\u2713',\n        cls: 'track-edits-bulk-btn track-edits-bulk-accept',\n        title: 'Accept all edits'\n      });\n      acceptAllBtn.onclick = () => this.acceptAllClusters();\n      \n      const rejectAllBtn = buttonsContainer.createEl('button', {\n        text: '\u2717',\n        cls: 'track-edits-bulk-btn track-edits-bulk-reject',\n        title: 'Reject all edits'\n      });\n      rejectAllBtn.onclick = () => this.rejectAllClusters();\n    }\n\n    // Edits list - v2.0 style\n    const editsList = container.createEl('div', { cls: 'track-edits-list' });\n    \n    if (this.clusters.length === 0) {\n      return;\n    }\n\n    // Render each cluster - v2.0 style\n    this.clusters.forEach((cluster, index) => {\n      this.renderCluster(editsList, cluster, index);\n    });\n  }\n\n  private renderCluster(container: HTMLElement, cluster: EditCluster, index: number) {\n    // v2.0 style: Clean cluster item with flexbox layout\n    const clusterItem = container.createEl('div', { cls: 'track-edit-item track-cluster-item' });\n    const clusterRow = clusterItem.createEl('div', { cls: 'track-cluster-row' });\n    \n    // Left side: edit display (v2.0 style)\n    const clusterContent = clusterRow.createEl('div', { cls: 'track-cluster-content' });\n    \n    const previewText = this.getClusterPreview(cluster);\n    \n    if (cluster.type === 'word_replacement') {\n      // Show deletion \u2192 insertion cleanly\n      const deleteSpan = clusterContent.createEl('code', { \n        text: previewText.before || '',\n        cls: 'track-edit-deleted'\n      });\n      clusterContent.appendText(' \u2192 ');\n      const addSpan = clusterContent.createEl('code', {\n        text: previewText.after || '',\n        cls: 'track-edit-added'\n      });\n    } else {\n      // Show addition cleanly\n      clusterContent.createEl('code', {\n        text: previewText.text || '',\n        cls: 'track-edit-added'\n      });\n    }\n    \n    // Right side: action buttons (v2.0 style - minimal)\n    const buttonsContainer = clusterRow.createEl('div', { cls: 'track-edit-buttons' });\n    \n    const acceptBtn = buttonsContainer.createEl('button', {\n      text: '\u2713',\n      cls: 'track-edit-btn track-edit-btn-accept',\n      title: 'Accept edit'\n    });\n    acceptBtn.onclick = () => this.acceptCluster(cluster.id);\n    \n    const rejectBtn = buttonsContainer.createEl('button', {\n      text: '\u2717',\n      cls: 'track-edit-btn track-edit-btn-reject',\n      title: 'Reject edit'\n    });\n    rejectBtn.onclick = () => this.rejectCluster(cluster.id);\n  }\n\n  private getClusterTitle(cluster: EditCluster): string {\n    switch (cluster.type) {\n      case 'word_replacement':\n        return 'Word Replacement';\n      case 'consecutive_typing':\n        return 'Consecutive Typing';\n      case 'deletion':\n        return 'Text Deletion';\n      default:\n        return 'Text Edit';\n    }\n  }\n\n  private getClusterTime(cluster: EditCluster): string {\n    const now = Date.now();\n    const timeDiff = now - cluster.startTime;\n    \n    if (timeDiff < 1000) {\n      return 'Just now';\n    } else if (timeDiff < 60000) {\n      return `${Math.floor(timeDiff / 1000)}s ago`;\n    } else {\n      return `${Math.floor(timeDiff / 60000)}m ago`;\n    }\n  }\n\n  private getClusterPreview(cluster: EditCluster): { text?: string; before?: string; after?: string } {\n    if (cluster.type === 'word_replacement') {\n      return {\n        before: cluster.metadata?.originalWord || '',\n        after: cluster.metadata?.newWord || ''\n      };\n    } else {\n      const text = cluster.edits\n        .map(edit => edit.text || '')\n        .join('')\n        .slice(0, 50);\n      return { text: text + (text.length === 50 ? '...' : '') };\n    }\n  }\n\n  private acceptCluster(clusterId: string) {\n    this.plugin.acceptEditCluster(clusterId);\n  }\n\n  private rejectCluster(clusterId: string) {\n    this.plugin.rejectEditCluster(clusterId);\n  }\n\n  private acceptAllClusters() {\n    // Take a snapshot of cluster IDs to avoid issues with array changing during iteration\n    const clusterIds = this.clusters.map(cluster => cluster.id);\n    \n    // Use batch processing method for better performance\n    this.plugin.acceptAllEditClusters(clusterIds);\n  }\n\n  private rejectAllClusters() {\n    // Add confirmation for destructive action\n    if (this.clusters.length > 3) {\n      const confirmed = confirm(`Are you sure you want to reject all ${this.clusters.length} edits? This cannot be undone.`);\n      if (!confirmed) return;\n    }\n    \n    // CRITICAL: Stop tracking FIRST to prevent new edits during rejection\n    this.plugin.stopTracking();\n    \n    // Take a snapshot of cluster IDs to avoid issues with array changing during iteration\n    const clusterIds = this.clusters.map(cluster => cluster.id);\n    \n    // Use batch processing method for better performance\n    this.plugin.rejectAllEditClusters(clusterIds);\n  }\n\n  private createAIControlsSection(container: HTMLElement): void {\n    const controlsDiv = container.createEl('div', { cls: 'track-edits-ai-simple' });\n    const controlsLine = controlsDiv.createEl('div', { cls: 'ai-simple-line' });\n    \n    // Left side: \"AI\" label with toggle right next to it\n    const labelToggleGroup = controlsLine.createEl('div', { cls: 'ai-label-toggle-group' });\n    \n    // \"AI\" label - more prominent\n    labelToggleGroup.createEl('span', { text: 'AI', cls: 'ai-simple-label' });\n    \n    // Toggle switch right next to label\n    const toggleSwitch = labelToggleGroup.createEl('div', { cls: 'ai-simple-toggle' });\n    toggleSwitch.addClass(this.plugin.settings.aiAlwaysEnabled ? 'on' : 'off');\n    toggleSwitch.setAttribute('title', this.plugin.settings.aiAlwaysEnabled ? 'AI Always On' : 'AI Manual Only');\n    \n    // Toggle click handler\n    toggleSwitch.onclick = () => {\n      this.plugin.settings.aiAlwaysEnabled = !this.plugin.settings.aiAlwaysEnabled;\n      this.plugin.saveSettings();\n      this.renderView(); // Re-render to update toggle state\n    };\n    \n    // Right side: \"Run Once\" button - more prominent\n    this.runOnceBtn = controlsLine.createEl('button', {\n      text: 'Run Once',\n      cls: this.plugin.settings.aiAlwaysEnabled ? 'ai-simple-btn disabled' : 'ai-simple-btn enabled',\n      title: 'Run AI analysis once on current edits'\n    });\n    \n    // Run Once click handler (only if not always enabled)\n    this.runOnceBtn.onclick = () => {\n      if (!this.plugin.settings.aiAlwaysEnabled) {\n        this.runAIAnalysisOnce();\n      }\n    };\n  }\n\n  private async runAIAnalysisOnce(): Promise<void> {\n    if (!this.runOnceBtn) return;\n    \n    // Update button state\n    this.runOnceBtn.textContent = 'Running...';\n    this.runOnceBtn.addClass('running');\n    \n    try {\n      // TODO: Call AI analysis method when implemented\n      await this.plugin.runAIAnalysisOnce();\n      \n      // Provide user feedback\n      this.runOnceBtn.textContent = 'Done!';\n      setTimeout(() => {\n        if (this.runOnceBtn) {\n          this.runOnceBtn.textContent = 'Run Once';\n          this.runOnceBtn.removeClass('running');\n        }\n      }, 2000);\n      \n    } catch (error) {\n      console.error('AI analysis failed:', error);\n      this.runOnceBtn.textContent = 'Error';\n      setTimeout(() => {\n        if (this.runOnceBtn) {\n          this.runOnceBtn.textContent = 'Run Once';\n          this.runOnceBtn.removeClass('running');\n        }\n      }, 2000);\n    }\n  }\n}", "import { EditChange } from '@shared/types';\nimport { generateId } from '@shared/utils';\nimport TrackEditsPlugin from './main';\n\nexport interface EditCluster {\n  id: string;\n  type: 'consecutive_typing' | 'word_replacement' | 'deletion' | 'mixed';\n  edits: EditChange[];\n  startTime: number;\n  endTime: number;\n  wordCount: number;\n  characterCount: number;\n  metadata?: {\n    originalWord?: string;\n    newWord?: string;\n    position?: number;\n  };\n}\n\nexport class EditClusterManager {\n  private plugin: TrackEditsPlugin;\n  private activeClusters: Map<string, EditCluster> = new Map();\n\n  constructor(plugin: TrackEditsPlugin) {\n    this.plugin = plugin;\n  }\n\n  clusterEdits(edits: EditChange[]): EditCluster[] {\n    if (!this.plugin.settings.enableClustering || edits.length === 0) {\n      return [];\n    }\n\n    // Clear old clusters\n    this.activeClusters.clear();\n\n    // Sort edits by timestamp\n    const sortedEdits = [...edits].sort((a, b) => a.timestamp - b.timestamp);\n\n    // Group edits into clusters\n    const clusters: EditCluster[] = [];\n    let currentCluster: EditChange[] = [];\n    let lastTimestamp = 0;\n\n    for (const edit of sortedEdits) {\n      const timeDiff = edit.timestamp - lastTimestamp;\n      \n      // Start new cluster if time window exceeded or first edit\n      if (timeDiff > this.plugin.settings.clusterTimeWindow || currentCluster.length === 0) {\n        if (currentCluster.length > 0) {\n          const cluster = this.createCluster(currentCluster);\n          if (cluster) {\n            clusters.push(cluster);\n            this.activeClusters.set(cluster.id, cluster);\n          }\n        }\n        currentCluster = [edit];\n      } else {\n        // Check if edit belongs to same word/context\n        if (this.areEditsInSameWord(currentCluster[currentCluster.length - 1], edit)) {\n          currentCluster.push(edit);\n        } else {\n          // Create cluster from current edits and start new one\n          const cluster = this.createCluster(currentCluster);\n          if (cluster) {\n            clusters.push(cluster);\n            this.activeClusters.set(cluster.id, cluster);\n          }\n          currentCluster = [edit];\n        }\n      }\n      \n      lastTimestamp = edit.timestamp;\n    }\n\n    // Process final cluster\n    if (currentCluster.length > 0) {\n      const cluster = this.createCluster(currentCluster);\n      if (cluster) {\n        clusters.push(cluster);\n        this.activeClusters.set(cluster.id, cluster);\n      }\n    }\n\n    return clusters;\n  }\n\n  private createCluster(edits: EditChange[]): EditCluster | null {\n    if (edits.length === 0) return null;\n\n    const startTime = Math.min(...edits.map(e => e.timestamp));\n    const endTime = Math.max(...edits.map(e => e.timestamp));\n    const clusterType = this.determineClusterType(edits);\n    \n    const cluster: EditCluster = {\n      id: generateId(),\n      type: clusterType,\n      edits: edits,\n      startTime,\n      endTime,\n      wordCount: this.calculateWordCount(edits),\n      characterCount: this.calculateCharacterCount(edits),\n      metadata: this.generateClusterMetadata(edits, clusterType)\n    };\n\n    return cluster;\n  }\n\n  private areEditsInSameWord(edit1: EditChange, edit2: EditChange): boolean {\n    // Check if positions are close (within word boundary)\n    const positionDiff = Math.abs(edit1.to - edit2.from);\n    \n    // Allow small gaps (like backspace then type)\n    if (positionDiff <= 5) {\n      return true;\n    }\n\n    // Check if both edits are in consecutive character positions\n    if (edit1.type === 'insert' && edit2.type === 'insert') {\n      return edit1.to === edit2.from || edit1.to === edit2.from - 1;\n    }\n\n    return false;\n  }\n\n  private determineClusterType(edits: EditChange[]): EditCluster['type'] {\n    const insertCount = edits.filter(e => e.type === 'insert').length;\n    const deleteCount = edits.filter(e => e.type === 'delete').length;\n    const replaceCount = edits.filter(e => e.type === 'replace').length;\n\n    // Word replacement pattern: delete followed by insert(s)\n    if (deleteCount > 0 && insertCount > 0) {\n      return 'word_replacement';\n    }\n\n    // Pure deletion\n    if (deleteCount > 0 && insertCount === 0) {\n      return 'deletion';\n    }\n\n    // Consecutive typing\n    if (insertCount > 0 && deleteCount === 0) {\n      return 'consecutive_typing';\n    }\n\n    return 'mixed';\n  }\n\n  private calculateWordCount(edits: EditChange[]): number {\n    const text = edits\n      .filter(e => e.text)\n      .map(e => e.text!)\n      .join('');\n    \n    return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n  }\n\n  private calculateCharacterCount(edits: EditChange[]): number {\n    return edits\n      .filter(e => e.text)\n      .reduce((count, edit) => count + (edit.text?.length || 0), 0);\n  }\n\n  private generateClusterMetadata(edits: EditChange[], type: EditCluster['type']): EditCluster['metadata'] {\n    const metadata: EditCluster['metadata'] = {};\n\n    if (type === 'word_replacement') {\n      const deletedEdits = edits.filter(e => e.type === 'delete');\n      const insertedEdits = edits.filter(e => e.type === 'insert');\n      \n      if (deletedEdits.length > 0) {\n        metadata.originalWord = deletedEdits\n          .map(e => e.removedText || '')\n          .join('');\n      }\n      \n      if (insertedEdits.length > 0) {\n        metadata.newWord = insertedEdits\n          .map(e => e.text || '')\n          .join('');\n      }\n    }\n\n    if (edits.length > 0) {\n      metadata.position = edits[0].from;\n    }\n\n    return metadata;\n  }\n\n  getCluster(clusterId: string): EditCluster | undefined {\n    return this.activeClusters.get(clusterId);\n  }\n\n  removeCluster(clusterId: string): boolean {\n    return this.activeClusters.delete(clusterId);\n  }\n\n  getAllClusters(): EditCluster[] {\n    return Array.from(this.activeClusters.values());\n  }\n\n  clearClusters(): void {\n    this.activeClusters.clear();\n  }\n}", "import { App } from 'obsidian';\n\nexport type StateChangeCallback = (enabled: boolean) => void;\n\nexport class ToggleStateManager {\n  private app: App;\n  private trackingEnabled: boolean;\n  private ribbonIcon: HTMLElement | null = null;\n  private statusIndicator: HTMLElement | null = null;\n  private sidePanel: HTMLElement | null = null;\n  private sidePanelOriginalContent: string = '';\n  public onStateChange: StateChangeCallback;\n\n  constructor(app: App, onStateChange: StateChangeCallback) {\n    this.app = app;\n    this.onStateChange = onStateChange;\n    \n    // Load saved state or default to enabled\n    this.trackingEnabled = this.loadSavedState();\n    \n    // Create screen reader announcer element\n    this.createAriaAnnouncer();\n  }\n\n  get isTrackingEnabled(): boolean {\n    return this.trackingEnabled;\n  }\n\n  /**\n   * Set tracking enabled/disabled state\n   */\n  setTrackingEnabled(enabled: boolean): void {\n    if (this.trackingEnabled === enabled) {\n      return; // No change\n    }\n\n    this.trackingEnabled = enabled;\n    \n    // Save state to session storage\n    this.saveState();\n    \n    // Update all UI elements\n    this.updateRibbonIcon();\n    this.updateStatusIndicator();\n    this.updateSidePanel();\n    \n    // Announce to screen readers\n    this.announceStateChange(enabled);\n    \n    // Notify callback\n    this.onStateChange(enabled);\n  }\n\n  /**\n   * Set the ribbon icon element to manage\n   */\n  setRibbonIcon(ribbonElement: HTMLElement): void {\n    this.ribbonIcon = ribbonElement;\n    this.updateRibbonIcon();\n  }\n\n  /**\n   * Set the status indicator element to manage\n   */\n  setStatusIndicator(statusElement: HTMLElement): void {\n    this.statusIndicator = statusElement;\n    this.updateStatusIndicator();\n  }\n\n  /**\n   * Set the side panel element to manage\n   */\n  setSidePanel(sidePanelElement: HTMLElement): void {\n    this.sidePanel = sidePanelElement;\n    // Save original content for restoration\n    this.sidePanelOriginalContent = sidePanelElement.innerHTML;\n    this.updateSidePanel();\n  }\n\n  private updateRibbonIcon(): void {\n    if (!this.ribbonIcon) return;\n\n    // Add transition class for smooth animation\n    this.ribbonIcon.classList.add('state-transition');\n\n    if (this.trackingEnabled) {\n      this.ribbonIcon.classList.add('track-edits-enabled');\n      this.ribbonIcon.classList.remove('track-edits-disabled');\n      this.ribbonIcon.title = 'Track Edits (Active) - Click to manage changes';\n      this.ribbonIcon.setAttribute('aria-label', 'Track Edits is active. Click to manage tracked changes.');\n    } else {\n      this.ribbonIcon.classList.add('track-edits-disabled');\n      this.ribbonIcon.classList.remove('track-edits-enabled');\n      this.ribbonIcon.title = 'Track Edits (Disabled) - Click to enable';\n      this.ribbonIcon.setAttribute('aria-label', 'Track Edits disabled. Click to enable tracking.');\n    }\n\n    // Remove transition class after animation completes\n    setTimeout(() => {\n      if (this.ribbonIcon) {\n        this.ribbonIcon.classList.remove('state-transition');\n      }\n    }, 300);\n  }\n\n  private updateStatusIndicator(): void {\n    if (!this.statusIndicator) return;\n\n    if (this.trackingEnabled) {\n      this.statusIndicator.classList.add('status-active');\n      this.statusIndicator.classList.remove('status-disabled');\n      this.statusIndicator.setAttribute('aria-label', 'Track Edits is active');\n      this.statusIndicator.textContent = 'Active';\n    } else {\n      this.statusIndicator.classList.add('status-disabled');\n      this.statusIndicator.classList.remove('status-active');\n      this.statusIndicator.setAttribute('aria-label', 'Track Edits is disabled');\n      this.statusIndicator.textContent = 'Disabled';\n    }\n  }\n\n  private updateSidePanel(): void {\n    if (!this.sidePanel) return;\n\n    if (this.trackingEnabled) {\n      this.sidePanel.classList.add('track-edits-active');\n      this.sidePanel.classList.remove('track-edits-disabled');\n      // Restore original content when re-enabled\n      if (this.sidePanelOriginalContent) {\n        this.sidePanel.innerHTML = this.sidePanelOriginalContent;\n      }\n    } else {\n      this.sidePanel.classList.add('track-edits-disabled');\n      this.sidePanel.classList.remove('track-edits-active');\n      // Show empty state\n      this.sidePanel.innerHTML = this.createEmptyStateHTML();\n    }\n  }\n\n  private createEmptyStateHTML(): string {\n    return `\n      <div class=\"track-edits-empty-state\">\n        <div class=\"empty-state-icon\">\n          <svg width=\"48\" height=\"48\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\">\n            <path d=\"M9 12l2 2 4-4\"></path>\n            <path d=\"M21 12c-1 0-3-1-3-3s2-3 3-3 3 1 3 3-2 3-3 3\"></path>\n            <path d=\"M3 12c1 0 3-1 3-3s-2-3-3-3-3 1-3 3 2 3 3 3\"></path>\n            <path d=\"M3 12h6m6 0h6\"></path>\n          </svg>\n        </div>\n        <h3 class=\"empty-state-title\">Tracking disabled</h3>\n        <p class=\"empty-state-description\">\n          Enable Track Edits to see changes and suggestions for your document.\n        </p>\n        <button class=\"empty-state-button\" onclick=\"window.TrackEdits?.enableTracking()\">\n          Enable Track Edits\n        </button>\n      </div>\n    `;\n  }\n\n  private saveState(): void {\n    sessionStorage.setItem('track-edits-enabled', String(this.trackingEnabled));\n  }\n\n  private loadSavedState(): boolean {\n    const saved = sessionStorage.getItem('track-edits-enabled');\n    return saved !== null ? saved === 'true' : true; // Default to enabled\n  }\n\n  private createAriaAnnouncer(): void {\n    // Create hidden element for screen reader announcements\n    let announcer = document.getElementById('track-edits-announcer');\n    if (!announcer) {\n      announcer = document.createElement('div');\n      announcer.id = 'track-edits-announcer';\n      announcer.setAttribute('aria-live', 'polite');\n      announcer.setAttribute('aria-atomic', 'true');\n      announcer.style.position = 'absolute';\n      announcer.style.left = '-10000px';\n      announcer.style.width = '1px';\n      announcer.style.height = '1px';\n      announcer.style.overflow = 'hidden';\n      document.body.appendChild(announcer);\n    }\n  }\n\n  private announceStateChange(enabled: boolean): void {\n    const announcer = document.getElementById('track-edits-announcer');\n    if (announcer) {\n      announcer.textContent = enabled \n        ? 'Track Edits has been enabled'\n        : 'Track Edits has been disabled';\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy(): void {\n    const announcer = document.getElementById('track-edits-announcer');\n    if (announcer && announcer.parentNode) {\n      announcer.parentNode.removeChild(announcer);\n    }\n  }\n}", "import { App, Modal } from 'obsidian';\n\nexport interface ToggleConfirmationOptions {\n  editCount: number;\n  onConfirm: () => void;\n  onCancel: () => void;\n}\n\nexport class ToggleConfirmationModal extends Modal {\n  private options: ToggleConfirmationOptions;\n  private keydownHandler: (e: KeyboardEvent) => void;\n\n  constructor(app: App, options: ToggleConfirmationOptions) {\n    super(app);\n    this.options = options;\n    \n    // Bind keyboard handler\n    this.keydownHandler = this.handleKeydown.bind(this);\n  }\n\n  get editCount(): number {\n    return this.options.editCount;\n  }\n\n  get onConfirm(): () => void {\n    return this.options.onConfirm;\n  }\n\n  get onCancel(): () => void {\n    return this.options.onCancel;\n  }\n\n  onOpen(): void {\n    const { contentEl } = this;\n    const { editCount } = this.options;\n\n    // Clear content\n    contentEl.empty();\n    contentEl.addClass('toggle-confirmation-modal');\n\n    // Create header\n    const header = contentEl.createEl('h2', {\n      text: 'Turn Off Track Edits?',\n      cls: 'modal-title'\n    });\n\n    // Create clear, concise message\n    const messageEl = contentEl.createEl('p', {\n      cls: 'modal-message'\n    });\n    \n    const editText = editCount === 1 ? 'edit' : 'edits';\n    messageEl.textContent = `You have ${editCount} pending ${editText}. These changes will be lost if you turn off tracking.`;\n\n    // TODO: Add \"Don't ask again\" option in future update\n\n    // Create button container\n    const buttonContainer = contentEl.createEl('div', {\n      cls: 'modal-button-container'\n    });\n\n    // Create Cancel button (secondary)\n    const cancelButton = buttonContainer.createEl('button', {\n      text: 'Keep Tracking',\n      cls: 'modal-button modal-button-secondary'\n    });\n\n    cancelButton.addEventListener('click', () => {\n      this.handleCancel();\n    });\n\n    // Create Confirm button (primary)\n    const confirmButton = buttonContainer.createEl('button', {\n      text: 'Turn Off Anyway',\n      cls: 'modal-button modal-button-primary'\n    });\n\n    confirmButton.addEventListener('click', () => {\n      this.handleConfirm();\n    });\n\n    // Set focus to cancel button (safe default)\n    cancelButton.focus();\n\n    // Add keyboard event listener\n    document.addEventListener('keydown', this.keydownHandler);\n  }\n\n  onClose(): void {\n    // Remove keyboard event listener\n    document.removeEventListener('keydown', this.keydownHandler);\n  }\n\n  private handleKeydown(e: KeyboardEvent): void {\n    if (e.key === 'Escape') {\n      e.preventDefault();\n      this.handleCancel();\n    } else if (e.key === 'Enter') {\n      e.preventDefault();\n      this.handleConfirm();\n    }\n  }\n\n  private handleConfirm(): void {\n    this.options.onConfirm();\n    this.close();\n  }\n\n  private handleCancel(): void {\n    this.options.onCancel();\n    this.close();\n  }\n\n  // TODO: Add shouldSkipConfirmation() and resetSessionPreference() methods in future update\n}", "/**\n * Change Grouping System for Editorial Engine Batch Processing\n * Task 2.4: Platform Integration - Intelligent change batching and grouping\n * \n * This system provides semantic change grouping logic that matches how writers\n * actually work with Editorial Engine operations like copy editing, proofreading,\n * and developmental planning.\n */\n\nimport { \n  EditorialOperationType, \n  ChangeGroupingStrategy, \n  ChangeGroupMetadata, \n  ChangeGroupingConfig,\n  ChangeGroupingResult\n} from './types/submit-changes-from-ai';\n\n// Import EditChange from the test file structure for now\ninterface EditChange {\n  id?: string;\n  timestamp: number;\n  type: 'insert' | 'delete' | 'replace';\n  from: number;\n  to: number;\n  text?: string;\n  removedText?: string;\n  author?: string;\n  aiProvider?: string;\n  aiModel?: string;\n  processingContext?: any;\n  aiTimestamp?: Date;\n}\n\n/**\n * Core change grouping system that provides intelligent batching\n * for Editorial Engine operations\n */\nexport class ChangeGroupingSystem {\n  private config: ChangeGroupingConfig;\n  private groupIdCounter = 0;\n\n  constructor(config?: Partial<ChangeGroupingConfig>) {\n    this.config = {\n      enabled: true,\n      defaultStrategy: 'mixed',\n      maxChangesPerGroup: 25,\n      timeWindowMs: 5000, // 5 seconds\n      proximityThreshold: 100, // 100 characters\n      minChangesForGroup: 2,\n      enableHierarchicalGrouping: true,\n      operationGroupingRules: {\n        'proofreading': {\n          strategy: 'proximity',\n          maxChangesPerGroup: 50,\n          priority: 'medium'\n        },\n        'copy-edit-pass': {\n          strategy: 'mixed',\n          maxChangesPerGroup: 30,\n          priority: 'high'\n        },\n        'developmental-feedback': {\n          strategy: 'semantic',\n          maxChangesPerGroup: 15,\n          priority: 'high'\n        },\n        'style-refinement': {\n          strategy: 'operation-type',\n          maxChangesPerGroup: 20,\n          priority: 'medium'\n        }\n      },\n      ...config\n    };\n  }\n\n  /**\n   * Main entry point for grouping changes from Editorial Engine operations\n   */\n  public groupChanges(\n    changes: EditChange[],\n    operationType: EditorialOperationType,\n    operationDescription?: string\n  ): ChangeGroupingResult {\n    if (!this.config.enabled || changes.length < this.config.minChangesForGroup) {\n      return this.createEmptyGroupingResult(changes);\n    }\n\n    const strategy = this.determineGroupingStrategy(operationType);\n    const groups: ChangeGroupMetadata[] = [];\n    const ungroupedChanges: string[] = [];\n    const warnings: string[] = [];\n\n    try {\n      switch (strategy) {\n        case 'proximity':\n          this.groupByProximity(changes, operationType, operationDescription, groups, ungroupedChanges);\n          break;\n        case 'operation-type':\n          this.groupByOperationType(changes, operationType, operationDescription, groups, ungroupedChanges);\n          break;\n        case 'semantic':\n          this.groupBySemantic(changes, operationType, operationDescription, groups, ungroupedChanges);\n          break;\n        case 'time-window':\n          this.groupByTimeWindow(changes, operationType, operationDescription, groups, ungroupedChanges);\n          break;\n        case 'mixed':\n          this.groupByMixedStrategy(changes, operationType, operationDescription, groups, ungroupedChanges);\n          break;\n        default:\n          // No grouping - all changes remain ungrouped\n          ungroupedChanges.push(...changes.map(c => c.id!));\n      }\n\n      // Apply hierarchical grouping if enabled\n      if (this.config.enableHierarchicalGrouping && groups.length > 1) {\n        this.createHierarchicalGroups(groups);\n      }\n\n    } catch (error) {\n      warnings.push(`Grouping error: ${error instanceof Error ? error.message : String(error)}`);\n      // Fall back to no grouping\n      ungroupedChanges.push(...changes.map(c => c.id!));\n    }\n\n    return this.createGroupingResult(changes, groups, ungroupedChanges, warnings);\n  }\n\n  /**\n   * Group changes by proximity - changes close together in the document\n   */\n  private groupByProximity(\n    changes: EditChange[],\n    operationType: EditorialOperationType,\n    operationDescription: string | undefined,\n    groups: ChangeGroupMetadata[],\n    ungroupedChanges: string[]\n  ): void {\n    // Sort changes by position\n    const sortedChanges = [...changes].sort((a, b) => a.from - b.from);\n    let currentGroup: EditChange[] = [];\n\n    for (const change of sortedChanges) {\n      if (currentGroup.length === 0) {\n        currentGroup.push(change);\n      } else {\n        const lastChange = currentGroup[currentGroup.length - 1];\n        const distance = change.from - lastChange.to;\n\n        // If within proximity threshold, add to current group\n        if (distance <= this.config.proximityThreshold && \n            currentGroup.length < this.getMaxChangesForOperation(operationType)) {\n          currentGroup.push(change);\n        } else {\n          // Finalize current group and start new one\n          if (currentGroup.length >= this.config.minChangesForGroup) {\n            groups.push(this.createGroupMetadata(currentGroup, operationType, 'proximity', operationDescription));\n          } else {\n            ungroupedChanges.push(...currentGroup.map(c => c.id!));\n          }\n          currentGroup = [change];\n        }\n      }\n    }\n\n    // Handle final group\n    if (currentGroup.length >= this.config.minChangesForGroup) {\n      groups.push(this.createGroupMetadata(currentGroup, operationType, 'proximity', operationDescription));\n    } else {\n      ungroupedChanges.push(...currentGroup.map(c => c.id!));\n    }\n  }\n\n  /**\n   * Group changes by operation type - similar change types together\n   */\n  private groupByOperationType(\n    changes: EditChange[],\n    operationType: EditorialOperationType,\n    operationDescription: string | undefined,\n    groups: ChangeGroupMetadata[],\n    ungroupedChanges: string[]\n  ): void {\n    const changesByType = new Map<string, EditChange[]>();\n\n    // Group by change type (insert, delete, replace)\n    for (const change of changes) {\n      const key = change.type;\n      if (!changesByType.has(key)) {\n        changesByType.set(key, []);\n      }\n      changesByType.get(key)!.push(change);\n    }\n\n    // Create groups for each type that has sufficient changes\n    for (const [type, typeChanges] of changesByType.entries()) {\n      if (typeChanges.length >= this.config.minChangesForGroup) {\n        // Further subdivide large groups\n        const maxChanges = this.getMaxChangesForOperation(operationType);\n        const subGroups = this.subdivideGroup(typeChanges, maxChanges);\n        \n        for (const subGroup of subGroups) {\n          groups.push(this.createGroupMetadata(\n            subGroup, \n            operationType, \n            'operation-type', \n            operationDescription,\n            `${this.getOperationTypeDescription(type)} changes`\n          ));\n        }\n      } else {\n        ungroupedChanges.push(...typeChanges.map(c => c.id!));\n      }\n    }\n  }\n\n  /**\n   * Group changes by semantic similarity\n   */\n  private groupBySemantic(\n    changes: EditChange[],\n    operationType: EditorialOperationType,\n    operationDescription: string | undefined,\n    groups: ChangeGroupMetadata[],\n    ungroupedChanges: string[]\n  ): void {\n    // For semantic grouping, we use a combination of content analysis and position\n    const semanticGroups = new Map<string, EditChange[]>();\n\n    for (const change of changes) {\n      const semanticKey = this.determineSemanticKey(change, operationType);\n      if (!semanticGroups.has(semanticKey)) {\n        semanticGroups.set(semanticKey, []);\n      }\n      semanticGroups.get(semanticKey)!.push(change);\n    }\n\n    // Create groups for semantic clusters\n    for (const [semanticKey, semanticChanges] of semanticGroups.entries()) {\n      if (semanticChanges.length >= this.config.minChangesForGroup) {\n        const maxChanges = this.getMaxChangesForOperation(operationType);\n        const subGroups = this.subdivideGroup(semanticChanges, maxChanges);\n        \n        for (const subGroup of subGroups) {\n          groups.push(this.createGroupMetadata(\n            subGroup, \n            operationType, \n            'semantic', \n            operationDescription,\n            `${semanticKey} improvements`\n          ));\n        }\n      } else {\n        ungroupedChanges.push(...semanticChanges.map(c => c.id!));\n      }\n    }\n  }\n\n  /**\n   * Group changes by time window\n   */\n  private groupByTimeWindow(\n    changes: EditChange[],\n    operationType: EditorialOperationType,\n    operationDescription: string | undefined,\n    groups: ChangeGroupMetadata[],\n    ungroupedChanges: string[]\n  ): void {\n    // Sort changes by timestamp\n    const sortedChanges = [...changes].sort((a, b) => a.timestamp - b.timestamp);\n    let currentGroup: EditChange[] = [];\n    let groupStartTime = 0;\n\n    for (const change of sortedChanges) {\n      if (currentGroup.length === 0) {\n        currentGroup.push(change);\n        groupStartTime = change.timestamp;\n      } else {\n        const timeSinceGroupStart = change.timestamp - groupStartTime;\n\n        // If within time window, add to current group\n        if (timeSinceGroupStart <= this.config.timeWindowMs && \n            currentGroup.length < this.getMaxChangesForOperation(operationType)) {\n          currentGroup.push(change);\n        } else {\n          // Finalize current group and start new one\n          if (currentGroup.length >= this.config.minChangesForGroup) {\n            groups.push(this.createGroupMetadata(currentGroup, operationType, 'time-window', operationDescription));\n          } else {\n            ungroupedChanges.push(...currentGroup.map(c => c.id!));\n          }\n          currentGroup = [change];\n          groupStartTime = change.timestamp;\n        }\n      }\n    }\n\n    // Handle final group\n    if (currentGroup.length >= this.config.minChangesForGroup) {\n      groups.push(this.createGroupMetadata(currentGroup, operationType, 'time-window', operationDescription));\n    } else {\n      ungroupedChanges.push(...currentGroup.map(c => c.id!));\n    }\n  }\n\n  /**\n   * Mixed strategy combining proximity, operation type, and semantic analysis\n   */\n  private groupByMixedStrategy(\n    changes: EditChange[],\n    operationType: EditorialOperationType,\n    operationDescription: string | undefined,\n    groups: ChangeGroupMetadata[],\n    ungroupedChanges: string[]\n  ): void {\n    // First pass: Group by proximity\n    const proximityGroups: EditChange[][] = [];\n    const sortedChanges = [...changes].sort((a, b) => a.from - b.from);\n    let currentGroup: EditChange[] = [];\n\n    for (const change of sortedChanges) {\n      if (currentGroup.length === 0) {\n        currentGroup.push(change);\n      } else {\n        const lastChange = currentGroup[currentGroup.length - 1];\n        const distance = change.from - lastChange.to;\n\n        if (distance <= this.config.proximityThreshold * 2) { // More lenient for mixed strategy\n          currentGroup.push(change);\n        } else {\n          if (currentGroup.length > 0) {\n            proximityGroups.push(currentGroup);\n          }\n          currentGroup = [change];\n        }\n      }\n    }\n    if (currentGroup.length > 0) {\n      proximityGroups.push(currentGroup);\n    }\n\n    // Second pass: Within each proximity group, further organize by operation type\n    for (const proximityGroup of proximityGroups) {\n      if (proximityGroup.length < this.config.minChangesForGroup) {\n        ungroupedChanges.push(...proximityGroup.map(c => c.id!));\n        continue;\n      }\n\n      // Sub-group by operation type within this proximity group\n      const typeGroups = new Map<string, EditChange[]>();\n      for (const change of proximityGroup) {\n        const typeKey = `${change.type}-${this.determineSemanticKey(change, operationType)}`;\n        if (!typeGroups.has(typeKey)) {\n          typeGroups.set(typeKey, []);\n        }\n        typeGroups.get(typeKey)!.push(change);\n      }\n\n      // Create final groups\n      for (const [typeKey, typeChanges] of typeGroups.entries()) {\n        if (typeChanges.length >= this.config.minChangesForGroup) {\n          const maxChanges = this.getMaxChangesForOperation(operationType);\n          if (typeChanges.length <= maxChanges) {\n            groups.push(this.createGroupMetadata(\n              typeChanges, \n              operationType, \n              'mixed', \n              operationDescription\n            ));\n          } else {\n            // Subdivide large groups\n            const subGroups = this.subdivideGroup(typeChanges, maxChanges);\n            for (const subGroup of subGroups) {\n              groups.push(this.createGroupMetadata(\n                subGroup, \n                operationType, \n                'mixed', \n                operationDescription\n              ));\n            }\n          }\n        } else {\n          ungroupedChanges.push(...typeChanges.map(c => c.id!));\n        }\n      }\n    }\n  }\n\n  /**\n   * Create hierarchical grouping structure for large operations\n   */\n  private createHierarchicalGroups(groups: ChangeGroupMetadata[]): void {\n    if (groups.length <= 3) return; // Not worth hierarchical grouping\n\n    // Create parent groups for related operations\n    const parentGroups = new Map<string, ChangeGroupMetadata[]>();\n    \n    for (const group of groups) {\n      const parentKey = this.determineParentGroupKey(group);\n      if (!parentGroups.has(parentKey)) {\n        parentGroups.set(parentKey, []);\n      }\n      parentGroups.get(parentKey)!.push(group);\n    }\n\n    // Create parent group metadata for groups with multiple children\n    for (const [parentKey, childGroups] of parentGroups.entries()) {\n      if (childGroups.length > 1) {\n        const parentGroupId = this.generateGroupId();\n        const parentGroup: ChangeGroupMetadata = {\n          groupId: parentGroupId,\n          operationType: childGroups[0].operationType,\n          operationDescription: `${parentKey} (${childGroups.length} sections)`,\n          groupingStrategy: 'mixed',\n          createdAt: new Date(),\n          changeCount: childGroups.reduce((sum, g) => sum + g.changeCount, 0),\n          scope: 'document',\n          positionRange: {\n            start: Math.min(...childGroups.map(g => g.positionRange.start)),\n            end: Math.max(...childGroups.map(g => g.positionRange.end))\n          },\n          priority: this.determineGroupPriority(childGroups[0].operationType),\n          status: 'pending',\n          childGroupIds: childGroups.map(g => g.groupId)\n        };\n\n        // Update child groups to reference parent\n        for (const childGroup of childGroups) {\n          childGroup.parentGroupId = parentGroupId;\n        }\n\n        // Insert parent group at beginning\n        groups.unshift(parentGroup);\n      }\n    }\n  }\n\n  /**\n   * Helper methods for grouping logic\n   */\n  private determineGroupingStrategy(operationType: EditorialOperationType): ChangeGroupingStrategy {\n    const rule = this.config.operationGroupingRules[operationType];\n    return rule?.strategy || this.config.defaultStrategy;\n  }\n\n  private getMaxChangesForOperation(operationType: EditorialOperationType): number {\n    const rule = this.config.operationGroupingRules[operationType];\n    return rule?.maxChangesPerGroup || this.config.maxChangesPerGroup;\n  }\n\n  private determineSemanticKey(change: EditChange, operationType: EditorialOperationType): string {\n    // Simplified semantic analysis based on change content and type\n    if (operationType === 'proofreading') {\n      if (change.text && /[.!?]$/.test(change.text.trim())) return 'sentence-ending';\n      if (change.type === 'replace' && change.removedText && change.text) {\n        if (/^[A-Z]/.test(change.text) && /^[a-z]/.test(change.removedText)) return 'capitalization';\n        if (change.text.length < change.removedText.length) return 'spelling-correction';\n      }\n      return 'grammar-fix';\n    }\n    \n    if (operationType === 'style-refinement') {\n      if (change.type === 'replace') return 'word-choice';\n      if (change.type === 'insert') return 'clarification';\n      return 'style-improvement';\n    }\n\n    return change.type;\n  }\n\n  private getOperationTypeDescription(changeType: string): string {\n    switch (changeType) {\n      case 'insert': return 'Addition';\n      case 'delete': return 'Removal';\n      case 'replace': return 'Replacement';\n      default: return 'Edit';\n    }\n  }\n\n  private determineParentGroupKey(group: ChangeGroupMetadata): string {\n    const scopePrefix = group.scope === 'document' ? 'Document-wide' : 'Section';\n    return `${scopePrefix} ${group.operationType}`;\n  }\n\n  private determineGroupPriority(operationType: EditorialOperationType): 'high' | 'medium' | 'low' {\n    const rule = this.config.operationGroupingRules[operationType];\n    if (rule?.priority) return rule.priority;\n    \n    // Default priorities based on operation importance\n    switch (operationType) {\n      case 'developmental-feedback':\n      case 'copy-edit-pass':\n        return 'high';\n      case 'proofreading':\n      case 'style-refinement':\n        return 'medium';\n      default:\n        return 'low';\n    }\n  }\n\n  private subdivideGroup(changes: EditChange[], maxSize: number): EditChange[][] {\n    if (changes.length <= maxSize) return [changes];\n    \n    const groups: EditChange[][] = [];\n    for (let i = 0; i < changes.length; i += maxSize) {\n      groups.push(changes.slice(i, i + maxSize));\n    }\n    return groups;\n  }\n\n  private createGroupMetadata(\n    changes: EditChange[],\n    operationType: EditorialOperationType,\n    strategy: ChangeGroupingStrategy,\n    operationDescription?: string,\n    specificDescription?: string\n  ): ChangeGroupMetadata {\n    const positions = changes.map(c => ({ start: c.from, end: c.to }));\n    const minPos = Math.min(...positions.map(p => p.start));\n    const maxPos = Math.max(...positions.map(p => p.end));\n    \n    // Determine scope based on position spread\n    let scope: 'paragraph' | 'section' | 'document' | 'selection' = 'selection';\n    const positionSpread = maxPos - minPos;\n    if (positionSpread > 5000) scope = 'document';\n    else if (positionSpread > 1000) scope = 'section';\n    else if (positionSpread > 200) scope = 'paragraph';\n\n    return {\n      groupId: this.generateGroupId(),\n      operationType,\n      operationDescription: specificDescription || operationDescription || this.getDefaultOperationDescription(operationType),\n      groupingStrategy: strategy,\n      createdAt: new Date(),\n      changeCount: changes.length,\n      scope,\n      positionRange: { start: minPos, end: maxPos },\n      priority: this.determineGroupPriority(operationType),\n      status: 'pending'\n    };\n  }\n\n  private getDefaultOperationDescription(operationType: EditorialOperationType): string {\n    switch (operationType) {\n      case 'copy-edit-pass': return 'Comprehensive copy editing pass';\n      case 'proofreading': return 'Grammar and spelling corrections';\n      case 'developmental-feedback': return 'Structural and content improvements';\n      case 'style-refinement': return 'Voice and tone refinements';\n      case 'fact-checking': return 'Accuracy and verification changes';\n      case 'formatting': return 'Document formatting updates';\n      case 'content-expansion': return 'Content additions and elaborations';\n      case 'content-reduction': return 'Content trimming and condensing';\n      case 'rewriting': return 'Content restructuring and rewriting';\n      default: return 'Editorial changes';\n    }\n  }\n\n  private generateGroupId(): string {\n    return `group_${Date.now()}_${++this.groupIdCounter}`;\n  }\n\n  private createEmptyGroupingResult(changes: EditChange[]): ChangeGroupingResult {\n    return {\n      groups: [],\n      ungroupedChanges: changes.map(c => c.id!),\n      warnings: [],\n      statistics: {\n        totalChanges: changes.length,\n        groupedChanges: 0,\n        ungroupedChanges: changes.length,\n        groupsCreated: 0,\n        averageGroupSize: 0\n      }\n    };\n  }\n\n  private createGroupingResult(\n    changes: EditChange[],\n    groups: ChangeGroupMetadata[],\n    ungroupedChanges: string[],\n    warnings: string[]\n  ): ChangeGroupingResult {\n    const groupedChanges = groups.reduce((sum, g) => sum + g.changeCount, 0);\n    \n    return {\n      groups,\n      ungroupedChanges,\n      warnings,\n      statistics: {\n        totalChanges: changes.length,\n        groupedChanges,\n        ungroupedChanges: ungroupedChanges.length,\n        groupsCreated: groups.length,\n        averageGroupSize: groups.length > 0 ? groupedChanges / groups.length : 0\n      }\n    };\n  }\n\n  /**\n   * Update configuration\n   */\n  public updateConfig(newConfig: Partial<ChangeGroupingConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  /**\n   * Get current configuration\n   */\n  public getConfig(): ChangeGroupingConfig {\n    return { ...this.config };\n  }\n}\n\n/**\n * Default configuration for different editorial workflows\n */\nexport const DEFAULT_GROUPING_CONFIGS = {\n  PROOFREADING: {\n    defaultStrategy: 'proximity' as ChangeGroupingStrategy,\n    maxChangesPerGroup: 50,\n    proximityThreshold: 150,\n    minChangesForGroup: 3\n  },\n  \n  COPY_EDITING: {\n    defaultStrategy: 'mixed' as ChangeGroupingStrategy,\n    maxChangesPerGroup: 30,\n    proximityThreshold: 200,\n    minChangesForGroup: 2,\n    enableHierarchicalGrouping: true\n  },\n  \n  DEVELOPMENTAL: {\n    defaultStrategy: 'semantic' as ChangeGroupingStrategy,\n    maxChangesPerGroup: 15,\n    proximityThreshold: 500,\n    minChangesForGroup: 2,\n    enableHierarchicalGrouping: true\n  }\n};", "/**\n * Change Batch Management System\n * Task 2.4: Platform Integration - Batch management and writer-centric controls\n * \n * Provides comprehensive batch management for Editorial Engine submissions,\n * including batch status tracking, hierarchical control, and writer-centric operations.\n */\n\nimport { \n  ChangeGroupMetadata, \n  ChangeGroupingResult,\n  EditorialOperationType \n} from './types/submit-changes-from-ai';\nimport { ChangeGroupingSystem } from './change-grouping-system';\n\n/**\n * Batch operation result for writer interactions\n */\nexport interface BatchOperationResult {\n  success: boolean;\n  affectedGroups: string[];\n  affectedChanges: string[];\n  errors: string[];\n  warnings: string[];\n}\n\n/**\n * Batch status update information\n */\nexport interface BatchStatusUpdate {\n  groupId: string;\n  newStatus: 'pending' | 'accepted' | 'rejected' | 'mixed';\n  writerNotes?: string;\n  timestamp: Date;\n  changeIds?: string[]; // Specific changes if partial acceptance\n}\n\n/**\n * Batch query options for filtering and sorting\n */\nexport interface BatchQueryOptions {\n  operationType?: EditorialOperationType;\n  status?: 'pending' | 'accepted' | 'rejected' | 'mixed';\n  priority?: 'high' | 'medium' | 'low';\n  scope?: 'paragraph' | 'section' | 'document' | 'selection';\n  sessionId?: string;\n  dateRange?: {\n    start: Date;\n    end: Date;\n  };\n  sortBy?: 'created' | 'priority' | 'position' | 'changeCount';\n  sortOrder?: 'asc' | 'desc';\n}\n\n/**\n * Change batch manager that handles all batch-related operations\n */\nexport class ChangeBatchManager {\n  private groupingSystem: ChangeGroupingSystem;\n  private batchMetadata = new Map<string, ChangeGroupMetadata>();\n  private sessionBatches = new Map<string, string[]>(); // sessionId -> groupIds\n  private changeToGroup = new Map<string, string>(); // changeId -> groupId\n  private batchStatusHistory = new Map<string, BatchStatusUpdate[]>();\n\n  constructor(groupingSystem?: ChangeGroupingSystem) {\n    this.groupingSystem = groupingSystem || new ChangeGroupingSystem();\n  }\n\n  /**\n   * Create batches from a set of changes with automatic grouping\n   */\n  public createBatches(\n    changes: any[], // Using any since we don't have proper EditChange import\n    sessionId: string,\n    operationType: EditorialOperationType,\n    operationDescription?: string\n  ): ChangeGroupingResult {\n    const groupingResult = this.groupingSystem.groupChanges(\n      changes,\n      operationType,\n      operationDescription\n    );\n\n    // Store batch metadata\n    for (const group of groupingResult.groups) {\n      this.batchMetadata.set(group.groupId, group);\n      \n      // Associate with session\n      if (!this.sessionBatches.has(sessionId)) {\n        this.sessionBatches.set(sessionId, []);\n      }\n      this.sessionBatches.get(sessionId)!.push(group.groupId);\n\n      // Map changes to groups\n      const groupChanges = this.getChangesForGroup(changes, group);\n      for (const change of groupChanges) {\n        if (change.id) {\n          this.changeToGroup.set(change.id, group.groupId);\n        }\n      }\n\n      // Initialize status history\n      this.batchStatusHistory.set(group.groupId, [{\n        groupId: group.groupId,\n        newStatus: 'pending',\n        timestamp: new Date()\n      }]);\n    }\n\n    return groupingResult;\n  }\n\n  /**\n   * Accept an entire batch of changes\n   */\n  public acceptBatch(\n    groupId: string,\n    writerNotes?: string\n  ): BatchOperationResult {\n    const batch = this.batchMetadata.get(groupId);\n    if (!batch) {\n      return {\n        success: false,\n        affectedGroups: [],\n        affectedChanges: [],\n        errors: [`Batch ${groupId} not found`],\n        warnings: []\n      };\n    }\n\n    const statusUpdate: BatchStatusUpdate = {\n      groupId,\n      newStatus: 'accepted',\n      writerNotes,\n      timestamp: new Date()\n    };\n\n    this.updateBatchStatus(groupId, statusUpdate);\n\n    // Also accept any child groups\n    const childGroups: string[] = [];\n    if (batch.childGroupIds) {\n      for (const childId of batch.childGroupIds) {\n        const childResult = this.acceptBatch(childId, `Accepted with parent batch`);\n        childGroups.push(...childResult.affectedGroups);\n      }\n    }\n\n    const affectedChanges = this.getChangeIdsForGroup(groupId);\n\n    return {\n      success: true,\n      affectedGroups: [groupId, ...childGroups],\n      affectedChanges,\n      errors: [],\n      warnings: []\n    };\n  }\n\n  /**\n   * Reject an entire batch of changes\n   */\n  public rejectBatch(\n    groupId: string,\n    writerNotes?: string\n  ): BatchOperationResult {\n    const batch = this.batchMetadata.get(groupId);\n    if (!batch) {\n      return {\n        success: false,\n        affectedGroups: [],\n        affectedChanges: [],\n        errors: [`Batch ${groupId} not found`],\n        warnings: []\n      };\n    }\n\n    const statusUpdate: BatchStatusUpdate = {\n      groupId,\n      newStatus: 'rejected',\n      writerNotes,\n      timestamp: new Date()\n    };\n\n    this.updateBatchStatus(groupId, statusUpdate);\n\n    // Also reject any child groups\n    const childGroups: string[] = [];\n    if (batch.childGroupIds) {\n      for (const childId of batch.childGroupIds) {\n        const childResult = this.rejectBatch(childId, `Rejected with parent batch`);\n        childGroups.push(...childResult.affectedGroups);\n      }\n    }\n\n    const affectedChanges = this.getChangeIdsForGroup(groupId);\n\n    return {\n      success: true,\n      affectedGroups: [groupId, ...childGroups],\n      affectedChanges,\n      errors: [],\n      warnings: []\n    };\n  }\n\n  /**\n   * Partially accept/reject specific changes within a batch\n   */\n  public partiallyProcessBatch(\n    groupId: string,\n    acceptedChangeIds: string[],\n    rejectedChangeIds: string[],\n    writerNotes?: string\n  ): BatchOperationResult {\n    const batch = this.batchMetadata.get(groupId);\n    if (!batch) {\n      return {\n        success: false,\n        affectedGroups: [],\n        affectedChanges: [],\n        errors: [`Batch ${groupId} not found`],\n        warnings: []\n      };\n    }\n\n    const allChangeIds = this.getChangeIdsForGroup(groupId);\n    const processedIds = [...acceptedChangeIds, ...rejectedChangeIds];\n    const unprocessedIds = allChangeIds.filter(id => !processedIds.includes(id));\n\n    let newStatus: 'pending' | 'accepted' | 'rejected' | 'mixed';\n    if (acceptedChangeIds.length === allChangeIds.length) {\n      newStatus = 'accepted';\n    } else if (rejectedChangeIds.length === allChangeIds.length) {\n      newStatus = 'rejected';\n    } else if (processedIds.length === allChangeIds.length) {\n      newStatus = 'mixed';\n    } else {\n      newStatus = 'mixed'; // Some changes still pending\n    }\n\n    const statusUpdate: BatchStatusUpdate = {\n      groupId,\n      newStatus,\n      writerNotes,\n      timestamp: new Date(),\n      changeIds: processedIds\n    };\n\n    this.updateBatchStatus(groupId, statusUpdate);\n\n    return {\n      success: true,\n      affectedGroups: [groupId],\n      affectedChanges: processedIds,\n      errors: [],\n      warnings: unprocessedIds.length > 0 ? \n        [`${unprocessedIds.length} changes in batch remain unprocessed`] : []\n    };\n  }\n\n  /**\n   * Query batches with filtering and sorting\n   */\n  public queryBatches(\n    sessionId?: string,\n    options: BatchQueryOptions = {}\n  ): ChangeGroupMetadata[] {\n    let batches: ChangeGroupMetadata[];\n\n    if (sessionId) {\n      const sessionGroupIds = this.sessionBatches.get(sessionId) || [];\n      batches = sessionGroupIds\n        .map(id => this.batchMetadata.get(id))\n        .filter((batch): batch is ChangeGroupMetadata => batch !== undefined);\n    } else {\n      batches = Array.from(this.batchMetadata.values());\n    }\n\n    // Apply filters\n    if (options.operationType) {\n      batches = batches.filter(b => b.operationType === options.operationType);\n    }\n    if (options.status) {\n      batches = batches.filter(b => b.status === options.status);\n    }\n    if (options.priority) {\n      batches = batches.filter(b => b.priority === options.priority);\n    }\n    if (options.scope) {\n      batches = batches.filter(b => b.scope === options.scope);\n    }\n    if (options.dateRange) {\n      batches = batches.filter(b => \n        b.createdAt >= options.dateRange!.start && \n        b.createdAt <= options.dateRange!.end\n      );\n    }\n\n    // Apply sorting\n    const sortBy = options.sortBy || 'created';\n    const sortOrder = options.sortOrder || 'desc';\n\n    batches.sort((a, b) => {\n      let comparison = 0;\n      \n      switch (sortBy) {\n        case 'created':\n          comparison = a.createdAt.getTime() - b.createdAt.getTime();\n          break;\n        case 'priority':\n          const priorityOrder = { high: 3, medium: 2, low: 1 };\n          comparison = priorityOrder[a.priority] - priorityOrder[b.priority];\n          break;\n        case 'position':\n          comparison = a.positionRange.start - b.positionRange.start;\n          break;\n        case 'changeCount':\n          comparison = a.changeCount - b.changeCount;\n          break;\n      }\n\n      return sortOrder === 'asc' ? comparison : -comparison;\n    });\n\n    return batches;\n  }\n\n  /**\n   * Get batch metadata by ID\n   */\n  public getBatch(groupId: string): ChangeGroupMetadata | undefined {\n    return this.batchMetadata.get(groupId);\n  }\n\n  /**\n   * Get batch status history\n   */\n  public getBatchStatusHistory(groupId: string): BatchStatusUpdate[] {\n    return this.batchStatusHistory.get(groupId) || [];\n  }\n\n  /**\n   * Get all batches for a session\n   */\n  public getSessionBatches(sessionId: string): ChangeGroupMetadata[] {\n    const groupIds = this.sessionBatches.get(sessionId) || [];\n    return groupIds\n      .map(id => this.batchMetadata.get(id))\n      .filter((batch): batch is ChangeGroupMetadata => batch !== undefined);\n  }\n\n  /**\n   * Get batch statistics for a session\n   */\n  public getSessionBatchStatistics(sessionId: string): {\n    totalBatches: number;\n    pendingBatches: number;\n    acceptedBatches: number;\n    rejectedBatches: number;\n    mixedBatches: number;\n    totalChanges: number;\n    averageBatchSize: number;\n  } {\n    const batches = this.getSessionBatches(sessionId);\n    \n    const stats = {\n      totalBatches: batches.length,\n      pendingBatches: 0,\n      acceptedBatches: 0,\n      rejectedBatches: 0,\n      mixedBatches: 0,\n      totalChanges: 0,\n      averageBatchSize: 0\n    };\n\n    for (const batch of batches) {\n      stats.totalChanges += batch.changeCount;\n      \n      switch (batch.status) {\n        case 'pending':\n          stats.pendingBatches++;\n          break;\n        case 'accepted':\n          stats.acceptedBatches++;\n          break;\n        case 'rejected':\n          stats.rejectedBatches++;\n          break;\n        case 'mixed':\n          stats.mixedBatches++;\n          break;\n      }\n    }\n\n    stats.averageBatchSize = stats.totalBatches > 0 ? stats.totalChanges / stats.totalBatches : 0;\n\n    return stats;\n  }\n\n  /**\n   * Update batch metadata\n   */\n  public updateBatchMetadata(\n    groupId: string,\n    updates: Partial<ChangeGroupMetadata>\n  ): boolean {\n    const batch = this.batchMetadata.get(groupId);\n    if (!batch) return false;\n\n    Object.assign(batch, updates);\n    this.batchMetadata.set(groupId, batch);\n    return true;\n  }\n\n  /**\n   * Delete a batch (and its history)\n   */\n  public deleteBatch(groupId: string): boolean {\n    const batch = this.batchMetadata.get(groupId);\n    if (!batch) return false;\n\n    // Remove from session tracking\n    for (const [sessionId, groupIds] of this.sessionBatches.entries()) {\n      const index = groupIds.indexOf(groupId);\n      if (index >= 0) {\n        groupIds.splice(index, 1);\n        if (groupIds.length === 0) {\n          this.sessionBatches.delete(sessionId);\n        }\n        break;\n      }\n    }\n\n    // Remove change mappings\n    for (const [changeId, mappedGroupId] of this.changeToGroup.entries()) {\n      if (mappedGroupId === groupId) {\n        this.changeToGroup.delete(changeId);\n      }\n    }\n\n    // Remove metadata and history\n    this.batchMetadata.delete(groupId);\n    this.batchStatusHistory.delete(groupId);\n\n    // Handle child groups\n    if (batch.childGroupIds) {\n      for (const childId of batch.childGroupIds) {\n        this.deleteBatch(childId);\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Get group ID for a specific change\n   */\n  public getGroupForChange(changeId: string): string | undefined {\n    return this.changeToGroup.get(changeId);\n  }\n\n  /**\n   * Clear all batch data for a session\n   */\n  public clearSessionBatches(sessionId: string): void {\n    const groupIds = this.sessionBatches.get(sessionId) || [];\n    for (const groupId of groupIds) {\n      this.deleteBatch(groupId);\n    }\n    this.sessionBatches.delete(sessionId);\n  }\n\n  /**\n   * Export batch data for persistence\n   */\n  public exportBatchData(): {\n    metadata: [string, ChangeGroupMetadata][];\n    sessionBatches: [string, string[]][];\n    changeToGroup: [string, string][];\n    statusHistory: [string, BatchStatusUpdate[]][];\n  } {\n    return {\n      metadata: Array.from(this.batchMetadata.entries()),\n      sessionBatches: Array.from(this.sessionBatches.entries()),\n      changeToGroup: Array.from(this.changeToGroup.entries()),\n      statusHistory: Array.from(this.batchStatusHistory.entries())\n    };\n  }\n\n  /**\n   * Import batch data from persistence\n   */\n  public importBatchData(data: {\n    metadata: [string, ChangeGroupMetadata][];\n    sessionBatches: [string, string[]][];\n    changeToGroup: [string, string][];\n    statusHistory: [string, BatchStatusUpdate[]][];\n  }): void {\n    this.batchMetadata = new Map(data.metadata);\n    this.sessionBatches = new Map(data.sessionBatches);\n    this.changeToGroup = new Map(data.changeToGroup);\n    this.batchStatusHistory = new Map(data.statusHistory);\n  }\n\n  /**\n   * Private helper methods\n   */\n  private updateBatchStatus(groupId: string, statusUpdate: BatchStatusUpdate): void {\n    const batch = this.batchMetadata.get(groupId);\n    if (batch) {\n      batch.status = statusUpdate.newStatus;\n      if (statusUpdate.writerNotes) {\n        batch.writerNotes = statusUpdate.writerNotes;\n      }\n    }\n\n    const history = this.batchStatusHistory.get(groupId) || [];\n    history.push(statusUpdate);\n    this.batchStatusHistory.set(groupId, history);\n  }\n\n  private getChangesForGroup(changes: any[], group: ChangeGroupMetadata): any[] {\n    // Simple implementation - in a real system this would use proper change tracking\n    return changes.filter(change => \n      change.from >= group.positionRange.start && \n      change.to <= group.positionRange.end\n    );\n  }\n\n  private getChangeIdsForGroup(groupId: string): string[] {\n    const changeIds: string[] = [];\n    for (const [changeId, mappedGroupId] of this.changeToGroup.entries()) {\n      if (mappedGroupId === groupId) {\n        changeIds.push(changeId);\n      }\n    }\n    return changeIds;\n  }\n}\n\n/**\n * Convenience factory for creating batch managers with preset configurations\n */\nexport class BatchManagerFactory {\n  static createForEditorialWorkflow(\n    operationType: EditorialOperationType\n  ): ChangeBatchManager {\n    let groupingSystem: ChangeGroupingSystem;\n\n    switch (operationType) {\n      case 'proofreading':\n        groupingSystem = new ChangeGroupingSystem({\n          defaultStrategy: 'proximity',\n          maxChangesPerGroup: 50,\n          proximityThreshold: 150,\n          minChangesForGroup: 3\n        });\n        break;\n      \n      case 'copy-edit-pass':\n        groupingSystem = new ChangeGroupingSystem({\n          defaultStrategy: 'mixed',\n          maxChangesPerGroup: 30,\n          proximityThreshold: 200,\n          minChangesForGroup: 2,\n          enableHierarchicalGrouping: true\n        });\n        break;\n      \n      case 'developmental-feedback':\n        groupingSystem = new ChangeGroupingSystem({\n          defaultStrategy: 'semantic',\n          maxChangesPerGroup: 15,\n          proximityThreshold: 500,\n          minChangesForGroup: 2,\n          enableHierarchicalGrouping: true\n        });\n        break;\n      \n      default:\n        groupingSystem = new ChangeGroupingSystem();\n    }\n\n    return new ChangeBatchManager(groupingSystem);\n  }\n}", "// Types for submitChangesFromAI() Editorial Engine integration API\n// Task 2.2: Platform Integration - TrackEdits Plugin API\n\nimport { EditChange, AIProcessingContext } from '../../../../shared/types';\n\n/**\n * Result object returned by submitChangesFromAI() method\n * Provides detailed feedback on the submission process\n */\nexport interface SubmitChangesFromAIResult {\n  /** Whether the submission was successful */\n  success: boolean;\n  \n  /** Session ID where changes were recorded (may be created during submission) */\n  sessionId?: string;\n  \n  /** Array of IDs for all successfully recorded changes */\n  changeIds: string[];\n  \n  /** Array of error messages if submission failed */\n  errors: string[];\n  \n  /** Array of warning messages (non-fatal issues) */\n  warnings: string[];\n  \n  /** Unique group ID if changes were grouped together */\n  changeGroupId?: string;\n  \n  /** Detailed grouping result with metadata */\n  groupingResult?: ChangeGroupingResult;\n  \n  /** Summary of validation performed during submission */\n  validationSummary?: {\n    totalChanges: number;\n    provider: string;\n    model: string;\n    validationMode: 'Editorial Engine' | 'Standard';\n    securityChecksEnabled: boolean;\n  };\n}\n\n/**\n * Options for submitChangesFromAI() method calls\n * Controls session management, validation, and processing behavior\n */\nexport interface SubmitChangesFromAIOptions {\n  /** Existing session ID to use for recording changes */\n  sessionId?: string;\n  \n  /** Whether to create a new session if none exists */\n  createSession?: boolean;\n  \n  /** Enable strict validation of AI metadata (default: true) */\n  strictValidation?: boolean;\n  \n  /** Bypass all validation checks (use with caution) */\n  bypassValidation?: boolean;\n  \n  /** Enable Editorial Engine-specific validation and features */\n  editorialEngineMode?: boolean;\n  \n  /** Group related changes with a common ID for batch analysis */\n  groupChanges?: boolean;\n  \n  /** Advanced grouping configuration */\n  groupingConfig?: Partial<ChangeGroupingConfig>;\n  \n  /** Editorial operation type for semantic grouping */\n  editorialOperation?: EditorialOperationType;\n  \n  /** Custom operation description (used when editorialOperation is 'custom') */\n  customOperationDescription?: string;\n  \n  /** Conversation context for chat integration */\n  conversationContext?: {\n    conversationId: string;\n    messageId?: string;\n    userPrompt?: string;\n  };\n  \n  // Multi-plugin change consolidation options\n  \n  /** Operation priority for multi-plugin consolidation (1-5, lower = higher priority) */\n  priority?: 1 | 2 | 3 | 4 | 5;\n  \n  /** Whether this is an automated operation (affects priority and user review requirements) */\n  automated?: boolean;\n  \n  /** Force processing even if conflicts are detected */\n  forceProcessing?: boolean;\n  \n  /** Maximum time to wait for consolidation (ms) */\n  consolidationTimeout?: number;\n  \n  /** Enable real-time consolidation with other plugins */\n  enableConsolidation?: boolean;\n  \n  /** Plugins that this operation can be merged with */\n  compatiblePlugins?: string[];\n  \n  /** Conflict resolution preferences */\n  conflictResolution?: {\n    /** Preferred resolution strategy */\n    strategy?: 'auto_merge' | 'priority_wins' | 'user_choice' | 'sequential';\n    \n    /** Allow semantic merging of changes */\n    allowSemanticMerge?: boolean;\n    \n    /** Maximum overlap tolerance for merging (characters) */\n    overlapTolerance?: number;\n    \n    /** Automatically defer to higher priority operations */\n    autoDefer?: boolean;\n  };\n  \n  /** Semantic context for intelligent conflict resolution */\n  semanticContext?: {\n    /** Primary intention of this operation */\n    intention?: 'correction' | 'enhancement' | 'formatting' | 'content_addition' | 'restructuring';\n    \n    /** Scope of changes */\n    scope?: 'word' | 'sentence' | 'paragraph' | 'section' | 'document';\n    \n    /** Confidence in the semantic analysis (0-1) */\n    confidence?: number;\n    \n    /** Whether formatting should be preserved */\n    preserveFormatting?: boolean;\n    \n    /** Whether content should be preserved */\n    preserveContent?: boolean;\n  };\n  \n  /** Maximum number of retry attempts for failed consolidation */\n  maxRetries?: number;\n}\n\n/**\n * Enhanced AI Processing Context with conversation support\n * Extends base AIProcessingContext with additional metadata\n */\nexport interface EnhancedAIProcessingContext extends AIProcessingContext {\n  /** Unique identifier linking changes to a conversation */\n  conversationId?: string;\n  \n  /** Specific message ID within the conversation */\n  messageId?: string;\n  \n  /** Original user prompt that generated these changes */\n  userPrompt?: string;\n  \n  /** Group ID for batch-related changes */\n  changeGroupId?: string;\n  \n  /** Additional metadata for processing context */\n  metadata?: Record<string, any>;\n  \n  /** Processing settings used to generate changes */\n  settings?: Record<string, any>;\n}\n\n/**\n * Editorial operation types that determine change grouping behavior\n */\nexport type EditorialOperationType = \n  | 'copy-edit-pass'           // Comprehensive copy editing\n  | 'proofreading'             // Grammar, spelling, punctuation fixes\n  | 'developmental-feedback'   // Structural and content suggestions\n  | 'style-refinement'         // Voice, tone, and style improvements\n  | 'fact-checking'            // Accuracy and verification changes\n  | 'formatting'               // Document structure and presentation\n  | 'content-expansion'        // Adding details, examples, clarification\n  | 'content-reduction'        // Trimming, condensing, removing redundancy\n  | 'rewriting'                // Major content restructuring\n  | 'custom'                   // User-defined operation type;\n\n/**\n * Change grouping strategy for batching similar edits\n */\nexport type ChangeGroupingStrategy = \n  | 'proximity'         // Group changes in same paragraph/section\n  | 'operation-type'    // Group by editing operation (grammar, style, etc.)\n  | 'semantic'          // Group semantically related changes\n  | 'time-window'       // Group changes within time period\n  | 'mixed'             // Combination of strategies\n  | 'none';             // No grouping\n\n/**\n * Metadata for change groups/batches\n */\nexport interface ChangeGroupMetadata {\n  /** Unique identifier for this change group */\n  groupId: string;\n  \n  /** Editorial operation that generated this group */\n  operationType: EditorialOperationType;\n  \n  /** Human-readable description of the operation */\n  operationDescription: string;\n  \n  /** Grouping strategy used to create this batch */\n  groupingStrategy: ChangeGroupingStrategy;\n  \n  /** Timestamp when group was created */\n  createdAt: Date;\n  \n  /** Total number of changes in this group */\n  changeCount: number;\n  \n  /** Document scope of changes (paragraph, section, document) */\n  scope: 'paragraph' | 'section' | 'document' | 'selection';\n  \n  /** Position range this group affects */\n  positionRange: {\n    start: number;\n    end: number;\n  };\n  \n  /** Priority level for review (high priority shown first) */\n  priority: 'high' | 'medium' | 'low';\n  \n  /** Status of the entire group */\n  status: 'pending' | 'accepted' | 'rejected' | 'mixed';\n  \n  /** Writer notes about this group */\n  writerNotes?: string;\n  \n  /** AI confidence level for this group of changes */\n  confidenceLevel?: number;\n  \n  /** Related groups (for hierarchical grouping) */\n  parentGroupId?: string;\n  childGroupIds?: string[];\n}\n\n/**\n * Configuration for automatic change grouping\n */\n// Plugin Registration System Types\nexport interface AIProcessingPlugin {\n  readonly id: string;\n  readonly name: string;\n  readonly version: string;\n  readonly author: string;\n  readonly description: string;\n  readonly capabilities: PluginCapabilities;\n  readonly metadata: PluginMetadata;\n  readonly apiVersion: string;\n}\n\nexport interface PluginCapabilities {\n  readonly editorialOperations: EditorialOperationType[];\n  readonly aiProviders: string[];\n  readonly maxBatchSize: number;\n  readonly supportsRealTime: boolean;\n  readonly supportsConversationContext: boolean;\n  readonly supportedFileTypes: string[];\n  readonly requiredPermissions: PluginPermission[];\n}\n\nexport interface PluginMetadata {\n  readonly homepage?: string;\n  readonly repository?: string;\n  readonly documentation?: string;\n  readonly license?: string;\n  readonly keywords: string[];\n  readonly minObsidianVersion?: string;\n  readonly securityPolicy?: string;\n}\n\nexport enum PluginPermission {\n  READ_DOCUMENTS = 'read_documents',\n  MODIFY_DOCUMENTS = 'modify_documents',\n  CREATE_SESSIONS = 'create_sessions',\n  ACCESS_VAULT_METADATA = 'access_vault_metadata',\n  NETWORK_ACCESS = 'network_access',\n  STORAGE_ACCESS = 'storage_access',\n  USER_INTERFACE = 'user_interface'\n}\n\nexport interface PluginRegistration {\n  readonly plugin: AIProcessingPlugin;\n  readonly registrationTime: Date;\n  readonly status: PluginRegistrationStatus;\n  readonly securityHash: string;\n  readonly validatedCapabilities: PluginCapabilities;\n  readonly lastActivity?: Date;\n  readonly performanceMetrics?: PluginPerformanceMetrics;\n}\n\nexport enum PluginRegistrationStatus {\n  PENDING = 'pending',\n  ACTIVE = 'active',\n  SUSPENDED = 'suspended',\n  DEACTIVATED = 'deactivated',\n  SECURITY_VIOLATION = 'security_violation',\n  VERSION_INCOMPATIBLE = 'version_incompatible'\n}\n\nexport interface PluginPerformanceMetrics {\n  readonly totalSubmissions: number;\n  readonly successRate: number;\n  readonly averageResponseTime: number;\n  readonly errorRate: number;\n  readonly lastErrorTime?: Date;\n  readonly rateLimitViolations: number;\n}\n\nexport interface PluginAuthenticationContext {\n  readonly pluginId: string;\n  readonly sessionToken: string;\n  readonly permissions: PluginPermission[];\n  readonly issuedAt: Date;\n  readonly expiresAt: Date;\n  readonly requestSignature?: string;\n}\n\nexport interface PluginValidationResult {\n  readonly isValid: boolean;\n  readonly errors: string[];\n  readonly warnings: string[];\n  readonly securityThreats: string[];\n  readonly validatedPlugin?: AIProcessingPlugin;\n  readonly recommendedPermissions: PluginPermission[];\n}\n\nexport interface PluginSubmissionOptions extends SubmitChangesFromAIOptions {\n  readonly pluginAuthContext: PluginAuthenticationContext;\n  readonly pluginCapabilityOverrides?: Partial<PluginCapabilities>;\n  readonly pluginMetadata?: Record<string, any>;\n}\n\nexport interface ChangeGroupingConfig {\n  /** Enable automatic grouping */\n  enabled: boolean;\n  \n  /** Default grouping strategy */\n  defaultStrategy: ChangeGroupingStrategy;\n  \n  /** Maximum changes per group */\n  maxChangesPerGroup: number;\n  \n  /** Time window for time-based grouping (milliseconds) */\n  timeWindowMs: number;\n  \n  /** Proximity threshold for position-based grouping (characters) */\n  proximityThreshold: number;\n  \n  /** Minimum changes required to create a group */\n  minChangesForGroup: number;\n  \n  /** Enable hierarchical grouping (groups within groups) */\n  enableHierarchicalGrouping: boolean;\n  \n  /** Operation-specific grouping rules */\n  operationGroupingRules: Partial<Record<EditorialOperationType, {\n    strategy: ChangeGroupingStrategy;\n    maxChangesPerGroup?: number;\n    priority?: 'high' | 'medium' | 'low';\n  }>>;\n}\n\n/**\n * Result of change grouping operation\n */\nexport interface ChangeGroupingResult {\n  /** Successfully created groups */\n  groups: ChangeGroupMetadata[];\n  \n  /** Changes that couldn't be grouped */\n  ungroupedChanges: string[];\n  \n  /** Warnings during grouping process */\n  warnings: string[];\n  \n  /** Grouping statistics */\n  statistics: {\n    totalChanges: number;\n    groupedChanges: number;\n    ungroupedChanges: number;\n    groupsCreated: number;\n    averageGroupSize: number;\n  };\n}", "/**\n * Plugin Interface Standards for AI Processing Plugins\n * \n * This file defines the standardized interfaces that all AI processing plugins\n * must implement to integrate with the Track Edits plugin registry system.\n */\n\nimport { \n  AIProcessingPlugin, \n  PluginCapabilities, \n  PluginPermission, \n  PluginAuthenticationContext,\n  PluginSubmissionOptions,\n  SubmitChangesFromAIResult,\n  PluginRegistrationStatus,\n  PluginPerformanceMetrics\n} from '../types/submit-changes-from-ai';\nimport { EditChange, AIProcessingContext } from '../types';\n\n/**\n * Standard API version for plugin compatibility\n */\nexport const PLUGIN_API_VERSION = '1.0.0';\n\n/**\n * Required interface that all AI processing plugins must implement\n */\nexport interface IAIProcessingPlugin {\n  /**\n   * Plugin identification and metadata\n   */\n  getPluginInfo(): AIProcessingPlugin;\n\n  /**\n   * Initialize the plugin with the Track Edits registry\n   * @param registry - The plugin registry instance\n   * @param authContext - Authentication context for secure operations\n   */\n  initialize(registry: IPluginRegistry, authContext: PluginAuthenticationContext): Promise<void>;\n\n  /**\n   * Submit AI-generated changes to Track Edits\n   * @param changes - Array of changes to submit\n   * @param aiProvider - AI provider identifier\n   * @param aiModel - AI model identifier\n   * @param processingContext - Context for the AI processing\n   * @param options - Additional submission options\n   */\n  submitChanges(\n    changes: EditChange[],\n    aiProvider: string,\n    aiModel: string,\n    processingContext?: AIProcessingContext,\n    options?: Partial<PluginSubmissionOptions>\n  ): Promise<SubmitChangesFromAIResult>;\n\n  /**\n   * Validate plugin capabilities against requested operation\n   * @param operation - The operation type to validate\n   * @param context - Additional context for validation\n   */\n  validateCapability(operation: string, context?: any): Promise<boolean>;\n\n  /**\n   * Clean up resources and prepare for deactivation\n   */\n  cleanup(): Promise<void>;\n\n  /**\n   * Handle plugin lifecycle events\n   * @param event - The lifecycle event\n   * @param data - Event-specific data\n   */\n  onLifecycleEvent(event: PluginLifecycleEvent, data?: any): Promise<void>;\n}\n\n/**\n * Plugin lifecycle events\n */\nexport enum PluginLifecycleEvent {\n  REGISTERED = 'registered',\n  ACTIVATED = 'activated',\n  DEACTIVATED = 'deactivated',\n  SUSPENDED = 'suspended',\n  UPDATED = 'updated',\n  PERMISSION_CHANGED = 'permission_changed',\n  ERROR = 'error'\n}\n\n/**\n * Plugin registry interface for managing registered plugins\n */\nexport interface IPluginRegistry {\n  /**\n   * Register a new AI processing plugin\n   * @param plugin - The plugin to register\n   * @param securityOptions - Security validation options\n   */\n  registerPlugin(plugin: IAIProcessingPlugin, securityOptions?: PluginSecurityOptions): Promise<PluginRegistrationResult>;\n\n  /**\n   * Unregister a plugin\n   * @param pluginId - ID of the plugin to unregister\n   * @param reason - Reason for unregistration\n   */\n  unregisterPlugin(pluginId: string, reason?: string): Promise<boolean>;\n\n  /**\n   * Get a registered plugin by ID\n   * @param pluginId - The plugin ID\n   */\n  getPlugin(pluginId: string): IAIProcessingPlugin | undefined;\n\n  /**\n   * Get all registered plugins with optional filtering\n   * @param filter - Optional filter criteria\n   */\n  getPlugins(filter?: PluginFilter): IAIProcessingPlugin[];\n\n  /**\n   * Update plugin status\n   * @param pluginId - The plugin ID\n   * @param status - New status\n   * @param reason - Reason for status change\n   */\n  updatePluginStatus(pluginId: string, status: PluginRegistrationStatus, reason?: string): Promise<boolean>;\n\n  /**\n   * Authenticate a plugin for API operations\n   * @param pluginId - The plugin ID\n   * @param credentials - Authentication credentials\n   */\n  authenticatePlugin(pluginId: string, credentials: PluginCredentials): Promise<PluginAuthenticationContext | null>;\n\n  /**\n   * Validate plugin permissions for an operation\n   * @param pluginId - The plugin ID\n   * @param requiredPermissions - Required permissions\n   * @param context - Operation context\n   */\n  validatePermissions(\n    pluginId: string, \n    requiredPermissions: PluginPermission[], \n    context?: any\n  ): Promise<PermissionValidationResult>;\n\n  /**\n   * Get plugin performance metrics\n   * @param pluginId - The plugin ID\n   */\n  getPluginMetrics(pluginId: string): PluginPerformanceMetrics | undefined;\n\n  /**\n   * Handle plugin error and update metrics\n   * @param pluginId - The plugin ID\n   * @param error - The error that occurred\n   * @param context - Error context\n   */\n  recordPluginError(pluginId: string, error: Error, context?: any): Promise<void>;\n}\n\n/**\n * Plugin security validation options\n */\nexport interface PluginSecurityOptions {\n  readonly validateCodeSignature: boolean;\n  readonly allowNetworkAccess: boolean;\n  readonly allowStorageAccess: boolean;\n  readonly maxMemoryUsage: number;\n  readonly rateLimitConfig: RateLimitConfig;\n  readonly sandboxEnabled: boolean;\n}\n\n/**\n * Rate limiting configuration for plugins\n */\nexport interface RateLimitConfig {\n  readonly requestsPerMinute: number;\n  readonly requestsPerHour: number;\n  readonly burstLimit: number;\n  readonly cooldownPeriod: number;\n}\n\n/**\n * Plugin registration result\n */\nexport interface PluginRegistrationResult {\n  readonly success: boolean;\n  readonly pluginId: string;\n  readonly authToken: string;\n  readonly permissions: PluginPermission[];\n  readonly errors: string[];\n  readonly warnings: string[];\n  readonly expiresAt: Date;\n}\n\n/**\n * Plugin credentials for authentication\n */\nexport interface PluginCredentials {\n  readonly pluginId: string;\n  readonly authToken?: string;\n  readonly signature?: string;\n  readonly timestamp: Date;\n  readonly nonce: string;\n}\n\n/**\n * Permission validation result\n */\nexport interface PermissionValidationResult {\n  readonly hasPermission: boolean;\n  readonly missingPermissions: PluginPermission[];\n  readonly warnings: string[];\n  readonly contextValidation: boolean;\n}\n\n/**\n * Plugin filter for querying registered plugins\n */\nexport interface PluginFilter {\n  readonly status?: PluginRegistrationStatus[];\n  readonly capabilities?: string[];\n  readonly permissions?: PluginPermission[];\n  readonly author?: string;\n  readonly minVersion?: string;\n  readonly maxVersion?: string;\n}\n\n/**\n * Plugin capability validation interface\n */\nexport interface IPluginCapabilityValidator {\n  /**\n   * Validate that a plugin has the required capabilities for an operation\n   * @param plugin - The plugin to validate\n   * @param requiredCapabilities - Required capabilities\n   * @param context - Operation context\n   */\n  validateCapabilities(\n    plugin: AIProcessingPlugin,\n    requiredCapabilities: string[],\n    context?: any\n  ): Promise<CapabilityValidationResult>;\n\n  /**\n   * Get recommended capabilities for an operation type\n   * @param operationType - The type of operation\n   */\n  getRecommendedCapabilities(operationType: string): PluginCapabilities;\n}\n\n/**\n * Capability validation result\n */\nexport interface CapabilityValidationResult {\n  readonly isValid: boolean;\n  readonly missingCapabilities: string[];\n  readonly recommendedCapabilities: string[];\n  readonly warnings: string[];\n}\n\n/**\n * Plugin security validator interface\n */\nexport interface IPluginSecurityValidator {\n  /**\n   * Perform security validation on a plugin\n   * @param plugin - The plugin to validate\n   * @param options - Security validation options\n   */\n  validateSecurity(plugin: IAIProcessingPlugin, options: PluginSecurityOptions): Promise<SecurityValidationResult>;\n\n  /**\n   * Generate security hash for plugin verification\n   * @param plugin - The plugin to hash\n   */\n  generateSecurityHash(plugin: AIProcessingPlugin): string;\n\n  /**\n   * Verify plugin integrity\n   * @param plugin - The plugin to verify\n   * @param expectedHash - Expected security hash\n   */\n  verifyIntegrity(plugin: IAIProcessingPlugin, expectedHash: string): boolean;\n}\n\n/**\n * Security validation result\n */\nexport interface SecurityValidationResult {\n  readonly isSecure: boolean;\n  readonly securityThreats: string[];\n  readonly warnings: string[];\n  readonly recommendedRestrictions: string[];\n  readonly securityHash: string;\n}\n\n/**\n * Plugin metadata schema for standardized plugin information\n */\nexport const PLUGIN_METADATA_SCHEMA = {\n  required: ['id', 'name', 'version', 'author', 'capabilities', 'apiVersion'],\n  properties: {\n    id: { type: 'string', pattern: '^[a-z0-9][a-z0-9-]*[a-z0-9]$' },\n    name: { type: 'string', minLength: 1, maxLength: 100 },\n    version: { type: 'string', pattern: '^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$' },\n    author: { type: 'string', minLength: 1, maxLength: 100 },\n    description: { type: 'string', maxLength: 500 },\n    apiVersion: { type: 'string', enum: [PLUGIN_API_VERSION] },\n    capabilities: {\n      type: 'object',\n      required: ['editorialOperations', 'requiredPermissions'],\n      properties: {\n        editorialOperations: { type: 'array', items: { type: 'string' } },\n        aiProviders: { type: 'array', items: { type: 'string' } },\n        maxBatchSize: { type: 'number', minimum: 1, maximum: 1000 },\n        requiredPermissions: { \n          type: 'array', \n          items: { enum: Object.values(PluginPermission) } \n        }\n      }\n    }\n  }\n} as const;\n\n/**\n * Default plugin capabilities for different operation types\n */\nexport const DEFAULT_PLUGIN_CAPABILITIES: Record<string, Partial<PluginCapabilities>> = {\n  basic_editing: {\n    editorialOperations: ['replace', 'insert', 'delete'],\n    maxBatchSize: 10,\n    supportsRealTime: false,\n    requiredPermissions: [PluginPermission.MODIFY_DOCUMENTS]\n  },\n  advanced_editing: {\n    editorialOperations: ['replace', 'insert', 'delete', 'restructure', 'format'],\n    maxBatchSize: 50,\n    supportsRealTime: true,\n    supportsConversationContext: true,\n    requiredPermissions: [\n      PluginPermission.MODIFY_DOCUMENTS,\n      PluginPermission.READ_DOCUMENTS,\n      PluginPermission.CREATE_SESSIONS\n    ]\n  },\n  ai_assistant: {\n    editorialOperations: ['replace', 'insert', 'delete', 'restructure', 'format', 'analyze'],\n    maxBatchSize: 100,\n    supportsRealTime: true,\n    supportsConversationContext: true,\n    requiredPermissions: [\n      PluginPermission.MODIFY_DOCUMENTS,\n      PluginPermission.READ_DOCUMENTS,\n      PluginPermission.CREATE_SESSIONS,\n      PluginPermission.ACCESS_VAULT_METADATA,\n      PluginPermission.NETWORK_ACCESS\n    ]\n  }\n};\n\n/**\n * Plugin API contract requirements\n */\nexport const PLUGIN_API_CONTRACT = {\n  minimumMethods: ['getPluginInfo', 'initialize', 'submitChanges', 'cleanup'],\n  requiredEvents: ['registered', 'activated', 'deactivated'],\n  supportedVersions: [PLUGIN_API_VERSION],\n  securityRequirements: {\n    authentication: true,\n    permissionValidation: true,\n    rateLimiting: true,\n    integrityChecking: true\n  }\n} as const;", "/**\n * Utility functions for Track Edits plugin\n */\n\n/**\n * Generates a unique ID for tracking purposes\n */\nexport function generateId(): string {\n  return Math.random().toString(36).substr(2, 9) + Date.now().toString(36);\n}\n\n/**\n * Debounce function to limit the rate at which a function can fire\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout;\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\n/**\n * Get word count from text\n */\nexport function getWordCount(text: string): number {\n  return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n}\n\n/**\n * Get character count from text\n */\nexport function getCharacterCount(text: string): number {\n  return text.length;\n}", "/**\n * Central Plugin Registry for AI Processing Plugins\n * \n * Manages registration, authentication, validation, and lifecycle of AI processing plugins\n * that integrate with the Track Edits plugin system.\n */\n\nimport { \n  AIProcessingPlugin,\n  PluginRegistration,\n  PluginRegistrationStatus,\n  PluginPerformanceMetrics,\n  PluginPermission,\n  PluginAuthenticationContext\n} from '../types/submit-changes-from-ai';\n\nimport {\n  IAIProcessingPlugin,\n  IPluginRegistry,\n  PluginLifecycleEvent,\n  PluginSecurityOptions,\n  PluginRegistrationResult,\n  PluginCredentials,\n  PermissionValidationResult,\n  PluginFilter,\n  RateLimitConfig,\n  PLUGIN_API_VERSION\n} from './plugin-interface';\n\nimport { generateId } from '../utils';\nimport { Plugin } from 'obsidian';\n\n/**\n * Central registry for managing AI processing plugins\n */\nexport class PluginRegistry implements IPluginRegistry {\n  private plugins = new Map<string, IAIProcessingPlugin>();\n  private registrations = new Map<string, PluginRegistration>();\n  private authTokens = new Map<string, PluginAuthenticationContext>();\n  private performanceMetrics = new Map<string, PluginPerformanceMetrics>();\n  private rateLimitTrackers = new Map<string, RateLimitTracker>();\n\n  constructor(\n    private obsidianPlugin: Plugin,\n    private securityValidator: IPluginSecurityValidator,\n    private capabilityValidator: IPluginCapabilityValidator\n  ) {}\n\n  /**\n   * Register a new AI processing plugin\n   */\n  async registerPlugin(\n    plugin: IAIProcessingPlugin, \n    securityOptions: PluginSecurityOptions = this.getDefaultSecurityOptions()\n  ): Promise<PluginRegistrationResult> {\n    const result: PluginRegistrationResult = {\n      success: false,\n      pluginId: '',\n      authToken: '',\n      permissions: [],\n      errors: [],\n      warnings: [],\n      expiresAt: new Date()\n    };\n\n    try {\n      const pluginInfo = plugin.getPluginInfo();\n      result.pluginId = pluginInfo.id;\n\n      // Validate plugin API compatibility\n      if (pluginInfo.apiVersion !== PLUGIN_API_VERSION) {\n        result.errors.push(`Incompatible API version: ${pluginInfo.apiVersion}. Expected: ${PLUGIN_API_VERSION}`);\n        return result;\n      }\n\n      // Check if plugin is already registered\n      if (this.registrations.has(pluginInfo.id)) {\n        const existingRegistration = this.registrations.get(pluginInfo.id)!;\n        if (existingRegistration.status === PluginRegistrationStatus.ACTIVE) {\n          result.errors.push(`Plugin ${pluginInfo.id} is already registered and active`);\n          return result;\n        }\n      }\n\n      // Validate plugin metadata\n      const validationResult = this.validatePluginMetadata(pluginInfo);\n      if (!validationResult.isValid) {\n        result.errors.push(...validationResult.errors);\n        result.warnings.push(...validationResult.warnings);\n        return result;\n      }\n\n      // Security validation\n      const securityResult = await this.securityValidator.validateSecurity(plugin, securityOptions);\n      if (!securityResult.isSecure) {\n        result.errors.push('Plugin failed security validation');\n        result.errors.push(...securityResult.securityThreats);\n        result.warnings.push(...securityResult.warnings);\n        return result;\n      }\n\n      result.warnings.push(...securityResult.warnings);\n\n      // Generate authentication token\n      const authToken = this.generateAuthToken();\n      const expiresAt = new Date();\n      expiresAt.setDate(expiresAt.getDate() + 30); // 30 days expiration\n\n      // Determine granted permissions based on capabilities and security validation\n      const grantedPermissions = this.determineGrantedPermissions(\n        pluginInfo.capabilities.requiredPermissions,\n        securityResult.recommendedRestrictions\n      );\n\n      // Create authentication context\n      const authContext: PluginAuthenticationContext = {\n        pluginId: pluginInfo.id,\n        sessionToken: authToken,\n        permissions: grantedPermissions,\n        issuedAt: new Date(),\n        expiresAt,\n        requestSignature: this.generateRequestSignature(pluginInfo.id, authToken)\n      };\n\n      // Create plugin registration\n      const registration: PluginRegistration = {\n        plugin: pluginInfo,\n        registrationTime: new Date(),\n        status: PluginRegistrationStatus.ACTIVE,\n        securityHash: securityResult.securityHash,\n        validatedCapabilities: pluginInfo.capabilities,\n        performanceMetrics: this.createInitialPerformanceMetrics()\n      };\n\n      // Initialize rate limiting\n      const rateLimitConfig: RateLimitConfig = {\n        requestsPerMinute: securityOptions.rateLimitConfig.requestsPerMinute,\n        requestsPerHour: securityOptions.rateLimitConfig.requestsPerHour,\n        burstLimit: securityOptions.rateLimitConfig.burstLimit,\n        cooldownPeriod: securityOptions.rateLimitConfig.cooldownPeriod\n      };\n\n      // Store registration data\n      this.plugins.set(pluginInfo.id, plugin);\n      this.registrations.set(pluginInfo.id, registration);\n      this.authTokens.set(authToken, authContext);\n      this.performanceMetrics.set(pluginInfo.id, registration.performanceMetrics);\n      this.rateLimitTrackers.set(pluginInfo.id, new RateLimitTracker(rateLimitConfig));\n\n      // Initialize plugin\n      await plugin.initialize(this, authContext);\n\n      // Notify plugin of successful registration\n      await plugin.onLifecycleEvent(PluginLifecycleEvent.REGISTERED, { \n        authContext, \n        permissions: grantedPermissions \n      });\n\n      // Activate plugin\n      await plugin.onLifecycleEvent(PluginLifecycleEvent.ACTIVATED);\n      \n      // Success\n      result.success = true;\n      result.authToken = authToken;\n      result.permissions = grantedPermissions;\n      result.expiresAt = expiresAt;\n\n      console.log(`[PluginRegistry] Successfully registered plugin: ${pluginInfo.id}`, {\n        version: pluginInfo.version,\n        permissions: grantedPermissions,\n        capabilities: Object.keys(pluginInfo.capabilities)\n      });\n\n      return result;\n\n    } catch (error) {\n      const errorMessage = `Plugin registration failed: ${error instanceof Error ? error.message : String(error)}`;\n      result.errors.push(errorMessage);\n      console.error(`[PluginRegistry] Registration error for ${result.pluginId}:`, error);\n      return result;\n    }\n  }\n\n  /**\n   * Unregister a plugin\n   */\n  async unregisterPlugin(pluginId: string, reason?: string): Promise<boolean> {\n    try {\n      const plugin = this.plugins.get(pluginId);\n      const registration = this.registrations.get(pluginId);\n\n      if (!plugin || !registration) {\n        console.warn(`[PluginRegistry] Cannot unregister unknown plugin: ${pluginId}`);\n        return false;\n      }\n\n      // Notify plugin of deactivation\n      try {\n        await plugin.onLifecycleEvent(PluginLifecycleEvent.DEACTIVATED, { reason });\n        await plugin.cleanup();\n      } catch (error) {\n        console.warn(`[PluginRegistry] Plugin cleanup failed for ${pluginId}:`, error);\n      }\n\n      // Remove from all tracking maps\n      this.plugins.delete(pluginId);\n      this.registrations.delete(pluginId);\n      this.performanceMetrics.delete(pluginId);\n      this.rateLimitTrackers.delete(pluginId);\n\n      // Remove auth tokens\n      for (const [token, authContext] of this.authTokens.entries()) {\n        if (authContext.pluginId === pluginId) {\n          this.authTokens.delete(token);\n        }\n      }\n\n      console.log(`[PluginRegistry] Successfully unregistered plugin: ${pluginId}`, { reason });\n      return true;\n\n    } catch (error) {\n      console.error(`[PluginRegistry] Error unregistering plugin ${pluginId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Get a registered plugin by ID\n   */\n  getPlugin(pluginId: string): IAIProcessingPlugin | undefined {\n    return this.plugins.get(pluginId);\n  }\n\n  /**\n   * Get all registered plugins with optional filtering\n   */\n  getPlugins(filter?: PluginFilter): IAIProcessingPlugin[] {\n    const plugins: IAIProcessingPlugin[] = [];\n\n    for (const [pluginId, plugin] of this.plugins.entries()) {\n      const registration = this.registrations.get(pluginId);\n      if (!registration) continue;\n\n      // Apply filters\n      if (filter) {\n        if (filter.status && !filter.status.includes(registration.status)) continue;\n        if (filter.author && registration.plugin.author !== filter.author) continue;\n        if (filter.capabilities && !this.hasCapabilities(registration.plugin, filter.capabilities)) continue;\n        if (filter.permissions && !this.hasPermissions(registration.validatedCapabilities.requiredPermissions, filter.permissions)) continue;\n        if (filter.minVersion && !this.isVersionCompatible(registration.plugin.version, filter.minVersion, '>=')) continue;\n        if (filter.maxVersion && !this.isVersionCompatible(registration.plugin.version, filter.maxVersion, '<=')) continue;\n      }\n\n      plugins.push(plugin);\n    }\n\n    return plugins;\n  }\n\n  /**\n   * Update plugin status\n   */\n  async updatePluginStatus(pluginId: string, status: PluginRegistrationStatus, reason?: string): Promise<boolean> {\n    const registration = this.registrations.get(pluginId);\n    const plugin = this.plugins.get(pluginId);\n\n    if (!registration || !plugin) {\n      return false;\n    }\n\n    const previousStatus = registration.status;\n    registration.status = status;\n\n    // Notify plugin of status change\n    try {\n      const eventMapping = {\n        [PluginRegistrationStatus.ACTIVE]: PluginLifecycleEvent.ACTIVATED,\n        [PluginRegistrationStatus.SUSPENDED]: PluginLifecycleEvent.SUSPENDED,\n        [PluginRegistrationStatus.DEACTIVATED]: PluginLifecycleEvent.DEACTIVATED,\n        [PluginRegistrationStatus.SECURITY_VIOLATION]: PluginLifecycleEvent.ERROR,\n        [PluginRegistrationStatus.VERSION_INCOMPATIBLE]: PluginLifecycleEvent.ERROR\n      };\n\n      const event = eventMapping[status];\n      if (event) {\n        await plugin.onLifecycleEvent(event, { previousStatus, reason });\n      }\n\n      console.log(`[PluginRegistry] Updated plugin ${pluginId} status: ${previousStatus} -> ${status}`, { reason });\n      return true;\n\n    } catch (error) {\n      console.error(`[PluginRegistry] Error updating status for plugin ${pluginId}:`, error);\n      registration.status = previousStatus; // Rollback\n      return false;\n    }\n  }\n\n  /**\n   * Authenticate a plugin for API operations\n   */\n  async authenticatePlugin(pluginId: string, credentials: PluginCredentials): Promise<PluginAuthenticationContext | null> {\n    try {\n      // Validate credentials\n      if (credentials.pluginId !== pluginId) {\n        return null;\n      }\n\n      const authContext = this.authTokens.get(credentials.authToken || '');\n      if (!authContext || authContext.pluginId !== pluginId) {\n        return null;\n      }\n\n      // Check expiration\n      if (authContext.expiresAt < new Date()) {\n        this.authTokens.delete(credentials.authToken || '');\n        return null;\n      }\n\n      // Validate registration status\n      const registration = this.registrations.get(pluginId);\n      if (!registration || registration.status !== PluginRegistrationStatus.ACTIVE) {\n        return null;\n      }\n\n      // Update last activity\n      registration.lastActivity = new Date();\n\n      return authContext;\n\n    } catch (error) {\n      console.error(`[PluginRegistry] Authentication error for plugin ${pluginId}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Validate plugin permissions for an operation\n   */\n  async validatePermissions(\n    pluginId: string, \n    requiredPermissions: PluginPermission[], \n    context?: any\n  ): Promise<PermissionValidationResult> {\n    const result: PermissionValidationResult = {\n      hasPermission: false,\n      missingPermissions: [],\n      warnings: [],\n      contextValidation: true\n    };\n\n    try {\n      const registration = this.registrations.get(pluginId);\n      if (!registration) {\n        result.missingPermissions = requiredPermissions;\n        return result;\n      }\n\n      const grantedPermissions = registration.validatedCapabilities.requiredPermissions;\n      const missingPermissions: PluginPermission[] = [];\n\n      for (const permission of requiredPermissions) {\n        if (!grantedPermissions.includes(permission)) {\n          missingPermissions.push(permission);\n        }\n      }\n\n      result.hasPermission = missingPermissions.length === 0;\n      result.missingPermissions = missingPermissions;\n\n      // Context-specific validation\n      if (context && result.hasPermission) {\n        result.contextValidation = await this.validatePermissionContext(pluginId, requiredPermissions, context);\n        if (!result.contextValidation) {\n          result.warnings.push('Permission granted but context validation failed');\n        }\n      }\n\n      return result;\n\n    } catch (error) {\n      result.warnings.push(`Permission validation error: ${error instanceof Error ? error.message : String(error)}`);\n      return result;\n    }\n  }\n\n  /**\n   * Get plugin performance metrics\n   */\n  getPluginMetrics(pluginId: string): PluginPerformanceMetrics | undefined {\n    return this.performanceMetrics.get(pluginId);\n  }\n\n  /**\n   * Record plugin error and update metrics\n   */\n  async recordPluginError(pluginId: string, error: Error, context?: any): Promise<void> {\n    const metrics = this.performanceMetrics.get(pluginId);\n    if (metrics) {\n      metrics.errorRate = (metrics.errorRate * metrics.totalSubmissions + 1) / (metrics.totalSubmissions + 1);\n      metrics.lastErrorTime = new Date();\n    }\n\n    const plugin = this.plugins.get(pluginId);\n    if (plugin) {\n      try {\n        await plugin.onLifecycleEvent(PluginLifecycleEvent.ERROR, { error, context });\n      } catch (lifecycleError) {\n        console.error(`[PluginRegistry] Plugin lifecycle error handling failed for ${pluginId}:`, lifecycleError);\n      }\n    }\n\n    console.error(`[PluginRegistry] Recorded error for plugin ${pluginId}:`, { error: error.message, context });\n  }\n\n  /**\n   * Check if a plugin has required capabilities\n   */\n  private hasCapabilities(plugin: AIProcessingPlugin, requiredCapabilities: string[]): boolean {\n    return requiredCapabilities.every(capability => \n      plugin.capabilities.editorialOperations.includes(capability as any)\n    );\n  }\n\n  /**\n   * Check if permissions include required permissions\n   */\n  private hasPermissions(grantedPermissions: PluginPermission[], requiredPermissions: PluginPermission[]): boolean {\n    return requiredPermissions.every(permission => grantedPermissions.includes(permission));\n  }\n\n  /**\n   * Check version compatibility\n   */\n  private isVersionCompatible(version: string, compareVersion: string, operator: '>=' | '<='): boolean {\n    // Simple semantic version comparison (would use a proper semver library in production)\n    const parseVersion = (v: string) => v.split('.').map(n => parseInt(n, 10));\n    const v1 = parseVersion(version);\n    const v2 = parseVersion(compareVersion);\n\n    for (let i = 0; i < 3; i++) {\n      if (v1[i] !== v2[i]) {\n        return operator === '>=' ? v1[i] >= v2[i] : v1[i] <= v2[i];\n      }\n    }\n    return true; // Equal versions\n  }\n\n  /**\n   * Validate plugin metadata structure\n   */\n  private validatePluginMetadata(plugin: AIProcessingPlugin): { isValid: boolean; errors: string[]; warnings: string[] } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    if (!plugin.id || !/^[a-z0-9][a-z0-9-]*[a-z0-9]$/.test(plugin.id)) {\n      errors.push('Invalid plugin ID format');\n    }\n\n    if (!plugin.name || plugin.name.length === 0) {\n      errors.push('Plugin name is required');\n    }\n\n    if (!plugin.version || !/^\\d+\\.\\d+\\.\\d+$/.test(plugin.version)) {\n      errors.push('Invalid version format (expected semantic versioning)');\n    }\n\n    if (!plugin.author || plugin.author.length === 0) {\n      errors.push('Plugin author is required');\n    }\n\n    if (!plugin.capabilities.editorialOperations || plugin.capabilities.editorialOperations.length === 0) {\n      errors.push('Plugin must declare at least one editorial operation capability');\n    }\n\n    if (!plugin.capabilities.requiredPermissions || plugin.capabilities.requiredPermissions.length === 0) {\n      warnings.push('Plugin declares no required permissions - this may limit functionality');\n    }\n\n    return { isValid: errors.length === 0, errors, warnings };\n  }\n\n  /**\n   * Generate authentication token\n   */\n  private generateAuthToken(): string {\n    return `plugin_${generateId()}_${Date.now()}`;\n  }\n\n  /**\n   * Generate request signature for authentication\n   */\n  private generateRequestSignature(pluginId: string, authToken: string): string {\n    // In production, this would use proper cryptographic signing\n    return `sig_${btoa(`${pluginId}:${authToken}:${Date.now()}`)}}`;\n  }\n\n  /**\n   * Determine granted permissions based on requested permissions and security restrictions\n   */\n  private determineGrantedPermissions(\n    requestedPermissions: PluginPermission[], \n    securityRestrictions: string[]\n  ): PluginPermission[] {\n    const grantedPermissions = [...requestedPermissions];\n\n    // Apply security restrictions\n    if (securityRestrictions.includes('no_network_access')) {\n      const index = grantedPermissions.indexOf(PluginPermission.NETWORK_ACCESS);\n      if (index > -1) grantedPermissions.splice(index, 1);\n    }\n\n    if (securityRestrictions.includes('no_storage_access')) {\n      const index = grantedPermissions.indexOf(PluginPermission.STORAGE_ACCESS);\n      if (index > -1) grantedPermissions.splice(index, 1);\n    }\n\n    return grantedPermissions;\n  }\n\n  /**\n   * Create initial performance metrics for a new plugin\n   */\n  private createInitialPerformanceMetrics(): PluginPerformanceMetrics {\n    return {\n      totalSubmissions: 0,\n      successRate: 1.0,\n      averageResponseTime: 0,\n      errorRate: 0,\n      rateLimitViolations: 0\n    };\n  }\n\n  /**\n   * Get default security options\n   */\n  private getDefaultSecurityOptions(): PluginSecurityOptions {\n    return {\n      validateCodeSignature: true,\n      allowNetworkAccess: false,\n      allowStorageAccess: true,\n      maxMemoryUsage: 50 * 1024 * 1024, // 50MB\n      rateLimitConfig: {\n        requestsPerMinute: 60,\n        requestsPerHour: 1000,\n        burstLimit: 10,\n        cooldownPeriod: 1000\n      },\n      sandboxEnabled: true\n    };\n  }\n\n  /**\n   * Validate permission context for specific operations\n   */\n  private async validatePermissionContext(\n    pluginId: string, \n    permissions: PluginPermission[], \n    context: any\n  ): Promise<boolean> {\n    // Context-specific validation logic would go here\n    // For example, checking file access permissions against specific files\n    return true;\n  }\n}\n\n/**\n * Rate limiting tracker for plugins\n */\nclass RateLimitTracker {\n  private requestTimes: number[] = [];\n  private burstCount = 0;\n  private lastBurstTime = 0;\n\n  constructor(private config: RateLimitConfig) {}\n\n  /**\n   * Check if a request is allowed under rate limits\n   */\n  isRequestAllowed(): boolean {\n    const now = Date.now();\n    const oneMinuteAgo = now - 60 * 1000;\n    const oneHourAgo = now - 60 * 60 * 1000;\n\n    // Clean old requests\n    this.requestTimes = this.requestTimes.filter(time => time > oneHourAgo);\n\n    // Check hourly limit\n    if (this.requestTimes.length >= this.config.requestsPerHour) {\n      return false;\n    }\n\n    // Check per-minute limit\n    const recentRequests = this.requestTimes.filter(time => time > oneMinuteAgo);\n    if (recentRequests.length >= this.config.requestsPerMinute) {\n      return false;\n    }\n\n    // Check burst limit\n    if (now - this.lastBurstTime > this.config.cooldownPeriod) {\n      this.burstCount = 0;\n      this.lastBurstTime = now;\n    }\n\n    if (this.burstCount >= this.config.burstLimit) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Record a request\n   */\n  recordRequest(): void {\n    const now = Date.now();\n    this.requestTimes.push(now);\n    this.burstCount++;\n  }\n}\n\n/**\n * Interfaces for security and capability validation (to be implemented in separate files)\n */\nexport interface IPluginSecurityValidator {\n  validateSecurity(plugin: IAIProcessingPlugin, options: PluginSecurityOptions): Promise<{\n    isSecure: boolean;\n    securityThreats: string[];\n    warnings: string[];\n    recommendedRestrictions: string[];\n    securityHash: string;\n  }>;\n}\n\nexport interface IPluginCapabilityValidator {\n  validateCapabilities(plugin: AIProcessingPlugin, requiredCapabilities: string[], context?: any): Promise<{\n    isValid: boolean;\n    missingCapabilities: string[];\n    warnings: string[];\n  }>;\n}", "/**\n * Plugin Security Validator\n * \n * Provides security validation, sandboxing, and permission management\n * for AI processing plugins in the Track Edits system.\n */\n\nimport { \n  PluginPermission,\n  AIProcessingPlugin \n} from '../types/submit-changes-from-ai';\n\nimport {\n  IAIProcessingPlugin,\n  PluginSecurityOptions,\n  SecurityValidationResult\n} from './plugin-interface';\n\nimport { IPluginSecurityValidator } from './plugin-registry';\n// Simple hash function for plugin fingerprinting (no crypto dependency)\nfunction simpleHash(str: string): string {\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash).toString(36);\n}\n\n/**\n * Security validator for plugins with comprehensive security checks\n */\nexport class PluginSecurityValidator implements IPluginSecurityValidator {\n  private trustedAuthors = new Set<string>(['writerr-official', 'obsidian-community']);\n  private blacklistedPatterns = [\n    /eval\\s*\\(/,\n    /Function\\s*\\(/,\n    /require\\s*\\(/,\n    /import\\s*\\(/,\n    /process\\./,\n    /global\\./,\n    /window\\./,\n    /document\\./\n  ];\n\n  /**\n   * Validate plugin security with comprehensive checks\n   */\n  async validateSecurity(\n    plugin: IAIProcessingPlugin, \n    options: PluginSecurityOptions\n  ): Promise<SecurityValidationResult> {\n    const result: SecurityValidationResult = {\n      isSecure: true,\n      securityThreats: [],\n      warnings: [],\n      recommendedRestrictions: [],\n      securityHash: ''\n    };\n\n    const pluginInfo = plugin.getPluginInfo();\n\n    try {\n      // Generate security hash\n      result.securityHash = this.generateSecurityHash(pluginInfo);\n\n      // Validate plugin metadata\n      this.validatePluginMetadata(pluginInfo, result);\n\n      // Validate capabilities and permissions\n      this.validateCapabilitiesAndPermissions(pluginInfo, result);\n\n      // Check code security (static analysis)\n      await this.performStaticSecurityAnalysis(plugin, result);\n\n      // Validate against security options\n      this.validateAgainstSecurityOptions(pluginInfo, options, result);\n\n      // Author trust validation\n      this.validateAuthorTrust(pluginInfo, result);\n\n      // Permission risk assessment\n      this.assessPermissionRisks(pluginInfo.capabilities.requiredPermissions, result);\n\n      // Network access validation\n      if (pluginInfo.capabilities.requiredPermissions.includes(PluginPermission.NETWORK_ACCESS)) {\n        this.validateNetworkAccess(pluginInfo, options, result);\n      }\n\n      // Storage access validation\n      if (pluginInfo.capabilities.requiredPermissions.includes(PluginPermission.STORAGE_ACCESS)) {\n        this.validateStorageAccess(pluginInfo, options, result);\n      }\n\n      // Determine final security status\n      result.isSecure = result.securityThreats.length === 0;\n\n      if (result.securityThreats.length > 0) {\n        console.warn(`[PluginSecurityValidator] Security threats detected for plugin ${pluginInfo.id}:`, \n          result.securityThreats);\n      }\n\n      return result;\n\n    } catch (error) {\n      result.isSecure = false;\n      result.securityThreats.push(`Security validation failed: ${error instanceof Error ? error.message : String(error)}`);\n      return result;\n    }\n  }\n\n  /**\n   * Generate security hash for plugin integrity verification\n   */\n  generateSecurityHash(plugin: AIProcessingPlugin): string {\n    const hashInput = JSON.stringify({\n      id: plugin.id,\n      version: plugin.version,\n      author: plugin.author,\n      capabilities: plugin.capabilities,\n      apiVersion: plugin.apiVersion\n    });\n\n    return simpleHash(hashInput);\n  }\n\n  /**\n   * Verify plugin integrity against expected hash\n   */\n  verifyIntegrity(plugin: IAIProcessingPlugin, expectedHash: string): boolean {\n    const pluginInfo = plugin.getPluginInfo();\n    const currentHash = this.generateSecurityHash(pluginInfo);\n    return currentHash === expectedHash;\n  }\n\n  /**\n   * Validate plugin metadata for security issues\n   */\n  private validatePluginMetadata(plugin: AIProcessingPlugin, result: SecurityValidationResult): void {\n    // Check for suspicious plugin IDs\n    if (plugin.id.includes('..') || plugin.id.includes('/') || plugin.id.includes('\\\\')) {\n      result.securityThreats.push('Plugin ID contains suspicious path characters');\n    }\n\n    // Validate version format\n    if (!/^\\d+\\.\\d+\\.\\d+$/.test(plugin.version)) {\n      result.warnings.push('Non-standard version format detected');\n    }\n\n    // Check description for suspicious content\n    if (plugin.description && this.containsSuspiciousContent(plugin.description)) {\n      result.warnings.push('Plugin description contains potentially suspicious content');\n    }\n\n    // Validate repository URL if provided\n    if (plugin.metadata.repository) {\n      if (!this.isValidRepositoryUrl(plugin.metadata.repository)) {\n        result.warnings.push('Invalid or suspicious repository URL');\n      }\n    }\n  }\n\n  /**\n   * Validate capabilities and permissions for security risks\n   */\n  private validateCapabilitiesAndPermissions(plugin: AIProcessingPlugin, result: SecurityValidationResult): void {\n    const { capabilities } = plugin;\n\n    // Check for excessive permissions\n    if (capabilities.requiredPermissions.length > 5) {\n      result.warnings.push('Plugin requests an unusually high number of permissions');\n    }\n\n    // Validate permission combinations\n    const hasNetworkAndModify = capabilities.requiredPermissions.includes(PluginPermission.NETWORK_ACCESS) &&\n                                capabilities.requiredPermissions.includes(PluginPermission.MODIFY_DOCUMENTS);\n    \n    if (hasNetworkAndModify) {\n      result.warnings.push('Plugin combines network access with document modification - high risk combination');\n      result.recommendedRestrictions.push('monitor_network_activity');\n    }\n\n    // Check for suspicious AI providers\n    if (capabilities.aiProviders && capabilities.aiProviders.some(provider => \n        this.isSuspiciousAIProvider(provider))) {\n      result.warnings.push('Plugin declares support for unrecognized AI providers');\n    }\n\n    // Validate batch size limits\n    if (capabilities.maxBatchSize > 1000) {\n      result.warnings.push('Plugin declares unusually large batch size - potential DoS risk');\n      result.recommendedRestrictions.push('limit_batch_size');\n    }\n  }\n\n  /**\n   * Perform static security analysis on plugin code\n   */\n  private async performStaticSecurityAnalysis(\n    plugin: IAIProcessingPlugin, \n    result: SecurityValidationResult\n  ): Promise<void> {\n    try {\n      // Convert plugin to string for analysis (simplified approach)\n      const pluginString = plugin.toString();\n\n      // Check for dangerous patterns\n      for (const pattern of this.blacklistedPatterns) {\n        if (pattern.test(pluginString)) {\n          result.securityThreats.push(`Dangerous code pattern detected: ${pattern.source}`);\n        }\n      }\n\n      // Check for obfuscated code\n      if (this.appearsObfuscated(pluginString)) {\n        result.securityThreats.push('Plugin code appears to be obfuscated');\n      }\n\n      // Check for external imports/requires\n      const externalImports = this.findExternalImports(pluginString);\n      if (externalImports.length > 0) {\n        result.warnings.push(`Plugin attempts to import external modules: ${externalImports.join(', ')}`);\n      }\n\n    } catch (error) {\n      result.warnings.push('Static code analysis failed - manual review required');\n    }\n  }\n\n  /**\n   * Validate against security options\n   */\n  private validateAgainstSecurityOptions(\n    plugin: AIProcessingPlugin, \n    options: PluginSecurityOptions, \n    result: SecurityValidationResult\n  ): void {\n    // Check network access against options\n    if (plugin.capabilities.requiredPermissions.includes(PluginPermission.NETWORK_ACCESS) && \n        !options.allowNetworkAccess) {\n      result.securityThreats.push('Plugin requires network access but policy disallows it');\n    }\n\n    // Check storage access against options\n    if (plugin.capabilities.requiredPermissions.includes(PluginPermission.STORAGE_ACCESS) && \n        !options.allowStorageAccess) {\n      result.securityThreats.push('Plugin requires storage access but policy disallows it');\n    }\n\n    // Validate sandbox requirements\n    if (options.sandboxEnabled && !this.isSandboxCompatible(plugin)) {\n      result.securityThreats.push('Plugin is not compatible with sandbox environment');\n    }\n\n    // Check memory usage requirements\n    if (plugin.capabilities.maxBatchSize * 1024 > options.maxMemoryUsage) {\n      result.warnings.push('Plugin may exceed memory limits based on batch size');\n      result.recommendedRestrictions.push('limit_memory_usage');\n    }\n  }\n\n  /**\n   * Validate author trust level\n   */\n  private validateAuthorTrust(plugin: AIProcessingPlugin, result: SecurityValidationResult): void {\n    const { author } = plugin;\n\n    if (this.trustedAuthors.has(author)) {\n      result.warnings.push('Plugin from trusted author - reduced security restrictions');\n      return;\n    }\n\n    // Check for suspicious author names\n    if (this.isSuspiciousAuthor(author)) {\n      result.warnings.push('Plugin author appears suspicious - enhanced monitoring recommended');\n      result.recommendedRestrictions.push('enhanced_monitoring');\n    }\n\n    // First-time author warning\n    result.warnings.push('Plugin from unverified author - standard security restrictions apply');\n  }\n\n  /**\n   * Assess risk levels for requested permissions\n   */\n  private assessPermissionRisks(permissions: PluginPermission[], result: SecurityValidationResult): void {\n    const highRiskPermissions = [\n      PluginPermission.NETWORK_ACCESS,\n      PluginPermission.STORAGE_ACCESS,\n      PluginPermission.ACCESS_VAULT_METADATA\n    ];\n\n    const mediumRiskPermissions = [\n      PluginPermission.MODIFY_DOCUMENTS,\n      PluginPermission.USER_INTERFACE\n    ];\n\n    const highRiskCount = permissions.filter(p => highRiskPermissions.includes(p)).length;\n    const mediumRiskCount = permissions.filter(p => mediumRiskPermissions.includes(p)).length;\n\n    if (highRiskCount > 2) {\n      result.warnings.push('Plugin requests multiple high-risk permissions');\n      result.recommendedRestrictions.push('enhanced_monitoring', 'audit_trail');\n    }\n\n    if (highRiskCount + mediumRiskCount > 4) {\n      result.warnings.push('Plugin requests elevated privilege level');\n      result.recommendedRestrictions.push('user_confirmation_required');\n    }\n  }\n\n  /**\n   * Validate network access requirements\n   */\n  private validateNetworkAccess(\n    plugin: AIProcessingPlugin, \n    options: PluginSecurityOptions, \n    result: SecurityValidationResult\n  ): void {\n    if (!options.allowNetworkAccess) {\n      result.securityThreats.push('Network access requested but not allowed by security policy');\n      return;\n    }\n\n    // Check for specific AI providers that require network access\n    if (plugin.capabilities.aiProviders) {\n      const externalProviders = plugin.capabilities.aiProviders.filter(provider => \n        !this.isLocalAIProvider(provider));\n      \n      if (externalProviders.length > 0) {\n        result.warnings.push(`Plugin requires network access for external AI providers: ${externalProviders.join(', ')}`);\n        result.recommendedRestrictions.push('monitor_network_traffic');\n      }\n    }\n\n    result.recommendedRestrictions.push('firewall_rules', 'connection_logging');\n  }\n\n  /**\n   * Validate storage access requirements\n   */\n  private validateStorageAccess(\n    plugin: AIProcessingPlugin, \n    options: PluginSecurityOptions, \n    result: SecurityValidationResult\n  ): void {\n    if (!options.allowStorageAccess) {\n      result.securityThreats.push('Storage access requested but not allowed by security policy');\n      return;\n    }\n\n    result.recommendedRestrictions.push('limit_storage_scope', 'audit_file_access');\n    result.warnings.push('Plugin can access local storage - ensure vault backup is current');\n  }\n\n  /**\n   * Check if content contains suspicious patterns\n   */\n  private containsSuspiciousContent(content: string): boolean {\n    const suspiciousPatterns = [\n      /cryptocurrency|bitcoin|mining/i,\n      /password|credential|token|secret/i,\n      /malware|virus|trojan/i,\n      /eval|execute|run|shell/i\n    ];\n\n    return suspiciousPatterns.some(pattern => pattern.test(content));\n  }\n\n  /**\n   * Validate repository URL format and safety\n   */\n  private isValidRepositoryUrl(url: string): boolean {\n    try {\n      const parsed = new URL(url);\n      const allowedHosts = ['github.com', 'gitlab.com', 'bitbucket.org'];\n      return allowedHosts.some(host => parsed.hostname.endsWith(host));\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if AI provider appears suspicious\n   */\n  private isSuspiciousAIProvider(provider: string): boolean {\n    const knownProviders = [\n      'openai', 'anthropic', 'google', 'microsoft', 'meta',\n      'cohere', 'huggingface', 'replicate', 'together'\n    ];\n\n    return !knownProviders.some(known => \n      provider.toLowerCase().includes(known));\n  }\n\n  /**\n   * Check if code appears obfuscated\n   */\n  private appearsObfuscated(code: string): boolean {\n    // Simple heuristics for code obfuscation\n    const suspiciousPatterns = [\n      /[a-zA-Z_$][a-zA-Z0-9_$]{50,}/,  // Extremely long variable names\n      /\\\\x[0-9a-fA-F]{2}/,             // Hex escape sequences\n      /\\\\u[0-9a-fA-F]{4}/,             // Unicode escape sequences\n      /eval\\s*\\(\\s*['\"]/,              // eval with string\n      /String\\.fromCharCode/           // Character code conversion\n    ];\n\n    return suspiciousPatterns.some(pattern => pattern.test(code));\n  }\n\n  /**\n   * Find external imports in code\n   */\n  private findExternalImports(code: string): string[] {\n    const imports: string[] = [];\n    const importPatterns = [\n      /require\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g,\n      /import\\s+.*\\s+from\\s+['\"]([^'\"]+)['\"]/g,\n      /import\\s*\\(\\s*['\"]([^'\"]+)['\"]\\s*\\)/g\n    ];\n\n    importPatterns.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(code)) !== null) {\n        imports.push(match[1]);\n      }\n    });\n\n    return imports.filter(imp => !imp.startsWith('.') && !imp.startsWith('/'));\n  }\n\n  /**\n   * Check if author name appears suspicious\n   */\n  private isSuspiciousAuthor(author: string): boolean {\n    const suspiciousPatterns = [\n      /^[a-zA-Z0-9]{32,}$/,  // Random-looking long strings\n      /test|temp|fake|anonymous/i,\n      /admin|root|system/i,\n      /[0-9]{5,}/             // Long sequences of numbers\n    ];\n\n    return suspiciousPatterns.some(pattern => pattern.test(author));\n  }\n\n  /**\n   * Check if AI provider is local/offline\n   */\n  private isLocalAIProvider(provider: string): boolean {\n    const localProviders = [\n      'local', 'offline', 'llamacpp', 'ollama', \n      'transformers', 'tensorflow', 'pytorch'\n    ];\n\n    return localProviders.some(local => \n      provider.toLowerCase().includes(local));\n  }\n\n  /**\n   * Check if plugin is compatible with sandbox environment\n   */\n  private isSandboxCompatible(plugin: AIProcessingPlugin): boolean {\n    const incompatiblePermissions = [\n      PluginPermission.NETWORK_ACCESS,\n      PluginPermission.STORAGE_ACCESS\n    ];\n\n    // Plugin is sandbox compatible if it doesn't require incompatible permissions\n    return !plugin.capabilities.requiredPermissions.some(permission =>\n      incompatiblePermissions.includes(permission));\n  }\n}", "/**\n * Plugin Capability Validator\n * \n * Validates and manages plugin capabilities for AI processing plugins,\n * ensuring they can perform the operations they claim to support.\n */\n\nimport { \n  AIProcessingPlugin,\n  PluginCapabilities,\n  EditorialOperationType \n} from '../types/submit-changes-from-ai';\n\nimport {\n  IPluginCapabilityValidator,\n  CapabilityValidationResult,\n  DEFAULT_PLUGIN_CAPABILITIES\n} from './plugin-interface';\n\n/**\n * Validator for plugin capabilities with operation-specific validation\n */\nexport class PluginCapabilityValidator implements IPluginCapabilityValidator {\n  private supportedEditorialOperations = new Set<string>([\n    'replace', 'insert', 'delete', 'restructure', 'format', 'analyze', \n    'translate', 'summarize', 'expand', 'compress', 'correct', 'enhance'\n  ]);\n\n  private supportedAIProviders = new Set<string>([\n    'openai', 'anthropic', 'google', 'microsoft', 'meta', 'cohere',\n    'huggingface', 'replicate', 'together', 'local', 'ollama'\n  ]);\n\n  private supportedFileTypes = new Set<string>([\n    'markdown', 'text', 'json', 'yaml', 'html', 'xml', 'csv'\n  ]);\n\n  /**\n   * Validate plugin capabilities against requirements\n   */\n  async validateCapabilities(\n    plugin: AIProcessingPlugin,\n    requiredCapabilities: string[],\n    context?: any\n  ): Promise<CapabilityValidationResult> {\n    const result: CapabilityValidationResult = {\n      isValid: true,\n      missingCapabilities: [],\n      recommendedCapabilities: [],\n      warnings: []\n    };\n\n    try {\n      // Validate editorial operations\n      await this.validateEditorialOperations(plugin, requiredCapabilities, result);\n\n      // Validate AI provider support\n      await this.validateAIProviderSupport(plugin, result);\n\n      // Validate batch processing capabilities\n      await this.validateBatchCapabilities(plugin, context, result);\n\n      // Validate file type support\n      await this.validateFileTypeSupport(plugin, context, result);\n\n      // Validate real-time capabilities\n      await this.validateRealTimeCapabilities(plugin, context, result);\n\n      // Validate conversation context support\n      await this.validateConversationContextSupport(plugin, context, result);\n\n      // Generate recommendations\n      this.generateCapabilityRecommendations(plugin, requiredCapabilities, result);\n\n      // Final validation status\n      result.isValid = result.missingCapabilities.length === 0;\n\n      return result;\n\n    } catch (error) {\n      result.isValid = false;\n      result.warnings.push(`Capability validation failed: ${error instanceof Error ? error.message : String(error)}`);\n      return result;\n    }\n  }\n\n  /**\n   * Get recommended capabilities for specific operation types\n   */\n  getRecommendedCapabilities(operationType: string): PluginCapabilities {\n    // Return default capabilities based on operation type\n    const defaultCapabilities = DEFAULT_PLUGIN_CAPABILITIES[operationType];\n    \n    if (defaultCapabilities) {\n      return {\n        editorialOperations: defaultCapabilities.editorialOperations || [],\n        aiProviders: defaultCapabilities.aiProviders || [],\n        maxBatchSize: defaultCapabilities.maxBatchSize || 10,\n        supportsRealTime: defaultCapabilities.supportsRealTime || false,\n        supportsConversationContext: defaultCapabilities.supportsConversationContext || false,\n        supportedFileTypes: defaultCapabilities.supportedFileTypes || ['markdown'],\n        requiredPermissions: defaultCapabilities.requiredPermissions || []\n      };\n    }\n\n    // Return basic capabilities for unknown operation types\n    return {\n      editorialOperations: ['replace', 'insert'],\n      aiProviders: ['openai'],\n      maxBatchSize: 5,\n      supportsRealTime: false,\n      supportsConversationContext: false,\n      supportedFileTypes: ['markdown'],\n      requiredPermissions: []\n    };\n  }\n\n  /**\n   * Validate editorial operations capabilities\n   */\n  private async validateEditorialOperations(\n    plugin: AIProcessingPlugin,\n    requiredCapabilities: string[],\n    result: CapabilityValidationResult\n  ): Promise<void> {\n    const { editorialOperations } = plugin.capabilities;\n\n    // Check if plugin declares any editorial operations\n    if (!editorialOperations || editorialOperations.length === 0) {\n      result.warnings.push('Plugin declares no editorial operations');\n      result.recommendedCapabilities.push('basic_text_editing');\n      return;\n    }\n\n    // Validate each declared operation\n    for (const operation of editorialOperations) {\n      if (!this.supportedEditorialOperations.has(operation)) {\n        result.warnings.push(`Unknown editorial operation: ${operation}`);\n      }\n    }\n\n    // Check for required capabilities\n    const missingOperations = requiredCapabilities.filter(capability => \n      this.isEditorialOperation(capability) && \n      !editorialOperations.includes(capability as EditorialOperationType)\n    );\n\n    result.missingCapabilities.push(...missingOperations);\n\n    // Validate operation combinations\n    this.validateOperationCombinations(editorialOperations, result);\n  }\n\n  /**\n   * Validate AI provider support\n   */\n  private async validateAIProviderSupport(\n    plugin: AIProcessingPlugin,\n    result: CapabilityValidationResult\n  ): Promise<void> {\n    const { aiProviders } = plugin.capabilities;\n\n    if (!aiProviders || aiProviders.length === 0) {\n      result.warnings.push('Plugin declares no AI provider support - will use system default');\n      return;\n    }\n\n    // Validate each declared provider\n    for (const provider of aiProviders) {\n      if (!this.supportedAIProviders.has(provider.toLowerCase())) {\n        result.warnings.push(`Unrecognized AI provider: ${provider}`);\n      }\n    }\n\n    // Check for provider-specific requirements\n    this.validateProviderSpecificRequirements(aiProviders, result);\n  }\n\n  /**\n   * Validate batch processing capabilities\n   */\n  private async validateBatchCapabilities(\n    plugin: AIProcessingPlugin,\n    context: any,\n    result: CapabilityValidationResult\n  ): Promise<void> {\n    const { maxBatchSize } = plugin.capabilities;\n\n    // Validate batch size limits\n    if (maxBatchSize <= 0) {\n      result.warnings.push('Plugin declares zero or negative batch size');\n      return;\n    }\n\n    if (maxBatchSize > 1000) {\n      result.warnings.push('Plugin declares very large batch size - may cause performance issues');\n      result.recommendedCapabilities.push('streaming_support');\n    }\n\n    // Context-specific validation\n    if (context?.expectedBatchSize && maxBatchSize < context.expectedBatchSize) {\n      result.warnings.push(`Plugin batch size (${maxBatchSize}) is smaller than expected (${context.expectedBatchSize})`);\n    }\n  }\n\n  /**\n   * Validate file type support\n   */\n  private async validateFileTypeSupport(\n    plugin: AIProcessingPlugin,\n    context: any,\n    result: CapabilityValidationResult\n  ): Promise<void> {\n    const { supportedFileTypes } = plugin.capabilities;\n\n    if (!supportedFileTypes || supportedFileTypes.length === 0) {\n      result.warnings.push('Plugin declares no file type support - assuming markdown only');\n      return;\n    }\n\n    // Validate each declared file type\n    for (const fileType of supportedFileTypes) {\n      if (!this.supportedFileTypes.has(fileType.toLowerCase())) {\n        result.warnings.push(`Unsupported file type: ${fileType}`);\n      }\n    }\n\n    // Context-specific file type validation\n    if (context?.requiredFileType) {\n      const requiredType = context.requiredFileType.toLowerCase();\n      if (!supportedFileTypes.some(type => type.toLowerCase() === requiredType)) {\n        result.missingCapabilities.push(`file_type_${requiredType}`);\n      }\n    }\n  }\n\n  /**\n   * Validate real-time processing capabilities\n   */\n  private async validateRealTimeCapabilities(\n    plugin: AIProcessingPlugin,\n    context: any,\n    result: CapabilityValidationResult\n  ): Promise<void> {\n    const { supportsRealTime } = plugin.capabilities;\n\n    if (context?.requiresRealTime && !supportsRealTime) {\n      result.missingCapabilities.push('real_time_processing');\n      result.recommendedCapabilities.push('streaming_api', 'incremental_updates');\n    }\n\n    if (supportsRealTime) {\n      // Validate that plugin has appropriate permissions for real-time operations\n      if (!plugin.capabilities.requiredPermissions.some(p => p.toString().includes('USER_INTERFACE'))) {\n        result.warnings.push('Plugin claims real-time support but lacks UI permissions');\n      }\n    }\n  }\n\n  /**\n   * Validate conversation context support\n   */\n  private async validateConversationContextSupport(\n    plugin: AIProcessingPlugin,\n    context: any,\n    result: CapabilityValidationResult\n  ): Promise<void> {\n    const { supportsConversationContext } = plugin.capabilities;\n\n    if (context?.requiresConversationContext && !supportsConversationContext) {\n      result.missingCapabilities.push('conversation_context');\n      result.recommendedCapabilities.push('session_management', 'context_tracking');\n    }\n\n    if (supportsConversationContext) {\n      // Validate that plugin can handle session management\n      if (!plugin.capabilities.editorialOperations.includes('analyze' as EditorialOperationType)) {\n        result.warnings.push('Plugin supports conversation context but lacks analysis capabilities');\n      }\n    }\n  }\n\n  /**\n   * Generate capability recommendations based on plugin configuration\n   */\n  private generateCapabilityRecommendations(\n    plugin: AIProcessingPlugin,\n    requiredCapabilities: string[],\n    result: CapabilityValidationResult\n  ): void {\n    const capabilities = plugin.capabilities;\n\n    // Recommend based on editorial operations\n    if (capabilities.editorialOperations.includes('restructure' as EditorialOperationType)) {\n      if (!capabilities.editorialOperations.includes('analyze' as EditorialOperationType)) {\n        result.recommendedCapabilities.push('content_analysis');\n      }\n    }\n\n    // Recommend based on batch size\n    if (capabilities.maxBatchSize > 50) {\n      if (!capabilities.supportsRealTime) {\n        result.recommendedCapabilities.push('progress_reporting');\n      }\n    }\n\n    // Recommend based on AI providers\n    if (capabilities.aiProviders.includes('local') || capabilities.aiProviders.includes('ollama')) {\n      result.recommendedCapabilities.push('offline_support');\n    }\n\n    // Recommend based on missing capabilities\n    if (result.missingCapabilities.length > 0) {\n      result.recommendedCapabilities.push('capability_extension_api');\n    }\n  }\n\n  /**\n   * Validate combinations of editorial operations\n   */\n  private validateOperationCombinations(\n    operations: EditorialOperationType[],\n    result: CapabilityValidationResult\n  ): void {\n    // Some operations require others\n    const dependencies = new Map<string, string[]>([\n      ['restructure', ['analyze']],\n      ['enhance', ['analyze', 'format']],\n      ['summarize', ['analyze']],\n      ['translate', ['analyze']],\n    ]);\n\n    for (const operation of operations) {\n      const requiredDeps = dependencies.get(operation);\n      if (requiredDeps) {\n        const missingDeps = requiredDeps.filter(dep => \n          !operations.includes(dep as EditorialOperationType));\n        \n        if (missingDeps.length > 0) {\n          result.warnings.push(\n            `Operation '${operation}' typically requires: ${missingDeps.join(', ')}`\n          );\n        }\n      }\n    }\n\n    // Warn about potentially conflicting operations\n    if (operations.includes('compress' as EditorialOperationType) && \n        operations.includes('expand' as EditorialOperationType)) {\n      result.warnings.push('Plugin declares both compress and expand - ensure proper operation selection');\n    }\n  }\n\n  /**\n   * Validate provider-specific requirements\n   */\n  private validateProviderSpecificRequirements(\n    providers: string[],\n    result: CapabilityValidationResult\n  ): void {\n    // OpenAI-specific validation\n    if (providers.includes('openai')) {\n      result.recommendedCapabilities.push('api_key_management', 'rate_limit_handling');\n    }\n\n    // Anthropic-specific validation\n    if (providers.includes('anthropic')) {\n      result.recommendedCapabilities.push('message_format_handling');\n    }\n\n    // Local provider validation\n    if (providers.includes('local') || providers.includes('ollama')) {\n      result.recommendedCapabilities.push('model_management', 'offline_support');\n    }\n\n    // Multiple provider support\n    if (providers.length > 3) {\n      result.recommendedCapabilities.push('provider_switching', 'unified_api');\n    }\n  }\n\n  /**\n   * Check if a capability is an editorial operation\n   */\n  private isEditorialOperation(capability: string): boolean {\n    return this.supportedEditorialOperations.has(capability);\n  }\n\n  /**\n   * Get capability score for a plugin (0-100)\n   */\n  getCapabilityScore(plugin: AIProcessingPlugin): number {\n    let score = 0;\n    const capabilities = plugin.capabilities;\n\n    // Score based on editorial operations (0-40 points)\n    const operationScore = Math.min(40, capabilities.editorialOperations.length * 5);\n    score += operationScore;\n\n    // Score based on AI provider support (0-20 points)\n    const providerScore = Math.min(20, capabilities.aiProviders.length * 4);\n    score += providerScore;\n\n    // Score based on batch size (0-15 points)\n    const batchScore = Math.min(15, Math.log10(capabilities.maxBatchSize) * 5);\n    score += batchScore;\n\n    // Score based on advanced features (0-25 points)\n    let featureScore = 0;\n    if (capabilities.supportsRealTime) featureScore += 8;\n    if (capabilities.supportsConversationContext) featureScore += 8;\n    if (capabilities.supportedFileTypes.length > 2) featureScore += 9;\n    score += featureScore;\n\n    return Math.round(Math.min(100, score));\n  }\n\n  /**\n   * Get compatibility matrix between plugins\n   */\n  getPluginCompatibilityMatrix(plugins: AIProcessingPlugin[]): Map<string, Map<string, number>> {\n    const matrix = new Map<string, Map<string, number>>();\n\n    for (let i = 0; i < plugins.length; i++) {\n      const pluginA = plugins[i];\n      const compatibilityMap = new Map<string, number>();\n\n      for (let j = 0; j < plugins.length; j++) {\n        if (i === j) continue;\n\n        const pluginB = plugins[j];\n        const compatibility = this.calculateCompatibilityScore(pluginA, pluginB);\n        compatibilityMap.set(pluginB.id, compatibility);\n      }\n\n      matrix.set(pluginA.id, compatibilityMap);\n    }\n\n    return matrix;\n  }\n\n  /**\n   * Calculate compatibility score between two plugins (0-100)\n   */\n  private calculateCompatibilityScore(pluginA: AIProcessingPlugin, pluginB: AIProcessingPlugin): number {\n    let score = 0;\n\n    // Editorial operations overlap (0-40 points)\n    const operationsA = new Set(pluginA.capabilities.editorialOperations);\n    const operationsB = new Set(pluginB.capabilities.editorialOperations);\n    const operationOverlap = this.calculateSetOverlap(operationsA, operationsB);\n    score += operationOverlap * 40;\n\n    // AI provider overlap (0-25 points)\n    const providersA = new Set(pluginA.capabilities.aiProviders);\n    const providersB = new Set(pluginB.capabilities.aiProviders);\n    const providerOverlap = this.calculateSetOverlap(providersA, providersB);\n    score += providerOverlap * 25;\n\n    // File type overlap (0-20 points)\n    const fileTypesA = new Set(pluginA.capabilities.supportedFileTypes);\n    const fileTypesB = new Set(pluginB.capabilities.supportedFileTypes);\n    const fileTypeOverlap = this.calculateSetOverlap(fileTypesA, fileTypesB);\n    score += fileTypeOverlap * 20;\n\n    // Feature compatibility (0-15 points)\n    let featureScore = 0;\n    if (pluginA.capabilities.supportsRealTime === pluginB.capabilities.supportsRealTime) {\n      featureScore += 7;\n    }\n    if (pluginA.capabilities.supportsConversationContext === pluginB.capabilities.supportsConversationContext) {\n      featureScore += 8;\n    }\n    score += featureScore;\n\n    return Math.round(Math.min(100, score));\n  }\n\n  /**\n   * Calculate overlap ratio between two sets\n   */\n  private calculateSetOverlap<T>(setA: Set<T>, setB: Set<T>): number {\n    const intersection = new Set([...setA].filter(x => setB.has(x)));\n    const union = new Set([...setA, ...setB]);\n    \n    return union.size === 0 ? 0 : intersection.size / union.size;\n  }\n}", "/**\n * Editorial Engine Plugin Wrapper\n * \n * Wraps the built-in Editorial Engine functionality as a registered plugin\n * to demonstrate plugin system integration and provide a reference implementation.\n */\n\nimport { \n  AIProcessingPlugin,\n  PluginCapabilities,\n  PluginPermission,\n  PluginAuthenticationContext,\n  PluginSubmissionOptions,\n  SubmitChangesFromAIResult,\n  EditorialOperationType\n} from '../types/submit-changes-from-ai';\n\nimport { EditChange, AIProcessingContext } from '../types';\nimport {\n  IAIProcessingPlugin,\n  IPluginRegistry,\n  PluginLifecycleEvent,\n  PLUGIN_API_VERSION\n} from './plugin-interface';\n\n/**\n * Editorial Engine as a registered plugin\n */\nexport class EditorialEnginePluginWrapper implements IAIProcessingPlugin {\n  private registry: IPluginRegistry | null = null;\n  private authContext: PluginAuthenticationContext | null = null;\n  private initialized = false;\n\n  /**\n   * Get plugin information\n   */\n  getPluginInfo(): AIProcessingPlugin {\n    return {\n      id: 'writerr-editorial-engine',\n      name: 'Editorial Engine',\n      version: '1.0.0',\n      author: 'writerr-official',\n      description: 'Built-in AI editorial engine for sophisticated content processing and editing',\n      capabilities: {\n        editorialOperations: [\n          'replace', 'insert', 'delete', 'restructure', 'format', \n          'analyze', 'enhance', 'correct', 'expand', 'compress'\n        ],\n        aiProviders: [\n          'openai', 'anthropic', 'google', 'local', 'ollama'\n        ],\n        maxBatchSize: 100,\n        supportsRealTime: true,\n        supportsConversationContext: true,\n        supportedFileTypes: [\n          'markdown', 'text', 'json', 'yaml', 'html'\n        ],\n        requiredPermissions: [\n          PluginPermission.READ_DOCUMENTS,\n          PluginPermission.MODIFY_DOCUMENTS,\n          PluginPermission.CREATE_SESSIONS,\n          PluginPermission.ACCESS_VAULT_METADATA,\n          PluginPermission.NETWORK_ACCESS,\n          PluginPermission.USER_INTERFACE\n        ]\n      },\n      metadata: {\n        homepage: 'https://writerr.ai/editorial-engine',\n        repository: 'https://github.com/writerr-ai/editorial-engine',\n        documentation: 'https://docs.writerr.ai/editorial-engine',\n        license: 'MIT',\n        keywords: ['ai', 'editing', 'writing', 'content', 'editorial'],\n        minObsidianVersion: '1.0.0',\n        securityPolicy: 'https://writerr.ai/security'\n      },\n      apiVersion: PLUGIN_API_VERSION\n    };\n  }\n\n  /**\n   * Initialize plugin with registry\n   */\n  async initialize(registry: IPluginRegistry, authContext: PluginAuthenticationContext): Promise<void> {\n    this.registry = registry;\n    this.authContext = authContext;\n    this.initialized = true;\n\n    console.log('[EditorialEnginePlugin] Initialized successfully with permissions:', \n      authContext.permissions.join(', '));\n  }\n\n  /**\n   * Submit AI changes through the plugin system\n   */\n  async submitChanges(\n    changes: EditChange[],\n    aiProvider: string,\n    aiModel: string,\n    processingContext?: AIProcessingContext,\n    options?: Partial<PluginSubmissionOptions>\n  ): Promise<SubmitChangesFromAIResult> {\n    if (!this.initialized || !this.authContext) {\n      return {\n        success: false,\n        changeIds: [],\n        errors: ['Plugin not initialized'],\n        warnings: []\n      };\n    }\n\n    // Validate authentication\n    if (!this.registry) {\n      return {\n        success: false,\n        changeIds: [],\n        errors: ['Plugin registry not available'],\n        warnings: []\n      };\n    }\n\n    const authResult = await this.registry.authenticatePlugin(\n      this.getPluginInfo().id,\n      {\n        pluginId: this.getPluginInfo().id,\n        authToken: this.authContext.sessionToken,\n        timestamp: new Date(),\n        nonce: Math.random().toString(36).substring(2, 15)\n      }\n    );\n\n    if (!authResult) {\n      return {\n        success: false,\n        changeIds: [],\n        errors: ['Plugin authentication failed'],\n        warnings: []\n      };\n    }\n\n    // Validate permissions\n    const requiredPermissions = [PluginPermission.MODIFY_DOCUMENTS];\n    const permissionResult = await this.registry.validatePermissions(\n      this.getPluginInfo().id,\n      requiredPermissions\n    );\n\n    if (!permissionResult.hasPermission) {\n      return {\n        success: false,\n        changeIds: [],\n        errors: [`Missing permissions: ${permissionResult.missingPermissions.join(', ')}`],\n        warnings: []\n      };\n    }\n\n    // Create plugin-specific submission options\n    const pluginOptions: PluginSubmissionOptions = {\n      ...options,\n      pluginAuthContext: authResult,\n      pluginMetadata: {\n        pluginId: this.getPluginInfo().id,\n        pluginVersion: this.getPluginInfo().version,\n        submissionTime: new Date().toISOString(),\n        editorialEngineMode: true\n      }\n    };\n\n    // Delegate to the main Track Edits submitChangesFromAI method\n    // This would be handled by the Track Edits plugin's main method\n    // For now, return a success structure\n    return {\n      success: true,\n      changeIds: changes.map((change, index) => change.id || `editorial_${Date.now()}_${index}`),\n      errors: [],\n      warnings: [],\n      sessionId: options?.sessionId,\n      validationSummary: {\n        totalChanges: changes.length,\n        provider: aiProvider,\n        model: aiModel,\n        validationMode: 'Editorial Engine',\n        securityChecksEnabled: true\n      }\n    };\n  }\n\n  /**\n   * Validate plugin capabilities\n   */\n  async validateCapability(operation: string, context?: any): Promise<boolean> {\n    const capabilities = this.getPluginInfo().capabilities;\n    \n    // Check if operation is supported\n    if (capabilities.editorialOperations.includes(operation as EditorialOperationType)) {\n      return true;\n    }\n\n    // Check for special capabilities\n    const specialCapabilities = [\n      'conversation_context', 'real_time_processing', 'batch_processing',\n      'file_type_markdown', 'file_type_text', 'ai_provider_openai',\n      'ai_provider_anthropic', 'ai_provider_local'\n    ];\n\n    return specialCapabilities.includes(operation);\n  }\n\n  /**\n   * Clean up resources\n   */\n  async cleanup(): Promise<void> {\n    this.initialized = false;\n    this.registry = null;\n    this.authContext = null;\n    \n    console.log('[EditorialEnginePlugin] Cleanup completed');\n  }\n\n  /**\n   * Handle lifecycle events\n   */\n  async onLifecycleEvent(event: PluginLifecycleEvent, data?: any): Promise<void> {\n    switch (event) {\n      case PluginLifecycleEvent.REGISTERED:\n        console.log('[EditorialEnginePlugin] Registered successfully', data);\n        break;\n\n      case PluginLifecycleEvent.ACTIVATED:\n        console.log('[EditorialEnginePlugin] Activated');\n        break;\n\n      case PluginLifecycleEvent.DEACTIVATED:\n        console.log('[EditorialEnginePlugin] Deactivated', data?.reason || 'No reason provided');\n        break;\n\n      case PluginLifecycleEvent.SUSPENDED:\n        console.warn('[EditorialEnginePlugin] Suspended', data?.reason || 'No reason provided');\n        break;\n\n      case PluginLifecycleEvent.UPDATED:\n        console.log('[EditorialEnginePlugin] Updated', data);\n        break;\n\n      case PluginLifecycleEvent.PERMISSION_CHANGED:\n        console.log('[EditorialEnginePlugin] Permissions changed', data);\n        if (this.authContext && data?.permissions) {\n          // Update local auth context\n          this.authContext = { ...this.authContext, permissions: data.permissions };\n        }\n        break;\n\n      case PluginLifecycleEvent.ERROR:\n        console.error('[EditorialEnginePlugin] Error occurred', data);\n        // Handle error - could trigger recovery procedures\n        break;\n\n      default:\n        console.log(`[EditorialEnginePlugin] Unknown lifecycle event: ${event}`, data);\n    }\n  }\n\n  /**\n   * Get plugin performance metrics\n   */\n  getPerformanceMetrics(): any {\n    return {\n      submissionsCount: 0, // Would track actual submissions\n      successRate: 1.0,\n      averageResponseTime: 250,\n      lastSubmissionTime: null\n    };\n  }\n\n  /**\n   * Check if plugin supports specific AI provider\n   */\n  supportsAIProvider(provider: string): boolean {\n    return this.getPluginInfo().capabilities.aiProviders.includes(provider);\n  }\n\n  /**\n   * Check if plugin supports specific file type\n   */\n  supportsFileType(fileType: string): boolean {\n    return this.getPluginInfo().capabilities.supportedFileTypes.includes(fileType);\n  }\n\n  /**\n   * Get maximum batch size supported\n   */\n  getMaxBatchSize(): number {\n    return this.getPluginInfo().capabilities.maxBatchSize;\n  }\n\n  /**\n   * Check if plugin supports real-time processing\n   */\n  supportsRealTime(): boolean {\n    return this.getPluginInfo().capabilities.supportsRealTime;\n  }\n\n  /**\n   * Check if plugin supports conversation context\n   */\n  supportsConversationContext(): boolean {\n    return this.getPluginInfo().capabilities.supportsConversationContext;\n  }\n}", "/**\n * Plugin API and Registration Endpoints\n * \n * Provides public API endpoints for plugin registration, authentication,\n * and interaction with the Track Edits plugin system.\n */\n\nimport { Plugin } from 'obsidian';\nimport { \n  AIProcessingPlugin,\n  PluginPermission,\n  PluginRegistrationStatus,\n  PluginPerformanceMetrics\n} from '../types/submit-changes-from-ai';\n\nimport {\n  IAIProcessingPlugin,\n  PluginRegistrationResult,\n  PluginSecurityOptions,\n  PluginFilter,\n  IPluginRegistry\n} from './plugin-interface';\n\n/**\n * Main Plugin API class that other plugins can use to interact with Track Edits\n */\nexport class TrackEditsPluginAPI {\n  constructor(private trackEditsPlugin: any) {} // TrackEditsPlugin type\n\n  /**\n   * Register an AI processing plugin with Track Edits\n   */\n  async registerPlugin(\n    plugin: IAIProcessingPlugin,\n    securityOptions?: Partial<PluginSecurityOptions>\n  ): Promise<PluginRegistrationResult> {\n    return await this.trackEditsPlugin.registerAIProcessingPlugin(plugin, securityOptions);\n  }\n\n  /**\n   * Unregister a plugin\n   */\n  async unregisterPlugin(pluginId: string, reason?: string): Promise<boolean> {\n    return await this.trackEditsPlugin.unregisterAIProcessingPlugin(pluginId, reason);\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  getRegisteredPlugins(filter?: PluginFilter): IAIProcessingPlugin[] {\n    const allPlugins = this.trackEditsPlugin.getRegisteredPlugins();\n    \n    if (!filter) {\n      return allPlugins;\n    }\n\n    // Apply client-side filtering if registry doesn't support it\n    return allPlugins.filter(plugin => {\n      const pluginInfo = plugin.getPluginInfo();\n      \n      if (filter.status && !filter.status.includes(PluginRegistrationStatus.ACTIVE)) {\n        return false;\n      }\n      \n      if (filter.author && pluginInfo.author !== filter.author) {\n        return false;\n      }\n      \n      if (filter.capabilities) {\n        const hasCapabilities = filter.capabilities.every(cap =>\n          pluginInfo.capabilities.editorialOperations.includes(cap as any)\n        );\n        if (!hasCapabilities) return false;\n      }\n      \n      return true;\n    });\n  }\n\n  /**\n   * Get specific plugin by ID\n   */\n  getPlugin(pluginId: string): IAIProcessingPlugin | undefined {\n    return this.trackEditsPlugin.getRegisteredPlugin(pluginId);\n  }\n\n  /**\n   * Submit AI changes through Track Edits (authenticated)\n   */\n  async submitAIChanges(\n    pluginId: string,\n    changes: any[], // EditChange[]\n    aiProvider: string,\n    aiModel: string,\n    processingContext?: any, // AIProcessingContext\n    options: any = {} // SubmitChangesFromAIOptions\n  ): Promise<any> { // SubmitChangesFromAIResult\n    const plugin = this.getPlugin(pluginId);\n    if (!plugin) {\n      return {\n        success: false,\n        changeIds: [],\n        errors: ['Plugin not found or not registered'],\n        warnings: []\n      };\n    }\n\n    // Use plugin's submit method which handles authentication internally\n    return await plugin.submitChanges(changes, aiProvider, aiModel, processingContext, options);\n  }\n\n  /**\n   * Check plugin status\n   */\n  getPluginStatus(pluginId: string): PluginRegistrationStatus | null {\n    const registry = (this.trackEditsPlugin as any).pluginRegistry as IPluginRegistry | null;\n    if (!registry) return null;\n\n    // This would need to be exposed by the registry\n    return PluginRegistrationStatus.ACTIVE; // Simplified\n  }\n\n  /**\n   * Get plugin performance metrics\n   */\n  getPluginMetrics(pluginId: string): PluginPerformanceMetrics | undefined {\n    const registry = (this.trackEditsPlugin as any).pluginRegistry as IPluginRegistry | null;\n    if (!registry) return undefined;\n\n    return registry.getPluginMetrics(pluginId);\n  }\n\n  /**\n   * Validate plugin capabilities for an operation\n   */\n  async validatePluginCapability(pluginId: string, operation: string, context?: any): Promise<boolean> {\n    const plugin = this.getPlugin(pluginId);\n    if (!plugin) return false;\n\n    return await plugin.validateCapability(operation, context);\n  }\n\n  /**\n   * Get plugin information\n   */\n  getPluginInfo(pluginId: string): AIProcessingPlugin | undefined {\n    const plugin = this.getPlugin(pluginId);\n    return plugin?.getPluginInfo();\n  }\n}\n\n/**\n * Global API accessor for other plugins\n */\nexport class TrackEditsGlobalAPI {\n  private static instance: TrackEditsPluginAPI | null = null;\n\n  /**\n   * Initialize the global API\n   */\n  static initialize(trackEditsPlugin: any): void {\n    TrackEditsGlobalAPI.instance = new TrackEditsPluginAPI(trackEditsPlugin);\n    \n    // Expose on window/global for other plugins\n    if (typeof window !== 'undefined') {\n      (window as any).TrackEditsAPI = TrackEditsGlobalAPI.instance;\n    }\n    \n    if (typeof global !== 'undefined') {\n      (global as any).TrackEditsAPI = TrackEditsGlobalAPI.instance;\n    }\n  }\n\n  /**\n   * Get the global API instance\n   */\n  static getInstance(): TrackEditsPluginAPI | null {\n    return TrackEditsGlobalAPI.instance;\n  }\n\n  /**\n   * Clean up the global API\n   */\n  static cleanup(): void {\n    if (typeof window !== 'undefined') {\n      delete (window as any).TrackEditsAPI;\n    }\n    \n    if (typeof global !== 'undefined') {\n      delete (global as any).TrackEditsAPI;\n    }\n    \n    TrackEditsGlobalAPI.instance = null;\n  }\n}\n\n/**\n * Plugin registration helper for other Obsidian plugins\n */\nexport class PluginRegistrationHelper {\n  /**\n   * Easy registration method for Obsidian plugins\n   */\n  static async registerWithTrackEdits(\n    obsidianPlugin: Plugin,\n    aiProcessingPlugin: IAIProcessingPlugin,\n    options?: Partial<PluginSecurityOptions>\n  ): Promise<PluginRegistrationResult> {\n    const trackEditsAPI = TrackEditsGlobalAPI.getInstance();\n    \n    if (!trackEditsAPI) {\n      return {\n        success: false,\n        pluginId: aiProcessingPlugin.getPluginInfo().id,\n        authToken: '',\n        permissions: [],\n        errors: ['Track Edits API not available'],\n        warnings: ['Ensure Track Edits plugin is loaded and active'],\n        expiresAt: new Date()\n      };\n    }\n\n    try {\n      const result = await trackEditsAPI.registerPlugin(aiProcessingPlugin, options);\n      \n      if (result.success) {\n        // Store registration info in the Obsidian plugin for cleanup\n        (obsidianPlugin as any)._trackEditsRegistration = {\n          pluginId: result.pluginId,\n          authToken: result.authToken,\n          registrationTime: new Date()\n        };\n\n        console.log(`[${obsidianPlugin.manifest.name}] Successfully registered with Track Edits`);\n      }\n\n      return result;\n    } catch (error) {\n      return {\n        success: false,\n        pluginId: aiProcessingPlugin.getPluginInfo().id,\n        authToken: '',\n        permissions: [],\n        errors: [`Registration failed: ${error instanceof Error ? error.message : String(error)}`],\n        warnings: [],\n        expiresAt: new Date()\n      };\n    }\n  }\n\n  /**\n   * Unregister plugin during Obsidian plugin unload\n   */\n  static async unregisterFromTrackEdits(obsidianPlugin: Plugin): Promise<boolean> {\n    const trackEditsAPI = TrackEditsGlobalAPI.getInstance();\n    const registration = (obsidianPlugin as any)._trackEditsRegistration;\n    \n    if (!trackEditsAPI || !registration) {\n      return true; // Nothing to unregister\n    }\n\n    try {\n      const result = await trackEditsAPI.unregisterPlugin(\n        registration.pluginId,\n        `Obsidian plugin ${obsidianPlugin.manifest.name} unloaded`\n      );\n\n      if (result) {\n        delete (obsidianPlugin as any)._trackEditsRegistration;\n        console.log(`[${obsidianPlugin.manifest.name}] Successfully unregistered from Track Edits`);\n      }\n\n      return result;\n    } catch (error) {\n      console.error(`[${obsidianPlugin.manifest.name}] Failed to unregister from Track Edits:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Create a simple AI processing plugin wrapper for basic functionality\n   */\n  static createSimpleAIPlugin(config: {\n    id: string;\n    name: string;\n    version: string;\n    author: string;\n    description: string;\n    capabilities?: Partial<PluginCapabilities>;\n    onSubmitChanges?: (changes: any[], aiProvider: string, aiModel: string) => Promise<any>;\n  }): IAIProcessingPlugin {\n    return new SimpleAIPluginWrapper(config);\n  }\n}\n\n/**\n * Simple plugin wrapper for basic AI processing plugins\n */\nclass SimpleAIPluginWrapper implements IAIProcessingPlugin {\n  private registry: IPluginRegistry | null = null;\n  private authContext: any = null;\n\n  constructor(private config: any) {}\n\n  getPluginInfo(): AIProcessingPlugin {\n    return {\n      id: this.config.id,\n      name: this.config.name,\n      version: this.config.version,\n      author: this.config.author,\n      description: this.config.description,\n      capabilities: {\n        editorialOperations: ['replace', 'insert', 'delete'],\n        aiProviders: ['openai'],\n        maxBatchSize: 10,\n        supportsRealTime: false,\n        supportsConversationContext: false,\n        supportedFileTypes: ['markdown'],\n        requiredPermissions: [PluginPermission.MODIFY_DOCUMENTS],\n        ...this.config.capabilities\n      },\n      metadata: {\n        keywords: ['ai', 'editing'],\n        license: 'Unknown'\n      },\n      apiVersion: '1.0.0'\n    };\n  }\n\n  async initialize(registry: IPluginRegistry, authContext: any): Promise<void> {\n    this.registry = registry;\n    this.authContext = authContext;\n  }\n\n  async submitChanges(changes: any[], aiProvider: string, aiModel: string, processingContext?: any, options?: any): Promise<any> {\n    if (this.config.onSubmitChanges) {\n      return await this.config.onSubmitChanges(changes, aiProvider, aiModel);\n    }\n\n    return {\n      success: true,\n      changeIds: changes.map((_, i) => `simple_${Date.now()}_${i}`),\n      errors: [],\n      warnings: ['Using simple plugin wrapper - limited functionality']\n    };\n  }\n\n  async validateCapability(operation: string): Promise<boolean> {\n    const capabilities = this.getPluginInfo().capabilities;\n    return capabilities.editorialOperations.includes(operation as any);\n  }\n\n  async cleanup(): Promise<void> {\n    this.registry = null;\n    this.authContext = null;\n  }\n\n  async onLifecycleEvent(event: any, data?: any): Promise<void> {\n    console.log(`[${this.config.name}] Lifecycle event: ${event}`, data);\n  }\n}\n\n/**\n * Export the API initialization function for the main Track Edits plugin\n */\nexport function initializeTrackEditsPluginAPI(trackEditsPlugin: any): void {\n  TrackEditsGlobalAPI.initialize(trackEditsPlugin);\n  console.log('[TrackEditsPluginAPI] Global API initialized and available to other plugins');\n}\n\n/**\n * Export the API cleanup function\n */\nexport function cleanupTrackEditsPluginAPI(): void {\n  TrackEditsGlobalAPI.cleanup();\n  console.log('[TrackEditsPluginAPI] Global API cleaned up');\n}\n\n/**\n * Type definitions for TypeScript plugins\n */\nexport interface TrackEditsAPIInterface {\n  registerPlugin(plugin: IAIProcessingPlugin, options?: Partial<PluginSecurityOptions>): Promise<PluginRegistrationResult>;\n  unregisterPlugin(pluginId: string, reason?: string): Promise<boolean>;\n  getRegisteredPlugins(filter?: PluginFilter): IAIProcessingPlugin[];\n  getPlugin(pluginId: string): IAIProcessingPlugin | undefined;\n  submitAIChanges(pluginId: string, changes: any[], aiProvider: string, aiModel: string, processingContext?: any, options?: any): Promise<any>;\n  getPluginStatus(pluginId: string): PluginRegistrationStatus | null;\n  getPluginMetrics(pluginId: string): PluginPerformanceMetrics | undefined;\n  validatePluginCapability(pluginId: string, operation: string, context?: any): Promise<boolean>;\n  getPluginInfo(pluginId: string): AIProcessingPlugin | undefined;\n}\n\n// Augment global types for TypeScript support\ndeclare global {\n  interface Window {\n    TrackEditsAPI?: TrackEditsAPIInterface;\n  }\n  \n  var TrackEditsAPI: TrackEditsAPIInterface | undefined;\n}", "// Event persistence manager for offline change synchronization\n\nimport { WriterrlEventBusConnection } from './event-bus-integration';\n\nexport interface PersistedEvent {\n  type: string;\n  data: any;\n  timestamp: Date;\n  eventId: string;\n  retryCount?: number;\n  lastAttempt?: Date;\n}\n\nexport interface SyncResult {\n  synced: number;\n  failed: number;\n  errors: Array<{ eventId: string; error: string }>;\n}\n\nexport interface StorageStats {\n  totalEvents: number;\n  oldestEvent?: Date;\n  newestEvent?: Date;\n  eventTypes: Record<string, number>;\n  estimatedSizeKB: number;\n}\n\nexport class EventPersistenceManager {\n  private db: IDBDatabase | null = null;\n  private readonly dbName = 'WriterrlEventPersistence';\n  private readonly dbVersion = 1;\n  private readonly storeName = 'events';\n  private readonly maxRetries = 3;\n  private maxStoredEvents = 1000;\n  private eventBus: WriterrlEventBusConnection | null = null;\n\n  constructor() {\n    // Auto-cleanup every 24 hours\n    setInterval(() => {\n      this.cleanupOldEvents(7); // Keep events for 7 days\n    }, 24 * 60 * 60 * 1000);\n  }\n\n  async initialize(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.dbVersion);\n\n      request.onerror = () => {\n        reject(new Error(`Failed to open IndexedDB: ${request.error?.message}`));\n      };\n\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        \n        if (!db.objectStoreNames.contains(this.storeName)) {\n          const store = db.createObjectStore(this.storeName, { keyPath: 'eventId' });\n          store.createIndex('timestamp', 'timestamp', { unique: false });\n          store.createIndex('type', 'type', { unique: false });\n          store.createIndex('retryCount', 'retryCount', { unique: false });\n        }\n      };\n    });\n  }\n\n  setEventBus(eventBus: WriterrlEventBusConnection): void {\n    this.eventBus = eventBus;\n    \n    // Auto-sync when connection is restored\n    this.eventBus.on('connection-restored', async () => {\n      if (this.eventBus?.isConnected) {\n        await this.syncPendingEvents(this.eventBus);\n      }\n    });\n  }\n\n  setMaxStoredEvents(max: number): void {\n    this.maxStoredEvents = max;\n  }\n\n  async storeEvent(event: PersistedEvent): Promise<void> {\n    if (!this.db) {\n      throw new Error('EventPersistenceManager not initialized');\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName], 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n\n      const eventWithDefaults = {\n        ...event,\n        retryCount: event.retryCount || 0,\n        timestamp: event.timestamp instanceof Date ? event.timestamp : new Date(event.timestamp)\n      };\n\n      const request = store.add(eventWithDefaults);\n\n      request.onsuccess = async () => {\n        // Enforce storage limits\n        await this.enforceStorageLimits();\n        resolve();\n      };\n\n      request.onerror = () => {\n        reject(new Error(`Failed to store event: ${request.error?.message}`));\n      };\n\n      transaction.onerror = () => {\n        reject(new Error(`Transaction failed: ${transaction.error?.message}`));\n      };\n    });\n  }\n\n  async getPendingEvents(): Promise<PersistedEvent[]> {\n    if (!this.db) {\n      throw new Error('EventPersistenceManager not initialized');\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName], 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.getAll();\n\n      request.onsuccess = () => {\n        const events = request.result as PersistedEvent[];\n        // Sort by timestamp to ensure correct order during sync\n        events.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n        resolve(events);\n      };\n\n      request.onerror = () => {\n        reject(new Error(`Failed to retrieve events: ${request.error?.message}`));\n      };\n    });\n  }\n\n  async syncPendingEvents(eventBus: WriterrlEventBusConnection): Promise<SyncResult> {\n    const pendingEvents = await this.getPendingEvents();\n    const result: SyncResult = {\n      synced: 0,\n      failed: 0,\n      errors: []\n    };\n\n    if (!eventBus.isConnected) {\n      throw new Error('Cannot sync: event bus not connected');\n    }\n\n    for (const event of pendingEvents) {\n      try {\n        // Skip events that have exceeded retry limit\n        if (event.retryCount! >= this.maxRetries) {\n          await this.removeEvent(event.eventId);\n          continue;\n        }\n\n        await eventBus.publish(event.type, event.data);\n        await this.removeEvent(event.eventId);\n        result.synced++;\n        \n      } catch (error) {\n        result.failed++;\n        result.errors.push({\n          eventId: event.eventId,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        });\n\n        // Update retry count\n        await this.updateEventRetryCount(event.eventId, event.retryCount! + 1);\n      }\n    }\n\n    return result;\n  }\n\n  async removeEvent(eventId: string): Promise<void> {\n    if (!this.db) {\n      throw new Error('EventPersistenceManager not initialized');\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName], 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.delete(eventId);\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => {\n        reject(new Error(`Failed to remove event: ${request.error?.message}`));\n      };\n    });\n  }\n\n  async updateEventRetryCount(eventId: string, retryCount: number): Promise<void> {\n    if (!this.db) {\n      throw new Error('EventPersistenceManager not initialized');\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName], 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      \n      const getRequest = store.get(eventId);\n      getRequest.onsuccess = () => {\n        const event = getRequest.result;\n        if (event) {\n          event.retryCount = retryCount;\n          event.lastAttempt = new Date();\n          \n          const putRequest = store.put(event);\n          putRequest.onsuccess = () => resolve();\n          putRequest.onerror = () => {\n            reject(new Error(`Failed to update retry count: ${putRequest.error?.message}`));\n          };\n        } else {\n          resolve(); // Event doesn't exist anymore\n        }\n      };\n\n      getRequest.onerror = () => {\n        reject(new Error(`Failed to get event for update: ${getRequest.error?.message}`));\n      };\n    });\n  }\n\n  async cleanupOldEvents(maxAgeDays: number): Promise<number> {\n    if (!this.db) {\n      throw new Error('EventPersistenceManager not initialized');\n    }\n\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName], 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const index = store.index('timestamp');\n      \n      const range = IDBKeyRange.upperBound(cutoffDate);\n      const request = index.openCursor(range);\n      let deletedCount = 0;\n\n      request.onsuccess = (event) => {\n        const cursor = (event.target as IDBRequest<IDBCursorWithValue>).result;\n        if (cursor) {\n          cursor.delete();\n          deletedCount++;\n          cursor.continue();\n        } else {\n          resolve(deletedCount);\n        }\n      };\n\n      request.onerror = () => {\n        reject(new Error(`Failed to cleanup old events: ${request.error?.message}`));\n      };\n    });\n  }\n\n  async clearAllEvents(): Promise<void> {\n    if (!this.db) {\n      throw new Error('EventPersistenceManager not initialized');\n    }\n\n    return new Promise((resolve, reject) => {\n      const transaction = this.db!.transaction([this.storeName], 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.clear();\n\n      request.onsuccess = () => resolve();\n      request.onerror = () => {\n        reject(new Error(`Failed to clear events: ${request.error?.message}`));\n      };\n    });\n  }\n\n  async getStorageStats(): Promise<StorageStats> {\n    const events = await this.getPendingEvents();\n    \n    if (events.length === 0) {\n      return {\n        totalEvents: 0,\n        eventTypes: {},\n        estimatedSizeKB: 0\n      };\n    }\n\n    const eventTypes: Record<string, number> = {};\n    let totalSizeEstimate = 0;\n\n    for (const event of events) {\n      eventTypes[event.type] = (eventTypes[event.type] || 0) + 1;\n      \n      // Rough size estimate (JSON serialized size)\n      totalSizeEstimate += JSON.stringify(event).length;\n    }\n\n    const timestamps = events.map(e => new Date(e.timestamp));\n    const oldestEvent = new Date(Math.min(...timestamps.map(d => d.getTime())));\n    const newestEvent = new Date(Math.max(...timestamps.map(d => d.getTime())));\n\n    return {\n      totalEvents: events.length,\n      oldestEvent,\n      newestEvent,\n      eventTypes,\n      estimatedSizeKB: Math.round(totalSizeEstimate / 1024)\n    };\n  }\n\n  private async enforceStorageLimits(): Promise<void> {\n    const events = await this.getPendingEvents();\n    \n    if (events.length <= this.maxStoredEvents) {\n      return;\n    }\n\n    // Remove oldest events beyond the limit\n    const eventsToRemove = events\n      .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())\n      .slice(0, events.length - this.maxStoredEvents);\n\n    for (const event of eventsToRemove) {\n      await this.removeEvent(event.eventId);\n    }\n  }\n\n  async isStorageAvailable(): Promise<boolean> {\n    try {\n      if (!this.db) {\n        await this.initialize();\n      }\n      return true;\n    } catch (error) {\n      console.warn('Event persistence storage unavailable:', error);\n      return false;\n    }\n  }\n\n  // Graceful degradation - store in memory if IndexedDB fails\n  private memoryFallback: Map<string, PersistedEvent> = new Map();\n\n  async storeEventSafe(event: PersistedEvent): Promise<void> {\n    try {\n      await this.storeEvent(event);\n    } catch (error) {\n      console.warn('Falling back to memory storage:', error);\n      this.memoryFallback.set(event.eventId, event);\n      \n      // Limit memory storage to prevent memory leaks\n      if (this.memoryFallback.size > 100) {\n        const oldestKey = this.memoryFallback.keys().next().value;\n        this.memoryFallback.delete(oldestKey);\n      }\n    }\n  }\n\n  async getPendingEventsSafe(): Promise<PersistedEvent[]> {\n    try {\n      return await this.getPendingEvents();\n    } catch (error) {\n      console.warn('Using memory fallback for pending events:', error);\n      return Array.from(this.memoryFallback.values());\n    }\n  }\n}"],
  "mappings": "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",
  "names": ["LoopType", "LoopSeverity", "PreventionAction", "config", "EventPriority", "EventPersistence", "config", "EnhancedEventFilteringSystem", "ErrorType", "ErrorCategory", "ErrorSeverity", "RollbackType", "error", "config", "config", "config", "config", "OperationPriority", "ConflictResolutionCapability", "ConflictType", "ConflictSeverity", "ConflictResolutionStrategy", "ConsolidationEventType", "ConsolidationPerformanceMonitor", "ConsolidationErrorManager", "ConflictDetectionEngine", "ChangeMergingEngine", "ConflictType", "ResolutionStrategy", "import_obsidian", "_a", "import_obsidian", "import_obsidian", "import_obsidian", "config", "PluginPermission", "generateId", "generateId", "config", "_a", "config", "AISubmissionErrorManager", "RetryRecoveryManager", "ChangeConsolidationManager", "session", "WriterrlEventFactory", "EventPriority", "EventPersistence", "STANDARD_EVENT_ROUTING", "WorkflowOrchestrator", "WriterrlWorkflowPatterns"]
}
