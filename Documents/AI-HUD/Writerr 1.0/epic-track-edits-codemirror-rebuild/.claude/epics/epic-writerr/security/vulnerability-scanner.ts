/**
 * @fileoverview Security vulnerability scanner for Writerr ecosystem
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { InputSanitizer } from '../packages/shared/src/security/InputSanitizer';

export interface VulnerabilityReport {
  summary: {
    totalFiles: number;
    vulnerableFiles: number;
    totalVulnerabilities: number;
    criticalVulnerabilities: number;
    highVulnerabilities: number;
    mediumVulnerabilities: number;
    lowVulnerabilities: number;
  };
  vulnerabilities: Vulnerability[];
  recommendations: string[];
  fixableIssues: number;
  scanDuration: number;
}

export interface Vulnerability {
  id: string;
  type: VulnerabilityType;
  severity: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  description: string;
  file: string;
  line?: number;
  column?: number;
  evidence: string;
  cwe?: string; // Common Weakness Enumeration ID
  cvss?: number; // Common Vulnerability Scoring System
  impact: string;
  remediation: string;
  autoFixable: boolean;
  references: string[];
}

export enum VulnerabilityType {
  CODE_INJECTION = 'code-injection',
  SCRIPT_INJECTION = 'script-injection',
  TEMPLATE_INJECTION = 'template-injection',
  SQL_INJECTION = 'sql-injection',
  COMMAND_INJECTION = 'command-injection',
  PATH_TRAVERSAL = 'path-traversal',
  XSS = 'cross-site-scripting',
  CSRF = 'cross-site-request-forgery',
  INSECURE_DESERIALIZATION = 'insecure-deserialization',
  SENSITIVE_DATA_EXPOSURE = 'sensitive-data-exposure',
  BROKEN_ACCESS_CONTROL = 'broken-access-control',
  SECURITY_MISCONFIGURATION = 'security-misconfiguration',
  VULNERABLE_DEPENDENCIES = 'vulnerable-dependencies',
  INSUFFICIENT_LOGGING = 'insufficient-logging',
  WEAK_CRYPTOGRAPHY = 'weak-cryptography'
}

export class VulnerabilityScanner {
  private scanRules: ScanRule[] = [];
  private packagePath: string;

  constructor(packagePath: string) {
    this.packagePath = packagePath;
    this.initializeScanRules();
  }

  /**
   * Run comprehensive vulnerability scan
   */
  async scanProject(): Promise<VulnerabilityReport> {
    const startTime = Date.now();
    const vulnerabilities: Vulnerability[] = [];
    
    console.log('Starting Writerr security vulnerability scan...');

    try {
      // Scan source code files
      const sourceFiles = await this.findSourceFiles();
      console.log(`Scanning ${sourceFiles.length} source files...`);

      for (const file of sourceFiles) {
        const fileVulnerabilities = await this.scanFile(file);
        vulnerabilities.push(...fileVulnerabilities);
      }

      // Scan configuration files
      const configVulnerabilities = await this.scanConfigurations();
      vulnerabilities.push(...configVulnerabilities);

      // Scan dependencies
      const dependencyVulnerabilities = await this.scanDependencies();
      vulnerabilities.push(...dependencyVulnerabilities);

      // Generate report
      const report = this.generateReport(vulnerabilities, sourceFiles.length, Date.now() - startTime);
      
      console.log(`Scan completed: ${vulnerabilities.length} vulnerabilities found`);
      return report;

    } catch (error) {
      console.error('Vulnerability scan failed:', error);
      throw error;
    }
  }

  /**
   * Initialize vulnerability scanning rules
   */
  private initializeScanRules(): void {
    this.scanRules = [
      // Code injection vulnerabilities
      {
        id: 'code-injection-eval',
        type: VulnerabilityType.CODE_INJECTION,
        severity: 'critical',
        pattern: /\beval\s*\(/gi,
        title: 'Use of eval() function',
        description: 'The eval() function executes arbitrary code and is extremely dangerous',
        cwe: 'CWE-94',
        cvss: 9.8,
        remediation: 'Remove eval() usage and use safer alternatives like JSON.parse() or proper parsing',
        autoFixable: false
      },
      {
        id: 'code-injection-function',
        type: VulnerabilityType.CODE_INJECTION,
        severity: 'high',
        pattern: /new\s+Function\s*\(/gi,
        title: 'Dynamic function creation',
        description: 'Creating functions from strings can lead to code injection',
        cwe: 'CWE-94',
        cvss: 8.5,
        remediation: 'Avoid dynamic function creation or properly sanitize inputs',
        autoFixable: false
      },
      {
        id: 'code-injection-settimeout',
        type: VulnerabilityType.CODE_INJECTION,
        severity: 'medium',
        pattern: /setTimeout\s*\(\s*['"`][^'"`]*['"`]/gi,
        title: 'setTimeout with string argument',
        description: 'Using setTimeout with string arguments can execute arbitrary code',
        cwe: 'CWE-94',
        cvss: 6.5,
        remediation: 'Use function references instead of string arguments',
        autoFixable: true
      },

      // Template injection
      {
        id: 'template-injection-unsafe',
        type: VulnerabilityType.TEMPLATE_INJECTION,
        severity: 'high',
        pattern: /\{\{\s*constructor\s*\}\}/gi,
        title: 'Unsafe template expression',
        description: 'Template expressions accessing constructor can lead to code execution',
        cwe: 'CWE-94',
        cvss: 8.0,
        remediation: 'Sanitize template inputs and use safe template expressions',
        autoFixable: false
      },
      {
        id: 'template-injection-proto',
        type: VulnerabilityType.TEMPLATE_INJECTION,
        severity: 'critical',
        pattern: /\{\{\s*__proto__\s*\}\}/gi,
        title: 'Prototype pollution in templates',
        description: 'Accessing __proto__ in templates can lead to prototype pollution',
        cwe: 'CWE-1321',
        cvss: 9.0,
        remediation: 'Remove __proto__ access and sanitize template variables',
        autoFixable: false
      },

      // XSS vulnerabilities
      {
        id: 'xss-innerhtml',
        type: VulnerabilityType.XSS,
        severity: 'high',
        pattern: /\.innerHTML\s*=\s*[^;]+/gi,
        title: 'Unsafe innerHTML assignment',
        description: 'Direct innerHTML assignment can lead to XSS vulnerabilities',
        cwe: 'CWE-79',
        cvss: 7.5,
        remediation: 'Use textContent or properly sanitize HTML before assignment',
        autoFixable: false
      },
      {
        id: 'xss-document-write',
        type: VulnerabilityType.XSS,
        severity: 'high',
        pattern: /document\.write\s*\(/gi,
        title: 'Use of document.write',
        description: 'document.write can introduce XSS vulnerabilities',
        cwe: 'CWE-79',
        cvss: 7.0,
        remediation: 'Use safer DOM manipulation methods',
        autoFixable: false
      },

      // Command injection
      {
        id: 'command-injection-exec',
        type: VulnerabilityType.COMMAND_INJECTION,
        severity: 'critical',
        pattern: /require\s*\(\s*['"`]child_process['"`]\s*\)\.exec/gi,
        title: 'Command execution vulnerability',
        description: 'Using child_process.exec with user input can lead to command injection',
        cwe: 'CWE-78',
        cvss: 9.5,
        remediation: 'Use safer alternatives like execFile with proper input validation',
        autoFixable: false
      },

      // Path traversal
      {
        id: 'path-traversal-dots',
        type: VulnerabilityType.PATH_TRAVERSAL,
        severity: 'medium',
        pattern: /\.\.\//gi,
        title: 'Potential path traversal',
        description: 'Path traversal sequences detected',
        cwe: 'CWE-22',
        cvss: 6.0,
        remediation: 'Validate and sanitize file paths before use',
        autoFixable: false
      },

      // Sensitive data exposure
      {
        id: 'sensitive-api-key',
        type: VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
        severity: 'critical',
        pattern: /(?:api[_-]?key|secret|token)\s*[:=]\s*['"`][A-Za-z0-9\-_]{32,}['"`]/gi,
        title: 'Hard-coded API key or secret',
        description: 'API keys or secrets found in source code',
        cwe: 'CWE-798',
        cvss: 9.0,
        remediation: 'Move secrets to environment variables or secure configuration',
        autoFixable: false
      },
      {
        id: 'sensitive-password',
        type: VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
        severity: 'high',
        pattern: /(?:password|passwd|pwd)\s*[:=]\s*['"`][^'"`]{6,}['"`]/gi,
        title: 'Hard-coded password',
        description: 'Password found in source code',
        cwe: 'CWE-798',
        cvss: 8.0,
        remediation: 'Remove hard-coded passwords and use secure authentication',
        autoFixable: false
      },

      // Insecure deserialization
      {
        id: 'insecure-deserialize-json',
        type: VulnerabilityType.INSECURE_DESERIALIZATION,
        severity: 'medium',
        pattern: /JSON\.parse\s*\(\s*[^)]*user|request|input[^)]*\)/gi,
        title: 'Unsafe JSON deserialization',
        description: 'Parsing JSON from user input without validation',
        cwe: 'CWE-502',
        cvss: 5.5,
        remediation: 'Validate JSON structure and content before parsing',
        autoFixable: false
      },

      // Weak cryptography
      {
        id: 'weak-crypto-md5',
        type: VulnerabilityType.WEAK_CRYPTOGRAPHY,
        severity: 'medium',
        pattern: /crypto\.createHash\s*\(\s*['"`]md5['"`]\s*\)/gi,
        title: 'Weak cryptographic hash (MD5)',
        description: 'MD5 is cryptographically weak and should not be used',
        cwe: 'CWE-327',
        cvss: 5.0,
        remediation: 'Use SHA-256 or stronger hash algorithms',
        autoFixable: true
      },
      {
        id: 'weak-crypto-sha1',
        type: VulnerabilityType.WEAK_CRYPTOGRAPHY,
        severity: 'low',
        pattern: /crypto\.createHash\s*\(\s*['"`]sha1['"`]\s*\)/gi,
        title: 'Weak cryptographic hash (SHA1)',
        description: 'SHA1 is considered weak for cryptographic purposes',
        cwe: 'CWE-327',
        cvss: 3.5,
        remediation: 'Use SHA-256 or stronger hash algorithms',
        autoFixable: true
      },

      // Security misconfigurations
      {
        id: 'security-debug-mode',
        type: VulnerabilityType.SECURITY_MISCONFIGURATION,
        severity: 'medium',
        pattern: /debug\s*[:=]\s*true/gi,
        title: 'Debug mode enabled',
        description: 'Debug mode should not be enabled in production',
        cwe: 'CWE-489',
        cvss: 4.5,
        remediation: 'Disable debug mode in production configurations',
        autoFixable: true
      },

      // Insufficient logging
      {
        id: 'insufficient-logging-error',
        type: VulnerabilityType.INSUFFICIENT_LOGGING,
        severity: 'low',
        pattern: /catch\s*\([^}]*\}\s*$/gm,
        title: 'Empty catch block',
        description: 'Errors should be logged for security monitoring',
        cwe: 'CWE-778',
        cvss: 2.5,
        remediation: 'Add proper error logging in catch blocks',
        autoFixable: true
      }
    ];
  }

  /**
   * Find all source files to scan
   */
  private async findSourceFiles(): Promise<string[]> {
    const files: string[] = [];
    const extensions = ['.ts', '.js', '.tsx', '.jsx', '.json', '.yml', '.yaml'];
    
    async function findFiles(dir: string): Promise<void> {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {
          await findFiles(fullPath);
        } else if (entry.isFile() && extensions.some(ext => entry.name.endsWith(ext))) {
          files.push(fullPath);
        }
      }
    }

    await findFiles(this.packagePath);
    return files;
  }

  /**
   * Scan individual file for vulnerabilities
   */
  private async scanFile(filePath: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const lines = content.split('\n');

      // Apply each scan rule to the file
      for (const rule of this.scanRules) {
        const matches = content.matchAll(rule.pattern);
        
        for (const match of matches) {
          const lineNumber = this.getLineNumber(content, match.index || 0);
          const line = lines[lineNumber - 1] || '';
          
          vulnerabilities.push({
            id: `${rule.id}-${path.basename(filePath)}-${lineNumber}`,
            type: rule.type,
            severity: rule.severity,
            title: rule.title,
            description: rule.description,
            file: path.relative(this.packagePath, filePath),
            line: lineNumber,
            column: this.getColumnNumber(content, match.index || 0),
            evidence: line.trim(),
            cwe: rule.cwe,
            cvss: rule.cvss,
            impact: this.calculateImpact(rule.severity, rule.cvss || 0),
            remediation: rule.remediation,
            autoFixable: rule.autoFixable,
            references: this.getReferences(rule.cwe)
          });
        }
      }

      // Additional context-specific checks
      if (filePath.includes('security')) {
        vulnerabilities.push(...await this.scanSecurityModule(filePath, content));
      }
      if (filePath.includes('config')) {
        vulnerabilities.push(...await this.scanConfigFile(filePath, content));
      }

    } catch (error) {
      console.warn(`Failed to scan file ${filePath}:`, error);
    }

    return vulnerabilities;
  }

  /**
   * Scan configuration files for security issues
   */
  private async scanConfigurations(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check for common configuration files
    const configFiles = [
      'package.json',
      'tsconfig.json',
      '.eslintrc.json',
      'deployment/*.yml',
      'deployment/*.yaml'
    ];

    for (const pattern of configFiles) {
      const files = await this.findFilesByPattern(pattern);
      
      for (const file of files) {
        try {
          const content = await fs.readFile(file, 'utf-8');
          
          // Check for insecure configurations
          if (file.endsWith('.json')) {
            const config = JSON.parse(content);
            vulnerabilities.push(...this.checkJSONSecurity(file, config));
          }
          
          if (file.endsWith('.yml') || file.endsWith('.yaml')) {
            vulnerabilities.push(...this.checkYAMLSecurity(file, content));
          }
          
        } catch (error) {
          console.warn(`Failed to scan config file ${file}:`, error);
        }
      }
    }

    return vulnerabilities;
  }

  /**
   * Scan dependencies for known vulnerabilities
   */
  private async scanDependencies(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      const packageJsonPath = path.join(this.packagePath, 'package.json');
      const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));
      
      const allDependencies = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies
      };

      // Check for known vulnerable packages
      const vulnerablePackages = this.getKnownVulnerablePackages();
      
      for (const [packageName, version] of Object.entries(allDependencies)) {
        const vulnerableVersion = vulnerablePackages[packageName];
        
        if (vulnerableVersion && this.isVulnerableVersion(version as string, vulnerableVersion)) {
          vulnerabilities.push({
            id: `vulnerable-dep-${packageName}`,
            type: VulnerabilityType.VULNERABLE_DEPENDENCIES,
            severity: 'high',
            title: `Vulnerable dependency: ${packageName}`,
            description: `Package ${packageName}@${version} has known security vulnerabilities`,
            file: 'package.json',
            evidence: `"${packageName}": "${version}"`,
            cwe: 'CWE-1035',
            cvss: 7.5,
            impact: 'May allow attackers to exploit known vulnerabilities in dependencies',
            remediation: `Update ${packageName} to version ${vulnerableVersion.fixedIn || 'latest'}`,
            autoFixable: true,
            references: [`https://www.npmjs.com/package/${packageName}`]
          });
        }
      }
      
    } catch (error) {
      console.warn('Failed to scan dependencies:', error);
    }

    return vulnerabilities;
  }

  /**
   * Scan security-specific modules
   */
  private async scanSecurityModule(filePath: string, content: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check for proper input sanitization usage
    if (!content.includes('InputSanitizer.sanitize')) {
      vulnerabilities.push({
        id: `missing-sanitization-${path.basename(filePath)}`,
        type: VulnerabilityType.SECURITY_MISCONFIGURATION,
        severity: 'medium',
        title: 'Missing input sanitization',
        description: 'Security module should use InputSanitizer for all user inputs',
        file: path.relative(this.packagePath, filePath),
        evidence: 'No InputSanitizer.sanitize() calls found',
        cwe: 'CWE-20',
        cvss: 5.0,
        impact: 'Unsanitized inputs may lead to injection vulnerabilities',
        remediation: 'Add InputSanitizer.sanitize() calls for all user inputs',
        autoFixable: false,
        references: ['https://owasp.org/www-community/Input_Validation_and_Sanitization']
      });
    }

    // Check for proper error handling in security contexts
    const errorHandlingPattern = /try\s*\{[^}]*security[^}]*\}\s*catch\s*\([^}]*\)/gi;
    if (content.includes('security') && !errorHandlingPattern.test(content)) {
      vulnerabilities.push({
        id: `missing-error-handling-${path.basename(filePath)}`,
        type: VulnerabilityType.INSUFFICIENT_LOGGING,
        severity: 'low',
        title: 'Missing security error handling',
        description: 'Security operations should have proper error handling',
        file: path.relative(this.packagePath, filePath),
        evidence: 'Security operations without try-catch blocks',
        cwe: 'CWE-754',
        cvss: 3.0,
        impact: 'Security errors may not be properly logged or handled',
        remediation: 'Add comprehensive error handling for security operations',
        autoFixable: false,
        references: ['https://owasp.org/www-community/Improper_Error_Handling']
      });
    }

    return vulnerabilities;
  }

  /**
   * Check JSON configuration security
   */
  private checkJSONSecurity(filePath: string, config: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    
    // Check for debug mode in production
    if (config.debug === true || config.DEBUG === true) {
      vulnerabilities.push({
        id: `debug-enabled-${path.basename(filePath)}`,
        type: VulnerabilityType.SECURITY_MISCONFIGURATION,
        severity: 'medium',
        title: 'Debug mode enabled in configuration',
        description: 'Debug mode should be disabled in production',
        file: path.relative(this.packagePath, filePath),
        evidence: JSON.stringify({ debug: config.debug || config.DEBUG }),
        cwe: 'CWE-489',
        cvss: 4.5,
        impact: 'Debug information may be exposed to attackers',
        remediation: 'Set debug to false in production configurations',
        autoFixable: true,
        references: ['https://owasp.org/www-community/vulnerabilities/Information_exposure_through_debug_information']
      });
    }

    // Check for insecure scripts in package.json
    if (config.scripts) {
      for (const [scriptName, scriptCommand] of Object.entries(config.scripts)) {
        if (typeof scriptCommand === 'string' && scriptCommand.includes('--ignore-scripts')) {
          vulnerabilities.push({
            id: `insecure-script-${scriptName}`,
            type: VulnerabilityType.SECURITY_MISCONFIGURATION,
            severity: 'medium',
            title: 'Insecure npm script configuration',
            description: 'Using --ignore-scripts can bypass security checks',
            file: path.relative(this.packagePath, filePath),
            evidence: `"${scriptName}": "${scriptCommand}"`,
            cwe: 'CWE-693',
            cvss: 5.0,
            impact: 'Security scripts may be bypassed during installation',
            remediation: 'Remove --ignore-scripts flag or ensure proper security validation',
            autoFixable: false,
            references: ['https://docs.npmjs.com/cli/v8/using-npm/scripts#security']
          });
        }
      }
    }

    return vulnerabilities;
  }

  /**
   * Check YAML configuration security
   */
  private checkYAMLSecurity(filePath: string, content: string): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];
    
    // Use InputSanitizer to check for YAML injection
    const validation = InputSanitizer.sanitize(content, { contextType: 'yaml' });
    
    validation.violations.forEach(violation => {
      vulnerabilities.push({
        id: `yaml-security-${path.basename(filePath)}-${Date.now()}`,
        type: VulnerabilityType.TEMPLATE_INJECTION,
        severity: violation.severity,
        title: 'YAML security violation',
        description: violation.description,
        file: path.relative(this.packagePath, filePath),
        evidence: violation.originalValue,
        cwe: 'CWE-94',
        cvss: violation.severity === 'critical' ? 9.0 : 6.0,
        impact: 'YAML injection may lead to code execution',
        remediation: 'Use safe YAML parsing and avoid dangerous constructs',
        autoFixable: false,
        references: ['https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data']
      });
    });

    return vulnerabilities;
  }

  /**
   * Get line number from character index
   */
  private getLineNumber(content: string, index: number): number {
    return content.substring(0, index).split('\n').length;
  }

  /**
   * Get column number from character index
   */
  private getColumnNumber(content: string, index: number): number {
    const lines = content.substring(0, index).split('\n');
    return lines[lines.length - 1].length + 1;
  }

  /**
   * Calculate impact description based on severity and CVSS
   */
  private calculateImpact(severity: string, cvss: number): string {
    if (severity === 'critical' || cvss >= 9.0) {
      return 'Critical security vulnerability that could lead to complete system compromise';
    } else if (severity === 'high' || cvss >= 7.0) {
      return 'High severity vulnerability that could allow significant unauthorized access';
    } else if (severity === 'medium' || cvss >= 4.0) {
      return 'Medium severity vulnerability that may lead to limited security impact';
    } else {
      return 'Low severity vulnerability with minimal security impact';
    }
  }

  /**
   * Get security references for CWE
   */
  private getReferences(cwe?: string): string[] {
    const references = ['https://owasp.org/www-project-top-ten/'];
    
    if (cwe) {
      references.push(`https://cwe.mitre.org/data/definitions/${cwe.replace('CWE-', '')}.html`);
    }
    
    return references;
  }

  /**
   * Find files by glob pattern
   */
  private async findFilesByPattern(pattern: string): Promise<string[]> {
    // Simple implementation - in production use a proper glob library
    const files: string[] = [];
    
    if (pattern.includes('*')) {
      // Handle glob patterns
      const baseDir = pattern.split('*')[0];
      const extension = pattern.split('*').pop();
      
      try {
        const entries = await fs.readdir(path.join(this.packagePath, baseDir), { withFileTypes: true });
        for (const entry of entries) {
          if (entry.isFile() && entry.name.endsWith(extension || '')) {
            files.push(path.join(this.packagePath, baseDir, entry.name));
          }
        }
      } catch {
        // Directory doesn't exist
      }
    } else {
      // Direct file path
      const filePath = path.join(this.packagePath, pattern);
      try {
        await fs.access(filePath);
        files.push(filePath);
      } catch {
        // File doesn't exist
      }
    }
    
    return files;
  }

  /**
   * Get known vulnerable packages (simplified - in production use vulnerability database)
   */
  private getKnownVulnerablePackages(): Record<string, any> {
    return {
      'lodash': {
        version: '<4.17.21',
        fixedIn: '4.17.21',
        cve: 'CVE-2021-23337'
      },
      'minimist': {
        version: '<1.2.6',
        fixedIn: '1.2.6',
        cve: 'CVE-2021-44906'
      },
      'qs': {
        version: '<6.11.0',
        fixedIn: '6.11.0',
        cve: 'CVE-2022-24999'
      }
    };
  }

  /**
   * Check if version is vulnerable
   */
  private isVulnerableVersion(current: string, vulnerable: any): boolean {
    // Simplified version comparison - in production use semver library
    return current.includes(vulnerable.version.replace('<', ''));
  }

  /**
   * Generate vulnerability report
   */
  private generateReport(
    vulnerabilities: Vulnerability[], 
    totalFiles: number, 
    scanDuration: number
  ): VulnerabilityReport {
    const summary = {
      totalFiles,
      vulnerableFiles: new Set(vulnerabilities.map(v => v.file)).size,
      totalVulnerabilities: vulnerabilities.length,
      criticalVulnerabilities: vulnerabilities.filter(v => v.severity === 'critical').length,
      highVulnerabilities: vulnerabilities.filter(v => v.severity === 'high').length,
      mediumVulnerabilities: vulnerabilities.filter(v => v.severity === 'medium').length,
      lowVulnerabilities: vulnerabilities.filter(v => v.severity === 'low').length
    };

    const recommendations = this.generateRecommendations(vulnerabilities);
    const fixableIssues = vulnerabilities.filter(v => v.autoFixable).length;

    return {
      summary,
      vulnerabilities: vulnerabilities.sort((a, b) => {
        const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
        return severityOrder[b.severity] - severityOrder[a.severity];
      }),
      recommendations,
      fixableIssues,
      scanDuration
    };
  }

  /**
   * Generate security recommendations
   */
  private generateRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations = new Set<string>();
    
    const hasCodeInjection = vulnerabilities.some(v => v.type === VulnerabilityType.CODE_INJECTION);
    const hasXSS = vulnerabilities.some(v => v.type === VulnerabilityType.XSS);
    const hasSensitiveData = vulnerabilities.some(v => v.type === VulnerabilityType.SENSITIVE_DATA_EXPOSURE);
    const hasVulnerableDeps = vulnerabilities.some(v => v.type === VulnerabilityType.VULNERABLE_DEPENDENCIES);
    const hasMisconfig = vulnerabilities.some(v => v.type === VulnerabilityType.SECURITY_MISCONFIGURATION);
    
    if (hasCodeInjection) {
      recommendations.add('Implement comprehensive input validation and sanitization');
      recommendations.add('Use parameterized queries and avoid dynamic code execution');
      recommendations.add('Enable Content Security Policy (CSP) headers');
    }
    
    if (hasXSS) {
      recommendations.add('Sanitize all user inputs before displaying');
      recommendations.add('Use safe DOM manipulation methods');
      recommendations.add('Implement output encoding for different contexts');
    }
    
    if (hasSensitiveData) {
      recommendations.add('Move all secrets to environment variables');
      recommendations.add('Implement proper secrets management');
      recommendations.add('Enable sensitive data detection in CI/CD pipeline');
    }
    
    if (hasVulnerableDeps) {
      recommendations.add('Regularly update dependencies to latest versions');
      recommendations.add('Use automated vulnerability scanning for dependencies');
      recommendations.add('Implement dependency pinning and review processes');
    }
    
    if (hasMisconfig) {
      recommendations.add('Review and harden all configuration files');
      recommendations.add('Disable debug mode in production environments');
      recommendations.add('Implement configuration validation and testing');
    }
    
    // General recommendations
    recommendations.add('Implement comprehensive security testing in CI/CD');
    recommendations.add('Regular security audits and penetration testing');
    recommendations.add('Security training for development team');
    recommendations.add('Implement security monitoring and alerting');
    
    return Array.from(recommendations);
  }

  /**
   * Generate formatted security report
   */
  generateFormattedReport(report: VulnerabilityReport): string {
    const { summary, vulnerabilities, recommendations, fixableIssues, scanDuration } = report;
    
    return `# Writerr Security Vulnerability Report

## Executive Summary
- **Scan Duration**: ${(scanDuration / 1000).toFixed(2)} seconds
- **Files Scanned**: ${summary.totalFiles}
- **Vulnerable Files**: ${summary.vulnerableFiles}
- **Total Vulnerabilities**: ${summary.totalVulnerabilities}
- **Auto-Fixable Issues**: ${fixableIssues}

## Severity Breakdown
- **Critical**: ${summary.criticalVulnerabilities} ${this.getSeverityEmoji('critical')}
- **High**: ${summary.highVulnerabilities} ${this.getSeverityEmoji('high')}
- **Medium**: ${summary.mediumVulnerabilities} ${this.getSeverityEmoji('medium')}
- **Low**: ${summary.lowVulnerabilities} ${this.getSeverityEmoji('low')}

## Risk Assessment
${this.generateRiskAssessment(summary)}

## Top Vulnerabilities
${vulnerabilities.slice(0, 10).map((vuln, index) => `
### ${index + 1}. ${vuln.title} (${vuln.severity.toUpperCase()})
- **File**: \`${vuln.file}${vuln.line ? `:${vuln.line}` : ''}\`
- **Type**: ${vuln.type}
- **CWE**: ${vuln.cwe || 'N/A'}
- **CVSS**: ${vuln.cvss || 'N/A'}
- **Auto-Fixable**: ${vuln.autoFixable ? 'Yes' : 'No'}

**Description**: ${vuln.description}

**Impact**: ${vuln.impact}

**Evidence**: 
\`\`\`
${vuln.evidence}
\`\`\`

**Remediation**: ${vuln.remediation}
`).join('\n')}

## Security Recommendations

${recommendations.map((rec, index) => `${index + 1}. ${rec}`).join('\n')}

## Vulnerability Types Distribution
${this.generateTypeDistribution(vulnerabilities)}

## Files Requiring Immediate Attention
${this.getHighRiskFiles(vulnerabilities)}

---

**Report Generated**: ${new Date().toISOString()}  
**Scanner Version**: Writerr Security Scanner v1.0  
**Next Scan Recommended**: ${new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toLocaleDateString()}
`;
  }

  private getSeverityEmoji(severity: string): string {
    const emojis = {
      critical: '🔴',
      high: '🟠', 
      medium: '🟡',
      low: '🟢'
    };
    return emojis[severity as keyof typeof emojis] || '⚪';
  }

  private generateRiskAssessment(summary: any): string {
    const totalVulns = summary.totalVulnerabilities;
    const criticalAndHigh = summary.criticalVulnerabilities + summary.highVulnerabilities;
    
    if (criticalAndHigh === 0) {
      return '✅ **LOW RISK** - No critical or high severity vulnerabilities detected.';
    } else if (criticalAndHigh <= 5) {
      return '⚠️ **MEDIUM RISK** - Some critical/high severity issues require attention.';
    } else {
      return '🚨 **HIGH RISK** - Multiple critical/high severity vulnerabilities require immediate action.';
    }
  }

  private generateTypeDistribution(vulnerabilities: Vulnerability[]): string {
    const typeCount = vulnerabilities.reduce((acc, vuln) => {
      acc[vuln.type] = (acc[vuln.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return Object.entries(typeCount)
      .sort(([,a], [,b]) => b - a)
      .map(([type, count]) => `- **${type.replace('-', ' ').toUpperCase()}**: ${count}`)
      .join('\n');
  }

  private getHighRiskFiles(vulnerabilities: Vulnerability[]): string {
    const fileRisk = vulnerabilities.reduce((acc, vuln) => {
      if (!acc[vuln.file]) {
        acc[vuln.file] = { critical: 0, high: 0, medium: 0, low: 0, total: 0 };
      }
      acc[vuln.file][vuln.severity]++;
      acc[vuln.file].total++;
      return acc;
    }, {} as Record<string, any>);

    return Object.entries(fileRisk)
      .filter(([, risk]) => risk.critical > 0 || risk.high > 0)
      .sort(([,a], [,b]) => (b.critical + b.high) - (a.critical + a.high))
      .slice(0, 10)
      .map(([file, risk]) => `- \`${file}\`: ${risk.total} issues (${risk.critical} critical, ${risk.high} high)`)
      .join('\n') || 'No high-risk files identified.';
  }
}

interface ScanRule {
  id: string;
  type: VulnerabilityType;
  severity: 'low' | 'medium' | 'high' | 'critical';
  pattern: RegExp;
  title: string;
  description: string;
  cwe?: string;
  cvss?: number;
  remediation: string;
  autoFixable: boolean;
}