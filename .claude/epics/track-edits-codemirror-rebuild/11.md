# Task 004: Decoration System Implementation

## Metadata
```yaml
task_id: 004
epic: track-edits-codemirror-rebuild
title: Decoration System Implementation
status: pending
priority: high
created: 2025-08-22T02:39:31Z
updated: 2025-08-22T02:39:31Z
estimated_hours: 6
depends_on: [002, 003]
parallel: false
tags:
  - decoration
  - widgets
  - marks
  - rendering
  - ui
```

## Description

Implement the hybrid decoration system using CodeMirror's native widget and mark decorations. This system will create visual representations of edits with deletion widgets (red strikethrough) and addition marks (green highlight), featuring automatic position mapping and immediate application without batching.

## Acceptance Criteria

- [ ] Create widget decorations for deletions with red strikethrough styling
- [ ] Create mark decorations for additions with green highlight styling
- [ ] Implement immediate decoration application (no batching)
- [ ] Set up automatic position mapping through StateField
- [ ] Create StateEffect system for add/remove operations
- [ ] Ensure clean decoration lifecycle management
- [ ] Add proper DOM structure for accessibility
- [ ] Implement decoration persistence across document changes

## Technical Requirements

### Widget Decoration System
```typescript
// Deletion widget component
const deletionWidget = Decoration.widget({
  widget: new DeletionWidget(deletedText, editId),
  side: 1,
  block: false
});

class DeletionWidget extends WidgetType {
  constructor(private text: string, private editId: string) {
    super();
  }
  
  toDOM(): HTMLElement {
    const span = document.createElement('span');
    span.className = 'track-edits-deletion';
    span.textContent = this.text;
    span.setAttribute('data-edit-id', this.editId);
    return span;
  }
}
```

### Mark Decoration System
```typescript
// Addition mark decoration
const additionMark = Decoration.mark({
  class: 'track-edits-addition',
  attributes: { 'data-edit-id': editId }
});
```

### StateEffect Types
```typescript
// Effects for decoration management
const addDecoration = StateEffect.define<{
  decoration: Decoration;
  from: number;
  to?: number;
}>({
  map: (val, mapping) => ({
    decoration: val.decoration,
    from: mapping.mapPos(val.from),
    to: val.to !== undefined ? mapping.mapPos(val.to) : undefined
  })
});

const removeDecoration = StateEffect.define<string>(); // editId
```

### Decoration StateField
- Manage DecorationSet with automatic position mapping
- Process add/remove StateEffects
- Handle decoration creation and cleanup
- Maintain decoration-to-edit mapping

## Implementation Notes

- Use CodeMirror's native position mapping (no manual calculations)
- Apply decorations immediately upon transaction processing
- Widget decorations for deletions preserve original text visibility
- Mark decorations for additions highlight new content
- Support nested and overlapping decorations
- Ensure decorations persist across document changes
- Handle edge cases (start/end of document, empty lines)

## Testing Strategy

- Test decoration creation for various edit types
- Verify position mapping accuracy after document changes
- Test decoration persistence across complex edits
- Validate DOM structure and accessibility
- Performance test with large numbers of decorations
- Test decoration cleanup and memory management

## Dependencies

- Task 002: ViewPlugin Implementation (for edit detection)
- Task 003: StateField Implementation (for state management)
- CodeMirror decoration APIs
- CSS styling for decoration appearance

## Files to Modify

- `src/main.ts` - Add decoration management to StateField
- `src/decorations.ts` - New file for decoration utilities
- `src/widgets.ts` - New file for widget implementations
- `styles.css` - Decoration styling

## Success Criteria

The task is complete when:
1. Widget decorations render deletions with proper styling
2. Mark decorations highlight additions correctly
3. Position mapping works automatically across edits
4. StateEffect system manages decoration lifecycle
5. Decorations persist across document changes
6. Performance meets < 16ms rendering target
7. DOM structure is accessible and semantic

## Notes

This decoration system is critical for user experience. Focus on immediate visual feedback and rock-solid persistence. The hybrid widget/mark approach ensures deletions remain visible (important for review) while additions are clearly highlighted. Automatic position mapping through StateField eliminates complex manual position tracking.
