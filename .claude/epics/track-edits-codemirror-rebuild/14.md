# Task 007: Side Panel UI Implementation âœ… COMPLETED

## Metadata
```yaml
task_id: 007
epic: track-edits-codemirror-rebuild
title: Side Panel UI Implementation
status: completed
priority: high
created: 2025-08-22T02:39:31Z
updated: 2025-08-22T06:15:00Z
completed: 2025-08-22T06:15:00Z
estimated_hours: 6
depends_on: [006]
parallel: [008]
tags:
  - ui
  - side-panel
  - clustering
  - user-experience
  - real-time-updates
```

## Description

Implement a clean side panel UI that displays intelligent edit clusters with code formatting and minimal labels. The panel provides cluster-level accept/reject operations with real-time updates using 100ms batching for optimal performance while maintaining a responsive user experience.

## Acceptance Criteria

- [x] Create clean side panel with proper Obsidian styling
- [x] Display edit clusters with code formatting and syntax highlighting
- [x] Implement cluster-level accept/reject operations
- [x] Add real-time updates with 100ms batching
- [x] Create minimal, informative labels for each cluster
- [x] Add cluster expansion/collapse functionality
- [x] Implement keyboard shortcuts for cluster operations
- [x] Ensure panel scrolling and performance optimization

## Technical Requirements

### Side Panel Architecture
```typescript
class TrackEditsView extends ItemView {
  private clustersContainer: HTMLElement;
  private updateTimer: number | null = null;
  private pendingUpdates: Set<string> = new Set();
  
  getViewType(): string {
    return 'track-edits-view';
  }
  
  getDisplayText(): string {
    return 'Track Edits';
  }
  
  async onOpen(): Promise<void> {
    this.createPanelStructure();
    this.setupEventListeners();
    this.startUpdateLoop();
  }
  
  private createPanelStructure(): void {
    const container = this.containerEl.children[1];
    container.empty();
    
    // Header with controls
    const header = container.createEl('div', { cls: 'track-edits-header' });
    header.createEl('h3', { text: 'Track Edits', cls: 'track-edits-title' });
    
    // Global controls
    const controls = header.createEl('div', { cls: 'track-edits-controls' });
    this.createGlobalControls(controls);
    
    // Clusters container
    this.clustersContainer = container.createEl('div', { 
      cls: 'track-edits-clusters' 
    });
  }
}
```

### Cluster Display Component
```typescript
interface ClusterDisplayData {
  cluster: EditCluster;
  isExpanded: boolean;
  previewText: string;
  contextLines: string[];
}

class ClusterRenderer {
  renderCluster(data: ClusterDisplayData, container: HTMLElement): HTMLElement {
    const clusterEl = container.createEl('div', { 
      cls: 'track-edits-cluster',
      attr: { 'data-cluster-id': data.cluster.id }
    });
    
    // Cluster header
    const header = clusterEl.createEl('div', { cls: 'cluster-header' });
    this.createClusterHeader(header, data);
    
    // Cluster content
    if (data.isExpanded) {
      const content = clusterEl.createEl('div', { cls: 'cluster-content' });
      this.createClusterContent(content, data);
    }
    
    // Cluster actions
    const actions = clusterEl.createEl('div', { cls: 'cluster-actions' });
    this.createClusterActions(actions, data.cluster);
    
    return clusterEl;
  }
  
  private createClusterHeader(header: HTMLElement, data: ClusterDisplayData): void {
    // Expand/collapse toggle
    const toggle = header.createEl('button', { 
      cls: 'cluster-toggle',
      attr: { 'aria-expanded': data.isExpanded.toString() }
    });
    toggle.createEl('span', { 
      cls: `cluster-toggle-icon ${data.isExpanded ? 'expanded' : 'collapsed'}` 
    });
    
    // Cluster type and summary
    const summary = header.createEl('div', { cls: 'cluster-summary' });
    summary.createEl('span', { 
      cls: `cluster-type ${data.cluster.type}`,
      text: this.getClusterTypeLabel(data.cluster.type)
    });
    summary.createEl('span', { 
      cls: 'cluster-preview',
      text: data.previewText
    });
    
    // Cluster metadata
    const meta = header.createEl('div', { cls: 'cluster-meta' });
    meta.createEl('span', { 
      cls: 'cluster-count',
      text: `${data.cluster.edits.length} edits`
    });
    meta.createEl('span', { 
      cls: 'cluster-time',
      text: this.formatRelativeTime(data.cluster.endTime)
    });
  }
}
```

### Real-time Updates with Batching
```typescript
class PanelUpdateManager {
  private updateTimer: number | null = null;
  private pendingUpdates: Set<string> = new Set();
  private readonly BATCH_DELAY = 100; // 100ms batching
  
  scheduleClusterUpdate(clusterId: string): void {
    this.pendingUpdates.add(clusterId);
    
    if (this.updateTimer === null) {
      this.updateTimer = window.setTimeout(() => {
        this.processBatchedUpdates();
      }, this.BATCH_DELAY);
    }
  }
  
  private processBatchedUpdates(): void {
    const clusterIds = Array.from(this.pendingUpdates);
    this.pendingUpdates.clear();
    this.updateTimer = null;
    
    // Batch DOM updates for performance
    const updates = clusterIds.map(id => ({
      id,
      cluster: this.getCluster(id),
      element: this.getClusterElement(id)
    })).filter(update => update.cluster && update.element);
    
    // Apply all updates in a single frame
    requestAnimationFrame(() => {
      updates.forEach(update => {
        this.updateClusterDisplay(update.element, update.cluster);
      });
    });
  }
  
  scheduleFullRefresh(): void {
    // Cancel pending updates and do full refresh
    if (this.updateTimer !== null) {
      clearTimeout(this.updateTimer);
      this.updateTimer = null;
    }
    this.pendingUpdates.clear();
    
    requestAnimationFrame(() => {
      this.refreshAllClusters();
    });
  }
}
```

### Cluster Operations Interface
```typescript
class ClusterOperationsUI {
  createClusterActions(container: HTMLElement, cluster: EditCluster): void {
    const actionBar = container.createEl('div', { cls: 'cluster-action-bar' });
    
    // Accept button
    const acceptBtn = actionBar.createEl('button', { 
      cls: 'cluster-action accept',
      text: 'Accept',
      attr: { 'data-action': 'accept', 'data-cluster-id': cluster.id }
    });
    acceptBtn.addEventListener('click', () => this.acceptCluster(cluster.id));
    
    // Reject button
    const rejectBtn = actionBar.createEl('button', { 
      cls: 'cluster-action reject',
      text: 'Reject',
      attr: { 'data-action': 'reject', 'data-cluster-id': cluster.id }
    });
    rejectBtn.addEventListener('click', () => this.rejectCluster(cluster.id));
    
    // Split cluster button (for complex clusters)
    if (cluster.edits.length > 3) {
      const splitBtn = actionBar.createEl('button', { 
        cls: 'cluster-action split',
        text: 'Split',
        attr: { 'data-action': 'split', 'data-cluster-id': cluster.id }
      });
      splitBtn.addEventListener('click', () => this.showSplitDialog(cluster.id));
    }
  }
  
  private acceptCluster(clusterId: string): void {
    const cluster = globalState.clusters.find(c => c.id === clusterId);
    if (!cluster) return;
    
    // Visual feedback
    this.showClusterFeedback(clusterId, 'accepting');
    
    // Execute accept operation
    clusterOperations.acceptCluster(cluster);
    
    // Update UI
    this.removeClusterFromPanel(clusterId);
  }
  
  private rejectCluster(clusterId: string): void {
    const cluster = globalState.clusters.find(c => c.id === clusterId);
    if (!cluster) return;
    
    // Visual feedback
    this.showClusterFeedback(clusterId, 'rejecting');
    
    // Execute reject operation
    clusterOperations.rejectCluster(cluster, activeTrackEditsView);
    
    // Update UI
    this.removeClusterFromPanel(clusterId);
  }
}
```

### Code Formatting and Syntax Highlighting
```typescript
class CodeDisplayFormatter {
  formatClusterContent(cluster: EditCluster, doc: Text): string {
    const edits = cluster.edits.sort((a, b) => a.position - b.position);
    const startPos = Math.min(...edits.map(e => e.position));
    const endPos = Math.max(...edits.map(e => e.position + e.length));
    
    // Get context around the edits
    const contextStart = Math.max(0, startPos - 50);
    const contextEnd = Math.min(doc.length, endPos + 50);
    const contextText = doc.sliceString(contextStart, contextEnd);
    
    // Apply syntax highlighting using Obsidian's built-in highlighter
    return this.applySyntaxHighlighting(contextText, edits, contextStart);
  }
  
  private applySyntaxHighlighting(text: string, edits: Edit[], offset: number): string {
    // Use Obsidian's markdown syntax highlighting
    const highlighted = this.highlightMarkdown(text);
    
    // Overlay edit highlighting
    return this.overlayEditHighlights(highlighted, edits, offset);
  }
  
  private overlayEditHighlights(html: string, edits: Edit[], offset: number): string {
    // Create DOM from highlighted HTML
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // Apply edit-specific styling
    edits.forEach(edit => {
      const relativePos = edit.position - offset;
      this.highlightEditInDOM(doc.body, edit, relativePos);
    });
    
    return doc.body.innerHTML;
  }
}
```

### Keyboard Shortcuts and Accessibility
```typescript
class PanelKeyboardHandler {
  setupKeyboardShortcuts(): void {
    this.scope = new KeyScope();
    
    // Accept selected cluster
    this.scope.register(['Mod+Enter'], () => {
      const selected = this.getSelectedCluster();
      if (selected) this.acceptCluster(selected.id);
    });
    
    // Reject selected cluster
    this.scope.register(['Mod+Backspace'], () => {
      const selected = this.getSelectedCluster();
      if (selected) this.rejectCluster(selected.id);
    });
    
    // Navigate clusters
    this.scope.register(['ArrowUp'], () => this.selectPreviousCluster());
    this.scope.register(['ArrowDown'], () => this.selectNextCluster());
    
    // Expand/collapse cluster
    this.scope.register(['Space'], () => this.toggleSelectedCluster());
    
    // Select all clusters
    this.scope.register(['Mod+a'], () => this.selectAllClusters());
  }
}
```

## Implementation Notes

- Use Obsidian's native styling system for consistent theming
- Implement virtual scrolling for large cluster lists
- Add loading states and smooth transitions
- Support cluster filtering and search functionality
- Handle edge cases (empty clusters, very large clusters)
- Optimize for mobile touch interactions
- Add tooltips and help text for user guidance
- Support undo/redo for cluster operations

## Testing Strategy

- Test with various cluster sizes and types
- Test real-time update performance with rapid edits
- Test keyboard navigation and accessibility
- Test panel resizing and responsive design
- Test integration with Obsidian theme system
- Performance test with 100+ clusters displayed
- Test cluster operation edge cases
- Validate user experience flows

## Dependencies

- Task 006: Edit Clustering Algorithm (for cluster data)
- Obsidian ItemView API
- Obsidian styling system
- CodeMirror text utilities

## Files to Modify

- `src/main.ts` - Add view registration and management
- `src/panel.ts` - New file for panel implementation
- `src/cluster-renderer.ts` - New file for cluster display logic
- `src/panel-updates.ts` - New file for real-time update management
- `styles.css` - Panel styling and responsive design

## Success Criteria

The task is complete when:
1. Side panel displays with proper Obsidian integration
2. Clusters are rendered with clean, readable formatting
3. Real-time updates work smoothly with 100ms batching
4. Cluster operations (accept/reject) function reliably
5. Keyboard shortcuts and accessibility features work
6. Panel performance scales with cluster count
7. Code formatting and syntax highlighting display correctly
8. User experience feels intuitive and responsive

## Notes

The side panel is the primary user interface for Track Edits, so it must feel polished and performant. Focus on clean visual design that integrates seamlessly with Obsidian's interface. The 100ms batching is critical for performance during rapid typing, but updates should still feel immediate to users. Code formatting should make it easy to understand what changed without being overwhelming. This UI will determine user adoption and satisfaction with the plugin.
