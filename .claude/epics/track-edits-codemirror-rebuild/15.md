# Task 008: AI Integration Component âœ… COMPLETED

## Metadata
```yaml
task_id: 008
epic: track-edits-codemirror-rebuild
title: AI Integration Component
status: completed
priority: medium
created: 2025-08-22T02:39:31Z
updated: 2025-08-22T06:30:00Z
completed: 2025-08-22T06:30:00Z
estimated_hours: 4
depends_on: [006]
parallel: [007]
tags:
  - ai-integration
  - pattern-analysis
  - toggle-component
  - writerr-infrastructure
  - unclear-detection
```

## Description

Implement a simple AI integration component with toggle switch and "Run Once" button that provides unclear pattern detection and analysis. This component integrates with existing Writerr AI infrastructure while maintaining clean state management between different AI modes and analysis types.

## Acceptance Criteria

- [x] Create AI toggle component with on/off states
- [x] Add "Run Once" button for manual AI analysis
- [x] Implement unclear pattern detection algorithm
- [x] Integrate with existing Writerr AI infrastructure
- [x] Add pattern analysis results display
- [x] Create clean state management for AI modes
- [x] Add AI processing indicators and feedback
- [x] Implement error handling for AI service failures

## Technical Requirements

### AI Toggle Component
```typescript
interface AIIntegrationState {
  isEnabled: boolean;
  isProcessing: boolean;
  lastAnalysis: number | null;
  mode: 'auto' | 'manual' | 'off';
  detectionSettings: {
    sensitivity: 'low' | 'medium' | 'high';
    patterns: string[];
    threshold: number;
  };
}

class AIIntegrationComponent {
  private state: AIIntegrationState;
  private toggleButton: HTMLElement;
  private runOnceButton: HTMLElement;
  private statusIndicator: HTMLElement;
  
  createAIControls(container: HTMLElement): void {
    const aiSection = container.createEl('div', { cls: 'ai-integration-section' });
    
    // Section header
    const header = aiSection.createEl('div', { cls: 'ai-section-header' });
    header.createEl('h4', { text: 'AI Analysis', cls: 'ai-section-title' });
    
    // Toggle switch
    const toggleContainer = aiSection.createEl('div', { cls: 'ai-toggle-container' });
    this.createToggleSwitch(toggleContainer);
    
    // Manual controls
    const controlsContainer = aiSection.createEl('div', { cls: 'ai-controls-container' });
    this.createManualControls(controlsContainer);
    
    // Status and results
    const statusContainer = aiSection.createEl('div', { cls: 'ai-status-container' });
    this.createStatusDisplay(statusContainer);
  }
  
  private createToggleSwitch(container: HTMLElement): void {
    const toggleWrapper = container.createEl('div', { cls: 'toggle-wrapper' });
    
    const label = toggleWrapper.createEl('label', { 
      cls: 'ai-toggle-label',
      text: 'Auto-detect unclear patterns'
    });
    
    this.toggleButton = toggleWrapper.createEl('button', { 
      cls: 'ai-toggle-switch',
      attr: { 'role': 'switch', 'aria-checked': 'false' }
    });
    
    const toggleSlider = this.toggleButton.createEl('div', { cls: 'toggle-slider' });
    
    this.toggleButton.addEventListener('click', () => {
      this.toggleAIMode();
    });
  }
  
  private createManualControls(container: HTMLElement): void {
    this.runOnceButton = container.createEl('button', { 
      cls: 'ai-run-once-button',
      text: 'Analyze Current Edits'
    });
    
    this.runOnceButton.addEventListener('click', () => {
      this.runManualAnalysis();
    });
    
    // Sensitivity slider
    const sensitivityContainer = container.createEl('div', { cls: 'sensitivity-container' });
    sensitivityContainer.createEl('label', { 
      text: 'Detection Sensitivity',
      cls: 'sensitivity-label'
    });
    
    const sensitivitySlider = sensitivityContainer.createEl('input', { 
      type: 'range',
      cls: 'sensitivity-slider',
      attr: { 'min': '1', 'max': '3', 'value': '2' }
    });
    
    sensitivitySlider.addEventListener('change', (e) => {
      this.updateSensitivity(parseInt((e.target as HTMLInputElement).value));
    });
  }
}
```

### Unclear Pattern Detection
```typescript
interface UnclearPattern {
  type: 'repetitive-edits' | 'conflicting-changes' | 'unclear-intent' | 'incomplete-thought';
  confidence: number;
  description: string;
  affectedClusters: string[];
  suggestion: string;
  evidence: {
    editCount: number;
    timeSpan: number;
    patterns: string[];
  };
}

class UnclearPatternDetector {
  private readonly REPETITIVE_THRESHOLD = 3;
  private readonly QUICK_SUCCESSION_MS = 1000;
  private readonly CONFIDENCE_THRESHOLD = 0.7;
  
  analyzeEditPatterns(clusters: EditCluster[]): UnclearPattern[] {
    const patterns: UnclearPattern[] = [];
    
    // Detect repetitive edits
    patterns.push(...this.detectRepetitiveEdits(clusters));
    
    // Detect conflicting changes
    patterns.push(...this.detectConflictingChanges(clusters));
    
    // Detect unclear intent
    patterns.push(...this.detectUnclearIntent(clusters));
    
    // Detect incomplete thoughts
    patterns.push(...this.detectIncompleteThoughts(clusters));
    
    return patterns.filter(p => p.confidence >= this.CONFIDENCE_THRESHOLD);
  }
  
  private detectRepetitiveEdits(clusters: EditCluster[]): UnclearPattern[] {
    const patterns: UnclearPattern[] = [];
    
    // Group clusters by position proximity
    const positionGroups = this.groupClustersByPosition(clusters);
    
    positionGroups.forEach(group => {
      if (group.length >= this.REPETITIVE_THRESHOLD) {
        const timeSpan = group[group.length - 1].endTime - group[0].startTime;
        
        if (timeSpan < 30000) { // 30 seconds
          patterns.push({
            type: 'repetitive-edits',
            confidence: Math.min(0.9, 0.5 + (group.length * 0.1)),
            description: `Multiple edits (${group.length}) in same area within ${Math.round(timeSpan/1000)}s`,
            affectedClusters: group.map(c => c.id),
            suggestion: 'Consider what you\'re trying to express and make a single, clear edit',
            evidence: {
              editCount: group.length,
              timeSpan,
              patterns: this.extractEditPatterns(group)
            }
          });
        }
      }
    });
    
    return patterns;
  }
  
  private detectConflictingChanges(clusters: EditCluster[]): UnclearPattern[] {
    const patterns: UnclearPattern[] = [];
    
    // Look for clusters that undo/redo similar changes
    for (let i = 0; i < clusters.length - 1; i++) {
      for (let j = i + 1; j < clusters.length; j++) {
        const cluster1 = clusters[i];
        const cluster2 = clusters[j];
        
        if (this.areClustersConflicting(cluster1, cluster2)) {
          patterns.push({
            type: 'conflicting-changes',
            confidence: 0.8,
            description: 'Detected edits that reverse or conflict with earlier changes',
            affectedClusters: [cluster1.id, cluster2.id],
            suggestion: 'Review these changes to clarify your intended meaning',
            evidence: {
              editCount: cluster1.edits.length + cluster2.edits.length,
              timeSpan: cluster2.endTime - cluster1.startTime,
              patterns: ['conflict-detected']
            }
          });
        }
      }
    }
    
    return patterns;
  }
  
  private detectUnclearIntent(clusters: EditCluster[]): UnclearPattern[] {
    const patterns: UnclearPattern[] = [];
    
    clusters.forEach(cluster => {
      const complexity = this.calculateClusterComplexity(cluster);
      const hasUnclearWords = this.containsUnclearLanguage(cluster);
      
      if (complexity > 0.7 || hasUnclearWords) {
        patterns.push({
          type: 'unclear-intent',
          confidence: Math.max(complexity, hasUnclearWords ? 0.6 : 0),
          description: 'This edit contains potentially unclear or complex language',
          affectedClusters: [cluster.id],
          suggestion: 'Consider simplifying or clarifying this text',
          evidence: {
            editCount: cluster.edits.length,
            timeSpan: cluster.endTime - cluster.startTime,
            patterns: ['complexity-high', ...(hasUnclearWords ? ['unclear-words'] : [])]
          }
        });
      }
    });
    
    return patterns;
  }
}
```

### Writerr AI Infrastructure Integration
```typescript
class WriterrAIIntegration {
  private aiProvider: WritterrAIProvider;
  private analysisQueue: AnalysisRequest[] = [];
  private isProcessing: boolean = false;
  
  constructor() {
    // Get AI provider from window.WriterrAI or similar global
    this.aiProvider = (window as any).WriterrAI?.getProvider() || null;
    
    if (!this.aiProvider) {
      console.warn('Writerr AI provider not available. AI features disabled.');
    }
  }
  
  async analyzeEditPatterns(clusters: EditCluster[]): Promise<AIAnalysisResult> {
    if (!this.aiProvider) {
      throw new Error('AI provider not available');
    }
    
    const request: AnalysisRequest = {
      type: 'edit-pattern-analysis',
      data: {
        clusters: clusters.map(c => this.serializeCluster(c)),
        context: this.getDocumentContext(),
        timestamp: Date.now()
      },
      options: {
        model: 'gpt-4-turbo',
        temperature: 0.1,
        maxTokens: 1000
      }
    };
    
    return await this.aiProvider.analyze(request);
  }
  
  async suggestImprovements(pattern: UnclearPattern): Promise<ImprovementSuggestion[]> {
    if (!this.aiProvider) {
      throw new Error('AI provider not available');
    }
    
    const prompt = this.buildImprovementPrompt(pattern);
    
    const request: AnalysisRequest = {
      type: 'improvement-suggestion',
      data: { pattern, prompt },
      options: {
        model: 'gpt-4-turbo',
        temperature: 0.3,
        maxTokens: 500
      }
    };
    
    const result = await this.aiProvider.analyze(request);
    return this.parseImprovementSuggestions(result);
  }
  
  private buildImprovementPrompt(pattern: UnclearPattern): string {
    return `
      The user has made editing patterns that suggest unclear writing intent.
      
      Pattern Type: ${pattern.type}
      Description: ${pattern.description}
      Confidence: ${pattern.confidence}
      
      Evidence:
      - Edit Count: ${pattern.evidence.editCount}
      - Time Span: ${pattern.evidence.timeSpan}ms
      - Patterns: ${pattern.evidence.patterns.join(', ')}
      
      Please provide 2-3 specific, actionable suggestions to help the user clarify their writing.
      Focus on concrete improvements rather than general advice.
    `;
  }
}
```

### State Management and UI Updates
```typescript
class AIStateManager {
  private state: AIIntegrationState;
  private listeners: Array<(state: AIIntegrationState) => void> = [];
  
  constructor() {
    this.state = {
      isEnabled: false,
      isProcessing: false,
      lastAnalysis: null,
      mode: 'off',
      detectionSettings: {
        sensitivity: 'medium',
        patterns: ['repetitive-edits', 'unclear-intent'],
        threshold: 0.7
      }
    };
  }
  
  enableAI(): void {
    this.updateState({
      isEnabled: true,
      mode: 'auto'
    });
    
    this.startAutoDetection();
  }
  
  disableAI(): void {
    this.updateState({
      isEnabled: false,
      mode: 'off'
    });
    
    this.stopAutoDetection();
  }
  
  async runManualAnalysis(): Promise<void> {
    if (this.state.isProcessing) return;
    
    this.updateState({ isProcessing: true, mode: 'manual' });
    
    try {
      const clusters = globalState.clusters;
      const patterns = await this.performAnalysis(clusters);
      
      this.displayAnalysisResults(patterns);
      
      this.updateState({
        isProcessing: false,
        lastAnalysis: Date.now()
      });
    } catch (error) {
      console.error('AI analysis failed:', error);
      this.updateState({ isProcessing: false });
      this.showError('Analysis failed. Please try again.');
    }
  }
  
  private updateState(updates: Partial<AIIntegrationState>): void {
    this.state = { ...this.state, ...updates };
    this.notifyListeners();
  }
  
  private notifyListeners(): void {
    this.listeners.forEach(listener => listener(this.state));
  }
}
```

### Analysis Results Display
```typescript
class AnalysisResultsRenderer {
  displayPatterns(patterns: UnclearPattern[], container: HTMLElement): void {
    container.empty();
    
    if (patterns.length === 0) {
      container.createEl('div', { 
        cls: 'ai-no-patterns',
        text: 'âœ“ No unclear patterns detected'
      });
      return;
    }
    
    const resultsHeader = container.createEl('div', { cls: 'ai-results-header' });
    resultsHeader.createEl('h5', { 
      text: `${patterns.length} pattern${patterns.length > 1 ? 's' : ''} detected`,
      cls: 'ai-results-title'
    });
    
    patterns.forEach(pattern => {
      this.renderPattern(pattern, container);
    });
  }
  
  private renderPattern(pattern: UnclearPattern, container: HTMLElement): void {
    const patternEl = container.createEl('div', { 
      cls: `ai-pattern ai-pattern-${pattern.type}` 
    });
    
    // Pattern header
    const header = patternEl.createEl('div', { cls: 'ai-pattern-header' });
    header.createEl('span', { 
      cls: 'ai-pattern-type',
      text: this.formatPatternType(pattern.type)
    });
    header.createEl('span', { 
      cls: 'ai-pattern-confidence',
      text: `${Math.round(pattern.confidence * 100)}%`
    });
    
    // Pattern description
    patternEl.createEl('p', { 
      cls: 'ai-pattern-description',
      text: pattern.description
    });
    
    // Pattern suggestion
    const suggestion = patternEl.createEl('div', { cls: 'ai-pattern-suggestion' });
    suggestion.createEl('strong', { text: 'Suggestion: ' });
    suggestion.createSpan({ text: pattern.suggestion });
    
    // Affected clusters links
    if (pattern.affectedClusters.length > 0) {
      const clustersEl = patternEl.createEl('div', { cls: 'ai-affected-clusters' });
      clustersEl.createEl('span', { text: 'Affected edits: ' });
      
      pattern.affectedClusters.forEach((clusterId, index) => {
        if (index > 0) clustersEl.createSpan({ text: ', ' });
        
        const link = clustersEl.createEl('a', { 
          href: '#',
          text: `Cluster ${index + 1}`,
          cls: 'ai-cluster-link'
        });
        
        link.addEventListener('click', (e) => {
          e.preventDefault();
          this.highlightCluster(clusterId);
        });
      });
    }
  }
}
```

## Implementation Notes

- Keep AI integration lightweight and optional
- Handle AI service failures gracefully
- Cache analysis results to avoid repeated processing
- Support offline mode with local pattern detection
- Add clear feedback for AI processing states
- Respect user privacy and data handling preferences
- Support different AI providers through abstraction layer
- Add configuration options for AI sensitivity and behavior

## Testing Strategy

- Test AI toggle functionality and state management
- Test manual analysis with various edit patterns
- Test integration with Writerr AI infrastructure
- Test error handling for AI service failures
- Test pattern detection accuracy with real editing scenarios
- Test performance impact of AI analysis
- Test UI responsiveness during AI processing
- Validate privacy and data handling compliance

## Dependencies

- Task 006: Edit Clustering Algorithm (for cluster data)
- Writerr AI Infrastructure (`window.WriterrAI`)
- Pattern detection algorithms
- AI provider abstraction layer

## Files to Modify

- `src/main.ts` - Add AI integration initialization
- `src/ai-integration.ts` - New file for AI component logic
- `src/pattern-detection.ts` - New file for unclear pattern detection
- `src/ai-state.ts` - New file for AI state management
- `src/ai-results.ts` - New file for analysis results display
- `styles.css` - AI component styling

## Success Criteria

The task is complete when:
1. AI toggle component functions correctly with state management
2. Manual "Run Once" analysis works reliably
3. Unclear pattern detection identifies common issues accurately
4. Integration with Writerr AI infrastructure is stable
5. Analysis results display clearly and helpfully
6. Error handling works gracefully for AI failures
7. Performance impact is minimal during analysis
8. User experience feels helpful without being intrusive

## Notes

The AI integration should feel like a helpful assistant rather than an intrusive analyzer. Focus on patterns that genuinely indicate unclear writing rather than over-analyzing every edit. The toggle should make it easy for users to control when AI analysis runs, and the "Run Once" button provides manual control for users who prefer it. Integration with existing Writerr AI infrastructure ensures consistency with other AI features in the ecosystem while maintaining clean separation of concerns.
