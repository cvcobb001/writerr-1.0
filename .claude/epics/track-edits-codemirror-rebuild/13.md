# Task 006: Edit Clustering Algorithm âœ… COMPLETED

## Metadata
```yaml
task_id: 006
epic: track-edits-codemirror-rebuild
title: Edit Clustering Algorithm
status: completed
priority: high
created: 2025-08-22T02:39:31Z
updated: 2025-08-22T06:00:00Z
completed: 2025-08-22T06:00:00Z
estimated_hours: 8
depends_on: [004, 005]
parallel: false
tags:
  - clustering
  - algorithm
  - word-boundaries
  - user-experience
  - intelligence
```

## Description

Implement intelligent edit clustering using word boundary detection with hybrid word replacement recognition. This algorithm groups related edits using a 2-second time window, position proximity, and edit type matching to provide meaningful cluster-level operations for users while maintaining real-time cluster recalculation.

## Acceptance Criteria

- [x] Implement word boundary detection using `findWordStart()/findWordEnd()`
- [x] Create hybrid word replacement recognition algorithm
- [x] Use 2-second time window for temporal clustering
- [x] Add position proximity and edit type matching
- [x] Implement real-time cluster recalculation
- [x] Create cluster merge and split operations
- [x] Add cluster-level accept/reject functionality
- [x] Ensure 95% clustering accuracy for common editing patterns

## Technical Requirements

### Word Boundary Detection
```typescript
// Core word boundary utilities
function findWordStart(doc: Text, pos: number): number {
  const line = doc.lineAt(pos);
  const lineText = line.text;
  const offsetInLine = pos - line.from;
  
  // Move backwards to find word start
  let start = offsetInLine;
  while (start > 0 && /\w/.test(lineText[start - 1])) {
    start--;
  }
  
  return line.from + start;
}

function findWordEnd(doc: Text, pos: number): number {
  const line = doc.lineAt(pos);
  const lineText = line.text;
  const offsetInLine = pos - line.from;
  
  // Move forwards to find word end
  let end = offsetInLine;
  while (end < lineText.length && /\w/.test(lineText[end])) {
    end++;
  }
  
  return line.from + end;
}
```

### Clustering Algorithm
```typescript
interface EditCluster {
  id: string;
  edits: Edit[];
  type: 'deletion' | 'insertion' | 'replacement';
  startPosition: number;
  endPosition: number;
  startTime: number;
  endTime: number;
  wordBoundary: {
    start: number;
    end: number;
  };
}

class ClusteringEngine {
  private clusters: EditCluster[] = [];
  private readonly TIME_WINDOW = 2000; // 2 seconds
  private readonly MAX_POSITION_GAP = 10; // characters
  
  addEdit(edit: Edit, doc: Text): void {
    const candidates = this.findClusterCandidates(edit);
    
    if (candidates.length === 0) {
      this.createNewCluster(edit, doc);
    } else {
      this.mergeIntoCluster(edit, candidates[0], doc);
    }
    
    this.recalculateClusters(doc);
  }
  
  private findClusterCandidates(edit: Edit): EditCluster[] {
    return this.clusters.filter(cluster => {
      // Time window check
      const timeDiff = edit.timestamp - cluster.endTime;
      if (timeDiff > this.TIME_WINDOW) return false;
      
      // Position proximity check
      const positionDiff = Math.abs(edit.position - cluster.endPosition);
      if (positionDiff > this.MAX_POSITION_GAP) return false;
      
      // Edit type compatibility
      return this.areEditsCompatible(edit, cluster);
    });
  }
}
```

### Hybrid Word Replacement Detection
```typescript
// Detect word replacement patterns
function detectWordReplacement(edits: Edit[], doc: Text): boolean {
  // Look for deletion followed by insertion at same position
  const sortedEdits = edits.sort((a, b) => a.timestamp - b.timestamp);
  
  for (let i = 0; i < sortedEdits.length - 1; i++) {
    const deletion = sortedEdits[i];
    const insertion = sortedEdits[i + 1];
    
    if (deletion.type === 'deletion' && 
        insertion.type === 'insertion' &&
        insertion.timestamp - deletion.timestamp < 500 && // 500ms window
        Math.abs(insertion.position - deletion.position) <= 2) {
      
      // Check if both are at word boundaries
      const wordStart = findWordStart(doc, deletion.position);
      const wordEnd = findWordEnd(doc, insertion.position + insertion.newText!.length);
      
      if (deletion.position >= wordStart && 
          insertion.position + insertion.newText!.length <= wordEnd) {
        return true;
      }
    }
  }
  
  return false;
}
```

### Cluster Operations
```typescript
// Cluster-level operations
class ClusterOperations {
  acceptCluster(cluster: EditCluster): void {
    // Remove all decorations for edits in cluster
    cluster.edits.forEach(edit => {
      dispatch(removeDecoration.of(edit.id));
    });
    
    // Remove cluster from tracking
    this.removeCluster(cluster.id);
  }
  
  rejectCluster(cluster: EditCluster, view: EditorView): void {
    // Revert edits in reverse chronological order
    const sortedEdits = cluster.edits.sort((a, b) => b.timestamp - a.timestamp);
    
    for (const edit of sortedEdits) {
      this.revertEdit(edit, view);
    }
    
    // Remove cluster from tracking
    this.removeCluster(cluster.id);
  }
}
```

### Real-time Recalculation
- Monitor edit additions and removals
- Recalculate cluster boundaries on changes
- Merge adjacent clusters when appropriate
- Split clusters that exceed boundaries
- Update cluster metadata (start/end positions, times)

## Implementation Notes

- Use word boundaries as primary clustering criteria
- Handle partial word edits and word replacement patterns
- Maintain cluster stability (avoid excessive splitting/merging)
- Consider edit velocity in clustering decisions
- Support user-driven cluster manual adjustments
- Handle multi-line edits and complex text operations
- Optimize for common typing patterns (autocorrect, backspace-retype)

## Testing Strategy

- Test single word editing patterns
- Test word replacement scenarios (autocorrect)
- Test rapid typing with backspace corrections
- Test multi-word operations (cut/paste)
- Test edge cases (punctuation, numbers, special characters)
- Performance test cluster recalculation speed
- Test cluster stability under various edit patterns
- Validate clustering accuracy against human expectations

## Dependencies

- Task 004: Decoration System (for cluster visualization)
- Task 005: Change Detection (for edit data)
- CodeMirror text utilities
- Word boundary detection algorithms

## Files to Modify

- `src/main.ts` - Add clustering engine integration
- `src/clustering.ts` - New file for clustering algorithm
- `src/word-boundaries.ts` - New file for boundary detection
- `src/cluster-operations.ts` - New file for cluster management

## Success Criteria

The task is complete when:
1. Word boundary detection works accurately across text types
2. Clustering algorithm achieves 95% accuracy for common patterns
3. Real-time recalculation performs within 100ms
4. Hybrid word replacement detection works reliably
5. Cluster operations (accept/reject) function correctly
6. Algorithm handles edge cases gracefully
7. Performance scales with document size and edit volume
8. User experience feels natural and predictable

## Notes

This is the intelligence layer that makes Track Edits truly useful. The clustering algorithm must balance accuracy with performance, creating meaningful groups that match user mental models of their editing actions. Focus on common editing patterns (typing, corrections, word replacements) while ensuring the system remains responsive and predictable. The 95% accuracy target is critical for user trust and adoption.
